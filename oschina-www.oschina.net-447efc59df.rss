<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:itunes="http://www.itunes.com/dtds/podcast-1.0.dtd" xmlns:googleplay="http://www.google.com/schemas/play-podcasts/1.0" xmlns:media="http://www.rssboard.org/media-rss" version="2.0">
  <channel>
    <title><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></title>
    <link>undefined</link>
    <image>
      <url>https://www.oschina.net/img/logo.gif</url>
      <title>OSCHINA 社区最新新闻[RSS+]</title>
      <link>undefined</link>
    </image>
    <language>zh-CN</language>
    <atom:link href="https://www.oschina.net/news/rss" rel="self" type="application/rss+xml"/>
    <copyright><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></copyright>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[
      OSCHINA - 中文开源技术交流社区<br />
<br />
<a href="https://www.oschina.net/news/rss" target="_blank">https://www.oschina.net/news/rss</a>
      ]]>
    </itunes:summary>
    <description>
      <![CDATA[
      OSCHINA - 中文开源技术交流社区<br />
<br />
<a href="https://www.oschina.net/news/rss" target="_blank">https://www.oschina.net/news/rss</a>
      ]]>
    </description>
    <itunes:owner>
      <itunes:name><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:name>
    </itunes:owner>
    <itunes:image href="https://www.oschina.net/img/logo.gif"/>
<item>
    <title><![CDATA[黄仁勋：英伟达 AI 芯片在华份额由 95% 暴跌至 0%]]></title>
    <link>https://www.oschina.net/news/378040</link>
    <itunes:title><![CDATA[黄仁勋：英伟达 AI 芯片在华份额由 95% 暴跌至 0%]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>近日黄仁勋接受采访时表示，英伟达AI芯片在华份额由95%暴跌至0%。</p>
<p>在黄仁勋看来，人工智能和任何计算软件行业最重要的是开发者，因为成功的开发人员创造了未来的平台。而中国拥有着全球约50%的人工智能开发人员，这也是为什么中国在被限制进口先进AI芯片，也依然能够开发出DeepSeek这样的出色的人工智能技术的原因。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4e8fb108a7.png"></p>
<p>黄仁勋表示，如果希望世界建立在美国技术的基础上，那就需要创造出能够让世界依赖的美国技术，而英伟达有这样的技术。但是限制英伟达技术的对华出口，就限制了中国庞大的人工智能开发人员使用美国技术。</p>
<p>“如果我们100%不在中国，那么我们在中国市场的份额就是0%。我们（在中国AI市场的份额）从95%变成了0%。”</p>
<p>黄仁勋指出：“<span><strong>我无法想象任何政策制定者会愿意看到（英伟达）在中国这个世界上最大的市场之一的市场份额降低到0%。</strong></span>”</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>近日黄仁勋接受采访时表示，英伟达AI芯片在华份额由95%暴跌至0%。</p>
<p>在黄仁勋看来，人工智能和任何计算软件行业最重要的是开发者，因为成功的开发人员创造了未来的平台。而中国拥有着全球约50%的人工智能开发人员，这也是为什么中国在被限制进口先进AI芯片，也依然能够开发出DeepSeek这样的出色的人工智能技术的原因。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4e8fb108a7.png"></p>
<p>黄仁勋表示，如果希望世界建立在美国技术的基础上，那就需要创造出能够让世界依赖的美国技术，而英伟达有这样的技术。但是限制英伟达技术的对华出口，就限制了中国庞大的人工智能开发人员使用美国技术。</p>
<p>“如果我们100%不在中国，那么我们在中国市场的份额就是0%。我们（在中国AI市场的份额）从95%变成了0%。”</p>
<p>黄仁勋指出：“<span><strong>我无法想象任何政策制定者会愿意看到（英伟达）在中国这个世界上最大的市场之一的市场份额降低到0%。</strong></span>”</p>]]>
    </description>
    <content:encoded><![CDATA[<p>近日黄仁勋接受采访时表示，英伟达AI芯片在华份额由95%暴跌至0%。</p>
<p>在黄仁勋看来，人工智能和任何计算软件行业最重要的是开发者，因为成功的开发人员创造了未来的平台。而中国拥有着全球约50%的人工智能开发人员，这也是为什么中国在被限制进口先进AI芯片，也依然能够开发出DeepSeek这样的出色的人工智能技术的原因。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4e8fb108a7.png"></p>
<p>黄仁勋表示，如果希望世界建立在美国技术的基础上，那就需要创造出能够让世界依赖的美国技术，而英伟达有这样的技术。但是限制英伟达技术的对华出口，就限制了中国庞大的人工智能开发人员使用美国技术。</p>
<p>“如果我们100%不在中国，那么我们在中国市场的份额就是0%。我们（在中国AI市场的份额）从95%变成了0%。”</p>
<p>黄仁勋指出：“<span><strong>我无法想象任何政策制定者会愿意看到（英伟达）在中国这个世界上最大的市场之一的市场份额降低到0%。</strong></span>”</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4e8fb108a7.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4e8fb108a7.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 19:32:21 +0800</pubDate>
  </item><item>
    <title><![CDATA[李飞飞创业公司 World Labs 发布实时生成式世界模型 RTFM]]></title>
    <link>https://www.oschina.net/news/378039</link>
    <itunes:title><![CDATA[李飞飞创业公司 World Labs 发布实时生成式世界模型 RTFM]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>斯坦福大学教授李飞飞创业公司 World Labs&nbsp; 发布了全新<span><strong>实时生成式世界模型RTFM（Real-Time Frame Model）</strong></span>，称这是一个实时、持持续运行且保持3D一致性的生成式世界模型，亮点是可在单个H100 GPU上运行。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-5e741e71a6.jpg"></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-a2b25a6447.jpg"></p>
<p>据介绍，RTFM基于自回归扩散Transformer架构，通过端到端训练大规模视频数据，无需显式3D建模即可生成多视角2D图像，并模拟反射、阴影等复杂物理效果。模型支持从稀疏照片重建真实场景，结合空间记忆和上下文调度技术，确保场景持久性与一致性。</p>
<p><strong>性能优势</strong></p>
<ul>
<li>单块H100 GPU即可实时渲染交互式画面，帧率稳定，算力需求远低于传统方案（如生成1小时4K视频需处理超1亿token）。</li>
<li>设计遵循高效性、可扩展性、持久性三大原则，未来可随算力提升扩展模型规模。</li>
</ul>
<p>李飞飞团队表示，未来World Labs将进一步增强模型动态场景模拟与用户交互功能，更大规模模型有望带来更优性能。</p>
<ul>
</ul>
<p>模型地址：<em>https://rtfm.worldlabs.ai/</em></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>斯坦福大学教授李飞飞创业公司 World Labs&nbsp; 发布了全新<span><strong>实时生成式世界模型RTFM（Real-Time Frame Model）</strong></span>，称这是一个实时、持持续运行且保持3D一致性的生成式世界模型，亮点是可在单个H100 GPU上运行。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-5e741e71a6.jpg"></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-a2b25a6447.jpg"></p>
<p>据介绍，RTFM基于自回归扩散Transformer架构，通过端到端训练大规模视频数据，无需显式3D建模即可生成多视角2D图像，并模拟反射、阴影等复杂物理效果。模型支持从稀疏照片重建真实场景，结合空间记忆和上下文调度技术，确保场景持久性与一致性。</p>
<p><strong>性能优势</strong></p>
<ul>
<li>单块H100 GPU即可实时渲染交互式画面，帧率稳定，算力需求远低于传统方案（如生成1小时4K视频需处理超1亿token）。</li>
<li>设计遵循高效性、可扩展性、持久性三大原则，未来可随算力提升扩展模型规模。</li>
</ul>
<p>李飞飞团队表示，未来World Labs将进一步增强模型动态场景模拟与用户交互功能，更大规模模型有望带来更优性能。</p>
<ul>
</ul>
<p>模型地址：<em>https://rtfm.worldlabs.ai/</em></p>]]>
    </description>
    <content:encoded><![CDATA[<p>斯坦福大学教授李飞飞创业公司 World Labs&nbsp; 发布了全新<span><strong>实时生成式世界模型RTFM（Real-Time Frame Model）</strong></span>，称这是一个实时、持持续运行且保持3D一致性的生成式世界模型，亮点是可在单个H100 GPU上运行。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-5e741e71a6.jpg"></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-a2b25a6447.jpg"></p>
<p>据介绍，RTFM基于自回归扩散Transformer架构，通过端到端训练大规模视频数据，无需显式3D建模即可生成多视角2D图像，并模拟反射、阴影等复杂物理效果。模型支持从稀疏照片重建真实场景，结合空间记忆和上下文调度技术，确保场景持久性与一致性。</p>
<p><strong>性能优势</strong></p>
<ul>
<li>单块H100 GPU即可实时渲染交互式画面，帧率稳定，算力需求远低于传统方案（如生成1小时4K视频需处理超1亿token）。</li>
<li>设计遵循高效性、可扩展性、持久性三大原则，未来可随算力提升扩展模型规模。</li>
</ul>
<p>李飞飞团队表示，未来World Labs将进一步增强模型动态场景模拟与用户交互功能，更大规模模型有望带来更优性能。</p>
<ul>
</ul>
<p>模型地址：<em>https://rtfm.worldlabs.ai/</em></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-5e741e71a6.jpg"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-5e741e71a6.jpg" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 19:25:06 +0800</pubDate>
  </item><item>
    <title><![CDATA[科学家成功开发全球首台完全不含硅的计算机系统]]></title>
    <link>https://www.oschina.net/news/378037</link>
    <itunes:title><![CDATA[科学家成功开发全球首台完全不含硅的计算机系统]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>美国宾夕法尼亚州立大学的研究团队近日宣布，他们成功开发了全球首台完全不含硅的计算机系统，采用原子级薄层材料制成。这一突破有望重塑电子设备行业，为更高效、更微型化的计算设备铺平道路。</p>
<p>长久以来，硅一直是智能手机、计算机、电动车等半导体技术的核心材料，但其主导地位正受到挑战。宾夕法尼亚州立大学的科学家们首次利用二维（2D）材料制造出可实现基本运算功能的计算机，彰显了电子材料创新的新方向。</p>
<p>研究团队在最新一期《自然》杂志上发表了成果。他们介绍说，首次实现了“不含硅”的互补金属氧化物半导体（CMOS）计算机的制作。CMOS是当前几乎所有电子设备的核心技术，而此次却完全没有使用硅，而是采用了两种不同的二维材料：二硫化钼（MoS₂）和二硒化钨（WSe₂）。前者用于制作n型晶体管，后者则用于p型晶体管，通过两者的协同作用完成电流的调控。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-64cde03ade.png"></p>
<p>项目负责人、工程学教授Saptarshi Das表示：“硅材料多年来推动了电子科技的不断微型化，但在纳米尺度下，硅器件开始出现性能衰减。而2D材料则可以在原子级厚度下保持优异的电子特性，极具发展潜力。”</p>
<p>Das补充说明，CMOS技术需要n型与p型晶体管协作，才能兼顾高性能与低功耗，这也是此前业界无法完全脱离硅材料的重要原因。虽然早前已有人用二维材料做出简单电路，但此次宾夕法尼亚团队实现了大规模晶体管集成，真正制造出可运行的一体化计算机。</p>
<p>据介绍，研究团队采用金属有机化学气相沉积（MOCVD）技术，分别制备了大面积的二硫化钼与二硒化钨薄膜。在此基础上集成了超千个n型和p型晶体管，通过微调制造及后处理工艺，成功调节了两种晶体管的阈值电压，实现了完整的CMOS逻辑电路。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-34284f8832.png"></p>
<p>团队成员、博士生Subir Ghosh指出，他们的2D CMOS计算机能以极低电压运行，实现简单的逻辑运算，工作频率最高可达25千赫兹。虽然速度远不及传统硅CMOS芯片，但已可以完成基础指令集的运算。</p>
<p>Ghosh还表示，他们建立了基于实验数据并结合器件差异的计算模型，用以预测2D计算机的性能，并与现有硅技术进行对标。虽然仍有进一步优化空间，但这项工作已在电子材料创新领域迈出了重要一步。</p>
<p>Das表示，未来二维CMOS计算机距离实际应用还有不少工作要做，但他强调，自2010年左右起，2D材料相关研究进展迅速。对比硅技术长达80年的发展历程，2D材料计算机的进步令人振奋。</p>
<p>该项目得到了美国国家科学基金会、陆军研究办公室及海军研究办公室等机构的部分资助。</p>
<p>编译自/<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fscitechdaily.com%2Fis-this-the-end-of-the-silicon-era-scientists-unveil-worlds-first-2d-computer%2F" target="_blank">ScitechDaily</a></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>美国宾夕法尼亚州立大学的研究团队近日宣布，他们成功开发了全球首台完全不含硅的计算机系统，采用原子级薄层材料制成。这一突破有望重塑电子设备行业，为更高效、更微型化的计算设备铺平道路。</p>
<p>长久以来，硅一直是智能手机、计算机、电动车等半导体技术的核心材料，但其主导地位正受到挑战。宾夕法尼亚州立大学的科学家们首次利用二维（2D）材料制造出可实现基本运算功能的计算机，彰显了电子材料创新的新方向。</p>
<p>研究团队在最新一期《自然》杂志上发表了成果。他们介绍说，首次实现了“不含硅”的互补金属氧化物半导体（CMOS）计算机的制作。CMOS是当前几乎所有电子设备的核心技术，而此次却完全没有使用硅，而是采用了两种不同的二维材料：二硫化钼（MoS₂）和二硒化钨（WSe₂）。前者用于制作n型晶体管，后者则用于p型晶体管，通过两者的协同作用完成电流的调控。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-64cde03ade.png"></p>
<p>项目负责人、工程学教授Saptarshi Das表示：“硅材料多年来推动了电子科技的不断微型化，但在纳米尺度下，硅器件开始出现性能衰减。而2D材料则可以在原子级厚度下保持优异的电子特性，极具发展潜力。”</p>
<p>Das补充说明，CMOS技术需要n型与p型晶体管协作，才能兼顾高性能与低功耗，这也是此前业界无法完全脱离硅材料的重要原因。虽然早前已有人用二维材料做出简单电路，但此次宾夕法尼亚团队实现了大规模晶体管集成，真正制造出可运行的一体化计算机。</p>
<p>据介绍，研究团队采用金属有机化学气相沉积（MOCVD）技术，分别制备了大面积的二硫化钼与二硒化钨薄膜。在此基础上集成了超千个n型和p型晶体管，通过微调制造及后处理工艺，成功调节了两种晶体管的阈值电压，实现了完整的CMOS逻辑电路。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-34284f8832.png"></p>
<p>团队成员、博士生Subir Ghosh指出，他们的2D CMOS计算机能以极低电压运行，实现简单的逻辑运算，工作频率最高可达25千赫兹。虽然速度远不及传统硅CMOS芯片，但已可以完成基础指令集的运算。</p>
<p>Ghosh还表示，他们建立了基于实验数据并结合器件差异的计算模型，用以预测2D计算机的性能，并与现有硅技术进行对标。虽然仍有进一步优化空间，但这项工作已在电子材料创新领域迈出了重要一步。</p>
<p>Das表示，未来二维CMOS计算机距离实际应用还有不少工作要做，但他强调，自2010年左右起，2D材料相关研究进展迅速。对比硅技术长达80年的发展历程，2D材料计算机的进步令人振奋。</p>
<p>该项目得到了美国国家科学基金会、陆军研究办公室及海军研究办公室等机构的部分资助。</p>
<p>编译自/<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fscitechdaily.com%2Fis-this-the-end-of-the-silicon-era-scientists-unveil-worlds-first-2d-computer%2F" target="_blank">ScitechDaily</a></p>]]>
    </description>
    <content:encoded><![CDATA[<p>美国宾夕法尼亚州立大学的研究团队近日宣布，他们成功开发了全球首台完全不含硅的计算机系统，采用原子级薄层材料制成。这一突破有望重塑电子设备行业，为更高效、更微型化的计算设备铺平道路。</p>
<p>长久以来，硅一直是智能手机、计算机、电动车等半导体技术的核心材料，但其主导地位正受到挑战。宾夕法尼亚州立大学的科学家们首次利用二维（2D）材料制造出可实现基本运算功能的计算机，彰显了电子材料创新的新方向。</p>
<p>研究团队在最新一期《自然》杂志上发表了成果。他们介绍说，首次实现了“不含硅”的互补金属氧化物半导体（CMOS）计算机的制作。CMOS是当前几乎所有电子设备的核心技术，而此次却完全没有使用硅，而是采用了两种不同的二维材料：二硫化钼（MoS₂）和二硒化钨（WSe₂）。前者用于制作n型晶体管，后者则用于p型晶体管，通过两者的协同作用完成电流的调控。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-64cde03ade.png"></p>
<p>项目负责人、工程学教授Saptarshi Das表示：“硅材料多年来推动了电子科技的不断微型化，但在纳米尺度下，硅器件开始出现性能衰减。而2D材料则可以在原子级厚度下保持优异的电子特性，极具发展潜力。”</p>
<p>Das补充说明，CMOS技术需要n型与p型晶体管协作，才能兼顾高性能与低功耗，这也是此前业界无法完全脱离硅材料的重要原因。虽然早前已有人用二维材料做出简单电路，但此次宾夕法尼亚团队实现了大规模晶体管集成，真正制造出可运行的一体化计算机。</p>
<p>据介绍，研究团队采用金属有机化学气相沉积（MOCVD）技术，分别制备了大面积的二硫化钼与二硒化钨薄膜。在此基础上集成了超千个n型和p型晶体管，通过微调制造及后处理工艺，成功调节了两种晶体管的阈值电压，实现了完整的CMOS逻辑电路。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-34284f8832.png"></p>
<p>团队成员、博士生Subir Ghosh指出，他们的2D CMOS计算机能以极低电压运行，实现简单的逻辑运算，工作频率最高可达25千赫兹。虽然速度远不及传统硅CMOS芯片，但已可以完成基础指令集的运算。</p>
<p>Ghosh还表示，他们建立了基于实验数据并结合器件差异的计算模型，用以预测2D计算机的性能，并与现有硅技术进行对标。虽然仍有进一步优化空间，但这项工作已在电子材料创新领域迈出了重要一步。</p>
<p>Das表示，未来二维CMOS计算机距离实际应用还有不少工作要做，但他强调，自2010年左右起，2D材料相关研究进展迅速。对比硅技术长达80年的发展历程，2D材料计算机的进步令人振奋。</p>
<p>该项目得到了美国国家科学基金会、陆军研究办公室及海军研究办公室等机构的部分资助。</p>
<p>编译自/<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fscitechdaily.com%2Fis-this-the-end-of-the-silicon-era-scientists-unveil-worlds-first-2d-computer%2F" target="_blank">ScitechDaily</a></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-64cde03ade.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-64cde03ade.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 18:58:52 +0800</pubDate>
  </item><item>
    <title><![CDATA[Fedora 43 因关键缺陷未修复而延期发布]]></title>
    <link>https://www.oschina.net/news/378035</link>
    <itunes:title><![CDATA[Fedora 43 因关键缺陷未修复而延期发布]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>Fedora 43 原定的最终发布日是 2025 年 10 月 21 日（下周）。但在最新版发布会议上，该版本被宣布为<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flists.fedoraproject.org%2Farchives%2Flist%2Fdevel-announce%40lists.fedoraproject.org%2Fthread%2FHOGWDCLA56C5G2N4QG5QPE42DKKMXTDK%2F" target="_blank"> “No-Go”（不可发布）</a>——意味着还不能按时发布。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-df1db68cb8.png"></p>
<p>根据会议讨论，Fedora 当前在其<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fqa.fedoraproject.org%2Fblockerbugs%2Fmilestone%2F43%2Ffinal%2Fbuglist" target="_blank">阻塞性 bug 列表</a>中有十个已被接受的关键缺陷，这些问题涵盖多个关键组件或领域：</p>
<ul>
<li> <p>安装程序 Anaconda 出现问题</p> </li>
<li> <p>GDM（GNOME Display Manager）和 GNOME Shell 出现问题</p> </li>
<li> <p>硬件回归（即某些硬件在 Fedora 43 中的支持反而退步），例如对 Mediatek MT7922 WiFi 的支持出错&nbsp;<br> 有些问题已被验证（verified），有些还在等待质量检测（QA）确认。</p> </li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5cc5ef303c.png"></p>
<p>因此，Fedora 开发者计划在下一个会议（文章中提到是星期四那天）再评估这些阻塞性缺陷的修复情况，如果情况允许，就在 2025 年 10 月 28 日发布 Fedora 43。否则还有后备发布时间：11 月 4 日或 11 月 11 日。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2991d04fc9.png"></p>
<p>众所周知，Fedora 版本常因缺陷延迟发布是常事；近年来，Fedora 团队在版本发布时间管理上改善很多，有些发行版甚至比预定早发布。但这次 Fedora 43 的开发遇到的关键缺陷，让其无法如期发布。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>Fedora 43 原定的最终发布日是 2025 年 10 月 21 日（下周）。但在最新版发布会议上，该版本被宣布为<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flists.fedoraproject.org%2Farchives%2Flist%2Fdevel-announce%40lists.fedoraproject.org%2Fthread%2FHOGWDCLA56C5G2N4QG5QPE42DKKMXTDK%2F" target="_blank"> “No-Go”（不可发布）</a>——意味着还不能按时发布。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-df1db68cb8.png"></p>
<p>根据会议讨论，Fedora 当前在其<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fqa.fedoraproject.org%2Fblockerbugs%2Fmilestone%2F43%2Ffinal%2Fbuglist" target="_blank">阻塞性 bug 列表</a>中有十个已被接受的关键缺陷，这些问题涵盖多个关键组件或领域：</p>
<ul>
<li> <p>安装程序 Anaconda 出现问题</p> </li>
<li> <p>GDM（GNOME Display Manager）和 GNOME Shell 出现问题</p> </li>
<li> <p>硬件回归（即某些硬件在 Fedora 43 中的支持反而退步），例如对 Mediatek MT7922 WiFi 的支持出错&nbsp;<br> 有些问题已被验证（verified），有些还在等待质量检测（QA）确认。</p> </li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5cc5ef303c.png"></p>
<p>因此，Fedora 开发者计划在下一个会议（文章中提到是星期四那天）再评估这些阻塞性缺陷的修复情况，如果情况允许，就在 2025 年 10 月 28 日发布 Fedora 43。否则还有后备发布时间：11 月 4 日或 11 月 11 日。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2991d04fc9.png"></p>
<p>众所周知，Fedora 版本常因缺陷延迟发布是常事；近年来，Fedora 团队在版本发布时间管理上改善很多，有些发行版甚至比预定早发布。但这次 Fedora 43 的开发遇到的关键缺陷，让其无法如期发布。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>Fedora 43 原定的最终发布日是 2025 年 10 月 21 日（下周）。但在最新版发布会议上，该版本被宣布为<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Flists.fedoraproject.org%2Farchives%2Flist%2Fdevel-announce%40lists.fedoraproject.org%2Fthread%2FHOGWDCLA56C5G2N4QG5QPE42DKKMXTDK%2F" target="_blank"> “No-Go”（不可发布）</a>——意味着还不能按时发布。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-df1db68cb8.png"></p>
<p>根据会议讨论，Fedora 当前在其<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fqa.fedoraproject.org%2Fblockerbugs%2Fmilestone%2F43%2Ffinal%2Fbuglist" target="_blank">阻塞性 bug 列表</a>中有十个已被接受的关键缺陷，这些问题涵盖多个关键组件或领域：</p>
<ul>
<li> <p>安装程序 Anaconda 出现问题</p> </li>
<li> <p>GDM（GNOME Display Manager）和 GNOME Shell 出现问题</p> </li>
<li> <p>硬件回归（即某些硬件在 Fedora 43 中的支持反而退步），例如对 Mediatek MT7922 WiFi 的支持出错&nbsp;<br> 有些问题已被验证（verified），有些还在等待质量检测（QA）确认。</p> </li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5cc5ef303c.png"></p>
<p>因此，Fedora 开发者计划在下一个会议（文章中提到是星期四那天）再评估这些阻塞性缺陷的修复情况，如果情况允许，就在 2025 年 10 月 28 日发布 Fedora 43。否则还有后备发布时间：11 月 4 日或 11 月 11 日。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2991d04fc9.png"></p>
<p>众所周知，Fedora 版本常因缺陷延迟发布是常事；近年来，Fedora 团队在版本发布时间管理上改善很多，有些发行版甚至比预定早发布。但这次 Fedora 43 的开发遇到的关键缺陷，让其无法如期发布。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-df1db68cb8.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-df1db68cb8.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 18:38:13 +0800</pubDate>
  </item><item>
    <title><![CDATA[【AI 智能运维平台】1017日平台更新速递（Blueking Lite）]]></title>
    <link>https://www.oschina.net/news/378029</link>
    <itunes:title><![CDATA[【AI 智能运维平台】1017日平台更新速递（Blueking Lite）]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><img alt="logo" src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/github.com-3feb255a10.png"></p>
<p><span>Blueking Lite 是一个<span>&nbsp;</span></span><strong>AI First</strong><span><span>&nbsp;</span>的</span><strong>轻量版</strong><span>运维产品，具有部署资源要求低、使用成本低、渐进式体验等特点，为运维管理员提供日常运维中的必备工具。</span><br> 本周更新如下</p>
<p>✨ 【OpsPilot 】<br> 🛠️ Chatflow 新增一类节点，可以直接使用平台的通知渠道进行消息通知<br> 🤖 lobechat的应用支持记录对话记录和运营统计</p>
<p>📊 【节点管理 】&nbsp;<br> 🔐 探针配置安全加固：采集配置文件中的明文密码改为环境变量注入<br> 🧩 安装过程可视化：控制器安装日志分步骤展示，每一步执行结果清晰可见，错误定位更快捷<br> 🔒 通讯加密增强：节点与服务之间通讯支持 TLS</p>
<p><br> 🔗 体验环境：https://bklite.canway.net/<br> 🏠 官网：https://bklite.ai/</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-22bbc0d5ff.png"></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><img alt="logo" src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/github.com-3feb255a10.png"></p>
<p><span>Blueking Lite 是一个<span>&nbsp;</span></span><strong>AI First</strong><span><span>&nbsp;</span>的</span><strong>轻量版</strong><span>运维产品，具有部署资源要求低、使用成本低、渐进式体验等特点，为运维管理员提供日常运维中的必备工具。</span><br> 本周更新如下</p>
<p>✨ 【OpsPilot 】<br> 🛠️ Chatflow 新增一类节点，可以直接使用平台的通知渠道进行消息通知<br> 🤖 lobechat的应用支持记录对话记录和运营统计</p>
<p>📊 【节点管理 】&nbsp;<br> 🔐 探针配置安全加固：采集配置文件中的明文密码改为环境变量注入<br> 🧩 安装过程可视化：控制器安装日志分步骤展示，每一步执行结果清晰可见，错误定位更快捷<br> 🔒 通讯加密增强：节点与服务之间通讯支持 TLS</p>
<p><br> 🔗 体验环境：https://bklite.canway.net/<br> 🏠 官网：https://bklite.ai/</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-22bbc0d5ff.png"></p>]]>
    </description>
    <content:encoded><![CDATA[<p><img alt="logo" src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/github.com-3feb255a10.png"></p>
<p><span>Blueking Lite 是一个<span>&nbsp;</span></span><strong>AI First</strong><span><span>&nbsp;</span>的</span><strong>轻量版</strong><span>运维产品，具有部署资源要求低、使用成本低、渐进式体验等特点，为运维管理员提供日常运维中的必备工具。</span><br> 本周更新如下</p>
<p>✨ 【OpsPilot 】<br> 🛠️ Chatflow 新增一类节点，可以直接使用平台的通知渠道进行消息通知<br> 🤖 lobechat的应用支持记录对话记录和运营统计</p>
<p>📊 【节点管理 】&nbsp;<br> 🔐 探针配置安全加固：采集配置文件中的明文密码改为环境变量注入<br> 🧩 安装过程可视化：控制器安装日志分步骤展示，每一步执行结果清晰可见，错误定位更快捷<br> 🔒 通讯加密增强：节点与服务之间通讯支持 TLS</p>
<p><br> 🔗 体验环境：https://bklite.canway.net/<br> 🏠 官网：https://bklite.ai/</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-22bbc0d5ff.png"></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/github.com-3feb255a10.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/github.com-3feb255a10.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 17:34:38 +0800</pubDate>
  </item><item>
    <title><![CDATA[小米 AI 团队发表新论文，雷军千万年薪要挖的 DeepSeek 天才少女署名]]></title>
    <link>https://www.oschina.net/news/378022</link>
    <itunes:title><![CDATA[小米 AI 团队发表新论文，雷军千万年薪要挖的 DeepSeek 天才少女署名]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>10月14日，小米和北京大学联合署名的论文发表于arXiv，曾被曝获小米集团创始人兼CEO雷军以千万年薪招募的DeepSeek“天才少女”罗福莉，出现在了这篇论文的通讯作者之列，但值得注意的是，论文作者中并没有标注罗福莉属于小米大模型团队。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-8019a1529e.png"></p>
<p>通讯作者中的罗福莉是95后，她本科就读于北京师范大学计算机专业，硕士毕业于北京大学计算语言学研究所计算语言学专业。随后罗福莉曾在阿里巴巴达摩院主导开发了多语言预训练模型VECO，并推动了AliceMind的开源工作，2022年入职DeepSeek，参与了MoE大模型DeepSeek-V2的研发。</p>
<p>去年年底，小米被曝以千万年薪挖角DeepSeek-V2核心开发者之一罗福莉，使其冲上热搜，但双方至今都未公开声明是否正式入职小米。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>10月14日，小米和北京大学联合署名的论文发表于arXiv，曾被曝获小米集团创始人兼CEO雷军以千万年薪招募的DeepSeek“天才少女”罗福莉，出现在了这篇论文的通讯作者之列，但值得注意的是，论文作者中并没有标注罗福莉属于小米大模型团队。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-8019a1529e.png"></p>
<p>通讯作者中的罗福莉是95后，她本科就读于北京师范大学计算机专业，硕士毕业于北京大学计算语言学研究所计算语言学专业。随后罗福莉曾在阿里巴巴达摩院主导开发了多语言预训练模型VECO，并推动了AliceMind的开源工作，2022年入职DeepSeek，参与了MoE大模型DeepSeek-V2的研发。</p>
<p>去年年底，小米被曝以千万年薪挖角DeepSeek-V2核心开发者之一罗福莉，使其冲上热搜，但双方至今都未公开声明是否正式入职小米。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>10月14日，小米和北京大学联合署名的论文发表于arXiv，曾被曝获小米集团创始人兼CEO雷军以千万年薪招募的DeepSeek“天才少女”罗福莉，出现在了这篇论文的通讯作者之列，但值得注意的是，论文作者中并没有标注罗福莉属于小米大模型团队。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-8019a1529e.png"></p>
<p>通讯作者中的罗福莉是95后，她本科就读于北京师范大学计算机专业，硕士毕业于北京大学计算语言学研究所计算语言学专业。随后罗福莉曾在阿里巴巴达摩院主导开发了多语言预训练模型VECO，并推动了AliceMind的开源工作，2022年入职DeepSeek，参与了MoE大模型DeepSeek-V2的研发。</p>
<p>去年年底，小米被曝以千万年薪挖角DeepSeek-V2核心开发者之一罗福莉，使其冲上热搜，但双方至今都未公开声明是否正式入职小米。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-8019a1529e.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-8019a1529e.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 17:14:26 +0800</pubDate>
  </item><item>
    <title><![CDATA[Node.js v25.0.0 发布，V8 引擎升级至 14.1 版本]]></title>
    <link>https://www.oschina.net/news/378015</link>
    <itunes:title><![CDATA[Node.js v25.0.0 发布，V8 引擎升级至 14.1 版本]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>Node.js 25 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnodejs.org%2Fen%2Fblog%2Frelease%2Fv25.0.0" target="_blank">已发布</a>，此版本将 V8 引擎升级至 14.1 版本，带来以下重大改进：</p>
<ul>
<li>JSON.stringify 性能显著提升</li>
<li>内置 Uint8Array 的 base64/十六进制转换功能</li>
<li>持续优化的 WebAssembly 和 JIT 管道。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-fcd4e7d7b1.png"></p>
<p>本次发布强化了默认安全应用与 Web 标准 API：</p>
<ul>
<li>权限模型新增 --allow-net 参数</li>
<li>默认启用 Web Storage</li>
<li>ErrorEvent 事件现为全局对象</li>
</ul>
<p>此外还移除了许多长期弃用的 API（如 SlowBuffer），并通过可移植编译缓存和 WebAssembly 的 JSPI 等功能提升开发体验。</p>
<p>下载地址：<em>https://github.com/nodejs/node/releases/tag/v25.0.0</em></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>Node.js 25 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnodejs.org%2Fen%2Fblog%2Frelease%2Fv25.0.0" target="_blank">已发布</a>，此版本将 V8 引擎升级至 14.1 版本，带来以下重大改进：</p>
<ul>
<li>JSON.stringify 性能显著提升</li>
<li>内置 Uint8Array 的 base64/十六进制转换功能</li>
<li>持续优化的 WebAssembly 和 JIT 管道。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-fcd4e7d7b1.png"></p>
<p>本次发布强化了默认安全应用与 Web 标准 API：</p>
<ul>
<li>权限模型新增 --allow-net 参数</li>
<li>默认启用 Web Storage</li>
<li>ErrorEvent 事件现为全局对象</li>
</ul>
<p>此外还移除了许多长期弃用的 API（如 SlowBuffer），并通过可移植编译缓存和 WebAssembly 的 JSPI 等功能提升开发体验。</p>
<p>下载地址：<em>https://github.com/nodejs/node/releases/tag/v25.0.0</em></p>]]>
    </description>
    <content:encoded><![CDATA[<p>Node.js 25 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fnodejs.org%2Fen%2Fblog%2Frelease%2Fv25.0.0" target="_blank">已发布</a>，此版本将 V8 引擎升级至 14.1 版本，带来以下重大改进：</p>
<ul>
<li>JSON.stringify 性能显著提升</li>
<li>内置 Uint8Array 的 base64/十六进制转换功能</li>
<li>持续优化的 WebAssembly 和 JIT 管道。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-fcd4e7d7b1.png"></p>
<p>本次发布强化了默认安全应用与 Web 标准 API：</p>
<ul>
<li>权限模型新增 --allow-net 参数</li>
<li>默认启用 Web Storage</li>
<li>ErrorEvent 事件现为全局对象</li>
</ul>
<p>此外还移除了许多长期弃用的 API（如 SlowBuffer），并通过可移植编译缓存和 WebAssembly 的 JSPI 等功能提升开发体验。</p>
<p>下载地址：<em>https://github.com/nodejs/node/releases/tag/v25.0.0</em></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-fcd4e7d7b1.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-fcd4e7d7b1.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 16:47:59 +0800</pubDate>
  </item><item>
    <title><![CDATA[lamp-cloud 5.6.1发布，依赖更新与体验增强双加持]]></title>
    <link>https://www.oschina.net/news/378005</link>
    <itunes:title><![CDATA[lamp-cloud 5.6.1发布，依赖更新与体验增强双加持]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<h1>更新日志</h1>
<h2>🎉 版本核心依赖</h2>
<div>
<pre><code><span>-</span> spring-boot-starter-parent：3.5.6
<span>-</span> spring-framework.version：6.2.12+
<span>-</span> nacos.version：3.1.0+
<span>-</span> spring-boot-admin.version：3.5.5+
<span>-</span> smart-doc.version：3.1.2+
<span>-</span> hutool.version：5.8.41+
<span>-</span> lombok.version：1.18.42+
<span>-</span> mybatis-plus.version：3.5.14+
<span>-</span> fastjson2.version：2.0.59+
<span>-</span> fastexcel.version：1.3.0+
<span>-</span> 前端框架：Vxe-PC-UI 4.9.29 + Vxe-Table 4.16.11
</code>
</pre>
</div>
<h2><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftangyh.top%2Fupgrade%2F5.x%25E7%2589%2588%25E6%259C%25AC%25E5%258D%2587%25E7%25BA%25A7%25E6%2597%25A5%25E5%25BF%2597.html%23%25F0%259F%258E%2589-%25E4%25BA%2594%25E5%25A4%25A7%25E6%25A0%25B8%25E5%25BF%2583%25E5%258A%259F%25E8%2583%25BD%25E5%258D%2587%25E7%25BA%25A7" target="_blank">#</a>🎉 五大核心功能升级</h2>
<ol>
<li><strong>导航栏吸顶</strong>：首选项导航栏支持外观/布局/快捷键吸顶悬浮</li>
<li><strong>水印自定义</strong>：动态配置水印文案，支持一键清除</li>
<li><strong>动画交互</strong>：主题切换/语言选择/全屏按钮新增丝滑动画</li>
<li><strong>权限控制</strong>：表单字段动态权限校验</li>
<li><strong>组件增强</strong>：Input输入框新增清除按钮</li>
</ol>
<h1>效果截图</h1>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-cab9faf219.png"></p>
<h1>体验网址</h1>
<table border="1" cellpadding="1" cellspacing="0">
<tbody>
<tr>
<td>  </td>
<td>vben2 版</td>
<td>vben5 版</td>
<td>soybean 版</td>
</tr>
<tr>
<td>数据源模式</td>
<td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdatasource.tangyh.top" target="_blank">点我体验</a></td>
<td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmax-datasource.tangyh.top" target="_blank">点我体验</a></td>
<td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsoy-datasource.tangyh.top" target="_blank">点我体验</a></td>
</tr>
<tr>
<td>字段模式</td>
<td><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fcolumn.tangyh.top" target="_blank">点我体验</a></td>
<td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmax-column.tangyh.top" target="_blank">点我体验</a></td>
<td><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fsoy-column.tangyh.top" target="_blank">点我体验</a></td>
</tr>
</tbody>
</table>
<h1><span>关于 lamp</span></h1>
<p><code>灯灯</code><span>&nbsp;</span>(简称灯，&nbsp;英文名：lamp)，她是一个项目集，为满足高内聚低耦合设计原则，将一个<strong>大项目</strong>拆解为以下几个子项目：</p>
<ol>
<li> <p>lamp-util：后端工具集</p> </li>
<li> <p><strong>lamp-cloud</strong>：基于 Spring Cloud 实现的后台</p> </li>
<li> <p>lamp-boot：基于 Spring Boot 实现的后台</p> </li>
<li> <p>lamp-job：基于 xxl-job 集成本项目的分布式定时任务</p> </li>
<li> <p>lamp-generator：代码生成器</p> </li>
<li> <p>lamp-web：前端</p> </li>
</ol>
<h1><span>lamp-cloud&nbsp;简介</span></h1>
<p><code>lamp-cloud</code><span>是基于</span><code>SpringCloudAlibaba、</code><span>&nbsp;</span><code>SpringCloud、</code><span>&nbsp;</span><code>SpringBoot</code><span><span>&nbsp;开发的微服务中后台快速开发平台，支持</span><span><span>&nbsp;</span>jdk17、</span><code><span>jdk11和jdk8，</span></code><span>专注于多租户 (SaaS 架构) 解决方案，亦可作为普通项目（非 SaaS 架构）的基础开发框架使用，目前已实现&nbsp;</span></span><strong>数据库隔离</strong><span>、</span><strong>字段隔离</strong><span>&nbsp;等租户隔离方案以及非租户隔离的解决方案。</span></p>
<p>她拥有自研 RBAC（基于租户应用的角色权限控制体系）、网关统一鉴权、数据权限、优雅缓存解决方案、防缓存击穿、前后端统一表单校验、字典数据自动回显、可视化前后端代码生成器、支持多种文件存储、支持多种短信邮件发送接口、灰度发布、防 XSS 攻击、防 SQL 注入、分布式事务、分布式定时任务等功能；支持多业务系统并行开发，&nbsp;支持多服务并行开发，是中后台系统开发脚手架的最佳选择。</p>
<p>lamp-cloud 代码简洁，注释齐全，架构清晰，非常适合个人学习以及中小企业作为基础框架使用。采用 Spring Cloud Alibaba、SpringBoot、Mybatis、Seata、Sentinel、RabbitMQ、FastDFS/MinIO、SkyWalking 等主要框架和中间件。本项目旨在实现基础框架能力，不涉及具体业务。</p>
<h1><span>关注项目</span></h1>
<ul>
<li> <p>官网：https://tangyh.top</p> </li>
<li> <p>源码：https://github.com/dromara/lamp-cloud</p> </li>
<li> <p><span>源码：https://gitee.com/dromara/lamp-cloud</span></p> </li>
</ul>]]>
    </itunes:summary>
    <description>
      <![CDATA[<h1>更新日志</h1>
<h2>🎉 版本核心依赖</h2>
<div>
<pre><code><span>-</span> spring-boot-starter-parent：3.5.6
<span>-</span> spring-framework.version：6.2.12+
<span>-</span> nacos.version：3.1.0+
<span>-</span> spring-boot-admin.version：3.5.5+
<span>-</span> smart-doc.version：3.1.2+
<span>-</span> hutool.version：5.8.41+
<span>-</span> lombok.version：1.18.42+
<span>-</span> mybatis-plus.version：3.5.14+
<span>-</span> fastjson2.version：2.0.59+
<span>-</span> fastexcel.version：1.3.0+
<span>-</span> 前端框架：Vxe-PC-UI 4.9.29 + Vxe-Table 4.16.11
</code>
</pre>
</div>
<h2><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftangyh.top%2Fupgrade%2F5.x%25E7%2589%2588%25E6%259C%25AC%25E5%258D%2587%25E7%25BA%25A7%25E6%2597%25A5%25E5%25BF%2597.html%23%25F0%259F%258E%2589-%25E4%25BA%2594%25E5%25A4%25A7%25E6%25A0%25B8%25E5%25BF%2583%25E5%258A%259F%25E8%2583%25BD%25E5%258D%2587%25E7%25BA%25A7" target="_blank">#</a>🎉 五大核心功能升级</h2>
<ol>
<li><strong>导航栏吸顶</strong>：首选项导航栏支持外观/布局/快捷键吸顶悬浮</li>
<li><strong>水印自定义</strong>：动态配置水印文案，支持一键清除</li>
<li><strong>动画交互</strong>：主题切换/语言选择/全屏按钮新增丝滑动画</li>
<li><strong>权限控制</strong>：表单字段动态权限校验</li>
<li><strong>组件增强</strong>：Input输入框新增清除按钮</li>
</ol>
<h1>效果截图</h1>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-cab9faf219.png"></p>
<h1>体验网址</h1>
<table border="1" cellpadding="1" cellspacing="0">
<tbody>
<tr>
<td>  </td>
<td>vben2 版</td>
<td>vben5 版</td>
<td>soybean 版</td>
</tr>
<tr>
<td>数据源模式</td>
<td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdatasource.tangyh.top" target="_blank">点我体验</a></td>
<td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmax-datasource.tangyh.top" target="_blank">点我体验</a></td>
<td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsoy-datasource.tangyh.top" target="_blank">点我体验</a></td>
</tr>
<tr>
<td>字段模式</td>
<td><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fcolumn.tangyh.top" target="_blank">点我体验</a></td>
<td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmax-column.tangyh.top" target="_blank">点我体验</a></td>
<td><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fsoy-column.tangyh.top" target="_blank">点我体验</a></td>
</tr>
</tbody>
</table>
<h1><span>关于 lamp</span></h1>
<p><code>灯灯</code><span>&nbsp;</span>(简称灯，&nbsp;英文名：lamp)，她是一个项目集，为满足高内聚低耦合设计原则，将一个<strong>大项目</strong>拆解为以下几个子项目：</p>
<ol>
<li> <p>lamp-util：后端工具集</p> </li>
<li> <p><strong>lamp-cloud</strong>：基于 Spring Cloud 实现的后台</p> </li>
<li> <p>lamp-boot：基于 Spring Boot 实现的后台</p> </li>
<li> <p>lamp-job：基于 xxl-job 集成本项目的分布式定时任务</p> </li>
<li> <p>lamp-generator：代码生成器</p> </li>
<li> <p>lamp-web：前端</p> </li>
</ol>
<h1><span>lamp-cloud&nbsp;简介</span></h1>
<p><code>lamp-cloud</code><span>是基于</span><code>SpringCloudAlibaba、</code><span>&nbsp;</span><code>SpringCloud、</code><span>&nbsp;</span><code>SpringBoot</code><span><span>&nbsp;开发的微服务中后台快速开发平台，支持</span><span><span>&nbsp;</span>jdk17、</span><code><span>jdk11和jdk8，</span></code><span>专注于多租户 (SaaS 架构) 解决方案，亦可作为普通项目（非 SaaS 架构）的基础开发框架使用，目前已实现&nbsp;</span></span><strong>数据库隔离</strong><span>、</span><strong>字段隔离</strong><span>&nbsp;等租户隔离方案以及非租户隔离的解决方案。</span></p>
<p>她拥有自研 RBAC（基于租户应用的角色权限控制体系）、网关统一鉴权、数据权限、优雅缓存解决方案、防缓存击穿、前后端统一表单校验、字典数据自动回显、可视化前后端代码生成器、支持多种文件存储、支持多种短信邮件发送接口、灰度发布、防 XSS 攻击、防 SQL 注入、分布式事务、分布式定时任务等功能；支持多业务系统并行开发，&nbsp;支持多服务并行开发，是中后台系统开发脚手架的最佳选择。</p>
<p>lamp-cloud 代码简洁，注释齐全，架构清晰，非常适合个人学习以及中小企业作为基础框架使用。采用 Spring Cloud Alibaba、SpringBoot、Mybatis、Seata、Sentinel、RabbitMQ、FastDFS/MinIO、SkyWalking 等主要框架和中间件。本项目旨在实现基础框架能力，不涉及具体业务。</p>
<h1><span>关注项目</span></h1>
<ul>
<li> <p>官网：https://tangyh.top</p> </li>
<li> <p>源码：https://github.com/dromara/lamp-cloud</p> </li>
<li> <p><span>源码：https://gitee.com/dromara/lamp-cloud</span></p> </li>
</ul>]]>
    </description>
    <content:encoded><![CDATA[<h1>更新日志</h1>
<h2>🎉 版本核心依赖</h2>
<div>
<pre><code><span>-</span> spring-boot-starter-parent：3.5.6
<span>-</span> spring-framework.version：6.2.12+
<span>-</span> nacos.version：3.1.0+
<span>-</span> spring-boot-admin.version：3.5.5+
<span>-</span> smart-doc.version：3.1.2+
<span>-</span> hutool.version：5.8.41+
<span>-</span> lombok.version：1.18.42+
<span>-</span> mybatis-plus.version：3.5.14+
<span>-</span> fastjson2.version：2.0.59+
<span>-</span> fastexcel.version：1.3.0+
<span>-</span> 前端框架：Vxe-PC-UI 4.9.29 + Vxe-Table 4.16.11
</code>
</pre>
</div>
<h2><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Ftangyh.top%2Fupgrade%2F5.x%25E7%2589%2588%25E6%259C%25AC%25E5%258D%2587%25E7%25BA%25A7%25E6%2597%25A5%25E5%25BF%2597.html%23%25F0%259F%258E%2589-%25E4%25BA%2594%25E5%25A4%25A7%25E6%25A0%25B8%25E5%25BF%2583%25E5%258A%259F%25E8%2583%25BD%25E5%258D%2587%25E7%25BA%25A7" target="_blank">#</a>🎉 五大核心功能升级</h2>
<ol>
<li><strong>导航栏吸顶</strong>：首选项导航栏支持外观/布局/快捷键吸顶悬浮</li>
<li><strong>水印自定义</strong>：动态配置水印文案，支持一键清除</li>
<li><strong>动画交互</strong>：主题切换/语言选择/全屏按钮新增丝滑动画</li>
<li><strong>权限控制</strong>：表单字段动态权限校验</li>
<li><strong>组件增强</strong>：Input输入框新增清除按钮</li>
</ol>
<h1>效果截图</h1>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-cab9faf219.png"></p>
<h1>体验网址</h1>
<table border="1" cellpadding="1" cellspacing="0">
<tbody>
<tr>
<td>  </td>
<td>vben2 版</td>
<td>vben5 版</td>
<td>soybean 版</td>
</tr>
<tr>
<td>数据源模式</td>
<td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdatasource.tangyh.top" target="_blank">点我体验</a></td>
<td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmax-datasource.tangyh.top" target="_blank">点我体验</a></td>
<td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsoy-datasource.tangyh.top" target="_blank">点我体验</a></td>
</tr>
<tr>
<td>字段模式</td>
<td><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fcolumn.tangyh.top" target="_blank">点我体验</a></td>
<td><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmax-column.tangyh.top" target="_blank">点我体验</a></td>
<td><a href="https://www.oschina.net/action/GoToLink?url=http%3A%2F%2Fsoy-column.tangyh.top" target="_blank">点我体验</a></td>
</tr>
</tbody>
</table>
<h1><span>关于 lamp</span></h1>
<p><code>灯灯</code><span>&nbsp;</span>(简称灯，&nbsp;英文名：lamp)，她是一个项目集，为满足高内聚低耦合设计原则，将一个<strong>大项目</strong>拆解为以下几个子项目：</p>
<ol>
<li> <p>lamp-util：后端工具集</p> </li>
<li> <p><strong>lamp-cloud</strong>：基于 Spring Cloud 实现的后台</p> </li>
<li> <p>lamp-boot：基于 Spring Boot 实现的后台</p> </li>
<li> <p>lamp-job：基于 xxl-job 集成本项目的分布式定时任务</p> </li>
<li> <p>lamp-generator：代码生成器</p> </li>
<li> <p>lamp-web：前端</p> </li>
</ol>
<h1><span>lamp-cloud&nbsp;简介</span></h1>
<p><code>lamp-cloud</code><span>是基于</span><code>SpringCloudAlibaba、</code><span>&nbsp;</span><code>SpringCloud、</code><span>&nbsp;</span><code>SpringBoot</code><span><span>&nbsp;开发的微服务中后台快速开发平台，支持</span><span><span>&nbsp;</span>jdk17、</span><code><span>jdk11和jdk8，</span></code><span>专注于多租户 (SaaS 架构) 解决方案，亦可作为普通项目（非 SaaS 架构）的基础开发框架使用，目前已实现&nbsp;</span></span><strong>数据库隔离</strong><span>、</span><strong>字段隔离</strong><span>&nbsp;等租户隔离方案以及非租户隔离的解决方案。</span></p>
<p>她拥有自研 RBAC（基于租户应用的角色权限控制体系）、网关统一鉴权、数据权限、优雅缓存解决方案、防缓存击穿、前后端统一表单校验、字典数据自动回显、可视化前后端代码生成器、支持多种文件存储、支持多种短信邮件发送接口、灰度发布、防 XSS 攻击、防 SQL 注入、分布式事务、分布式定时任务等功能；支持多业务系统并行开发，&nbsp;支持多服务并行开发，是中后台系统开发脚手架的最佳选择。</p>
<p>lamp-cloud 代码简洁，注释齐全，架构清晰，非常适合个人学习以及中小企业作为基础框架使用。采用 Spring Cloud Alibaba、SpringBoot、Mybatis、Seata、Sentinel、RabbitMQ、FastDFS/MinIO、SkyWalking 等主要框架和中间件。本项目旨在实现基础框架能力，不涉及具体业务。</p>
<h1><span>关注项目</span></h1>
<ul>
<li> <p>官网：https://tangyh.top</p> </li>
<li> <p>源码：https://github.com/dromara/lamp-cloud</p> </li>
<li> <p><span>源码：https://gitee.com/dromara/lamp-cloud</span></p> </li>
</ul>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-cab9faf219.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-cab9faf219.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 16:12:58 +0800</pubDate>
  </item><item>
    <title><![CDATA[AI 搜索引擎公司 Perplexity CEO 声称用 AI 完成投资者路演]]></title>
    <link>https://www.oschina.net/news/378004</link>
    <itunes:title><![CDATA[AI 搜索引擎公司 Perplexity CEO 声称用 AI 完成投资者路演]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.businessinsider.com%2Fperplexity-ceo-ai-not-pitch-decks-fundraising-aravind-srinivas-2025-10" target="_blank">Business Insider 报道称</a>，AI 搜索引擎公司 Perplexity 的 CEO Aravind Srinivas 表示，公司在融资时已完全放弃传统的演示文稿（pitch deck），转而使用一份书面备忘录（memo）和实时问答的形式来与投资者沟通。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e40f3dd664.png"></p>
<p>Srinivas 称，<span><strong>他会让投资者直接提出任何问题，然后借助 Perplexity 的 AI 工具即时生成回答，甚至可以自动“以他的语气”撰写邮件回复。有投资者在收到 AI 生成的回应后当天就决定投资</strong></span>。</p>
<p>这种做法在硅谷仍较为罕见，少数公司如 Rippling 曾在融资中使用文字备忘录取代幻灯片，但 Perplexity 更进一步，将 AI 深度融入整个沟通过程。</p>
<p>Perplexity 成立于 2022 年，创始人曾在 DeepMind 和 OpenAI 任职。公司已获得 SoftBank、NVIDIA 和 Jeff Bezos 等投资者支持，当前估值据传接近 200 亿美元。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.businessinsider.com%2Fperplexity-ceo-ai-not-pitch-decks-fundraising-aravind-srinivas-2025-10" target="_blank">Business Insider 报道称</a>，AI 搜索引擎公司 Perplexity 的 CEO Aravind Srinivas 表示，公司在融资时已完全放弃传统的演示文稿（pitch deck），转而使用一份书面备忘录（memo）和实时问答的形式来与投资者沟通。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e40f3dd664.png"></p>
<p>Srinivas 称，<span><strong>他会让投资者直接提出任何问题，然后借助 Perplexity 的 AI 工具即时生成回答，甚至可以自动“以他的语气”撰写邮件回复。有投资者在收到 AI 生成的回应后当天就决定投资</strong></span>。</p>
<p>这种做法在硅谷仍较为罕见，少数公司如 Rippling 曾在融资中使用文字备忘录取代幻灯片，但 Perplexity 更进一步，将 AI 深度融入整个沟通过程。</p>
<p>Perplexity 成立于 2022 年，创始人曾在 DeepMind 和 OpenAI 任职。公司已获得 SoftBank、NVIDIA 和 Jeff Bezos 等投资者支持，当前估值据传接近 200 亿美元。</p>]]>
    </description>
    <content:encoded><![CDATA[<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.businessinsider.com%2Fperplexity-ceo-ai-not-pitch-decks-fundraising-aravind-srinivas-2025-10" target="_blank">Business Insider 报道称</a>，AI 搜索引擎公司 Perplexity 的 CEO Aravind Srinivas 表示，公司在融资时已完全放弃传统的演示文稿（pitch deck），转而使用一份书面备忘录（memo）和实时问答的形式来与投资者沟通。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e40f3dd664.png"></p>
<p>Srinivas 称，<span><strong>他会让投资者直接提出任何问题，然后借助 Perplexity 的 AI 工具即时生成回答，甚至可以自动“以他的语气”撰写邮件回复。有投资者在收到 AI 生成的回应后当天就决定投资</strong></span>。</p>
<p>这种做法在硅谷仍较为罕见，少数公司如 Rippling 曾在融资中使用文字备忘录取代幻灯片，但 Perplexity 更进一步，将 AI 深度融入整个沟通过程。</p>
<p>Perplexity 成立于 2022 年，创始人曾在 DeepMind 和 OpenAI 任职。公司已获得 SoftBank、NVIDIA 和 Jeff Bezos 等投资者支持，当前估值据传接近 200 亿美元。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e40f3dd664.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e40f3dd664.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 16:12:50 +0800</pubDate>
  </item><item>
    <title><![CDATA[Chrome 新标签页搜索框迎来“大改版”]]></title>
    <link>https://www.oschina.net/news/378000</link>
    <itunes:title><![CDATA[Chrome 新标签页搜索框迎来“大改版”]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>谷歌正在为 Chrome 浏览器的新标签页（New Tab Page）测试一项重大改版，名为“Realbox Next”。这一更新重新设计了页面顶部的搜索框，让它不仅仅是一个输入网址或关键词的地方，而是一个更智能、更具交互性的起点。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-dee9842a88.png"></p>
<p>新版搜索框提供两种布局：“<strong>Tall（高版）</strong>”与“<strong>Compact（紧凑版）</strong>”。搜索框上方新增 “Ask Google” 标语，下方则提供多种智能提示，如“进行比较”“学习新技能”“制定计划”“研究主题”等，帮助用户更自然地发起复杂查询。尤其是 Tall 版，设计上更像一个对话框或创作空间，未来还将支持上下文建议，让搜索体验更接近 AI 助手的交互方式。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-ee9057a960.png"></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-24eec702a7.png"></p>
<p>目前，这一功能尚处于实验阶段，用户可通过 Chrome 的隐藏设置（flags）开启 <strong>“</strong>NTP Realbox Next<strong>”</strong> 选项体验早期版本。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-23063ec602.png"></p>
<p>此外，谷歌还在同步测试多项功能，包括新增“创建标签组”菜单选项、Lens 视频来源引用、画中画录屏排除、以及为阅读模式增加四种新主题等，显示出 Chrome 正持续朝着更智能、更个性化的方向演进。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>谷歌正在为 Chrome 浏览器的新标签页（New Tab Page）测试一项重大改版，名为“Realbox Next”。这一更新重新设计了页面顶部的搜索框，让它不仅仅是一个输入网址或关键词的地方，而是一个更智能、更具交互性的起点。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-dee9842a88.png"></p>
<p>新版搜索框提供两种布局：“<strong>Tall（高版）</strong>”与“<strong>Compact（紧凑版）</strong>”。搜索框上方新增 “Ask Google” 标语，下方则提供多种智能提示，如“进行比较”“学习新技能”“制定计划”“研究主题”等，帮助用户更自然地发起复杂查询。尤其是 Tall 版，设计上更像一个对话框或创作空间，未来还将支持上下文建议，让搜索体验更接近 AI 助手的交互方式。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-ee9057a960.png"></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-24eec702a7.png"></p>
<p>目前，这一功能尚处于实验阶段，用户可通过 Chrome 的隐藏设置（flags）开启 <strong>“</strong>NTP Realbox Next<strong>”</strong> 选项体验早期版本。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-23063ec602.png"></p>
<p>此外，谷歌还在同步测试多项功能，包括新增“创建标签组”菜单选项、Lens 视频来源引用、画中画录屏排除、以及为阅读模式增加四种新主题等，显示出 Chrome 正持续朝着更智能、更个性化的方向演进。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>谷歌正在为 Chrome 浏览器的新标签页（New Tab Page）测试一项重大改版，名为“Realbox Next”。这一更新重新设计了页面顶部的搜索框，让它不仅仅是一个输入网址或关键词的地方，而是一个更智能、更具交互性的起点。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-dee9842a88.png"></p>
<p>新版搜索框提供两种布局：“<strong>Tall（高版）</strong>”与“<strong>Compact（紧凑版）</strong>”。搜索框上方新增 “Ask Google” 标语，下方则提供多种智能提示，如“进行比较”“学习新技能”“制定计划”“研究主题”等，帮助用户更自然地发起复杂查询。尤其是 Tall 版，设计上更像一个对话框或创作空间，未来还将支持上下文建议，让搜索体验更接近 AI 助手的交互方式。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-ee9057a960.png"></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-24eec702a7.png"></p>
<p>目前，这一功能尚处于实验阶段，用户可通过 Chrome 的隐藏设置（flags）开启 <strong>“</strong>NTP Realbox Next<strong>”</strong> 选项体验早期版本。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-23063ec602.png"></p>
<p>此外，谷歌还在同步测试多项功能，包括新增“创建标签组”菜单选项、Lens 视频来源引用、画中画录屏排除、以及为阅读模式增加四种新主题等，显示出 Chrome 正持续朝着更智能、更个性化的方向演进。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-dee9842a88.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-dee9842a88.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 16:02:55 +0800</pubDate>
  </item><item>
    <title><![CDATA[维基百科因 AI 聊天机器人流量下降]]></title>
    <link>https://www.oschina.net/news/377998</link>
    <itunes:title><![CDATA[维基百科因 AI 聊天机器人流量下降]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><span>维基百科运营方维基媒体基金会近日表示，由于越来越多用户通过 AI 聊天机器人和搜索引擎直接获取维基百科上的信息，导致其人类访问流量显著下降。这一现象引发了基金会对维基百科未来可持续发展的担忧。</span></p>
<p><span>维基媒体基金会的高级总监 Marshall Miller 在官方博客中指出，虽然人们以新的方式获取知识是受欢迎的，但 AI 工具和社交平台在使用维基百科内容时，应该鼓励用户访问维基百科本身。他强调，维基百科的流量减少将导致志愿者减少，内容生产与扩充受到影响，甚至可能导致个人捐赠的减少，这将直接威胁到维基百科的正常运营。</span></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-08fd7a7305.png"></p>
<p><span>有趣的是，尽管 AI 和搜索引擎使维基百科的直接流量减少，但维基百科的数据对这些平台而言愈发重要。许多大型语言模型都使用维基百科作为核心数据集，而 Google 等平台长期依赖维基百科的文章来生成摘要和知识面板，这也进一步分流了维基百科的访问量。</span></p>
<p><span>Miller 提到，维基百科在2025年5月观察到源自巴西的 “人类访问流量” 异常高。经过调查后，基金会调整了自动检测系统，发现最近的人类页面浏览量同比下降约8%。这一趋势反映出 AI 和社交媒体改变了用户获取信息的方式，搜索引擎越来越多地直接返回基于维基百科内容的答案，让用户无需访问原始页面。</span></p>
<p><span>为了应对 AI 带来的挑战，维基百科正在加强政策和技术能力，规范第三方平台对其内容的使用，并与主要内容再利用方合作。此外，基金会还计划通过 YouTube、TikTok、Roblox 和 Instagram 等平台，向年轻用户推广维基内容。</span></p>
<p><span>Miller 呼吁用户在进行网络搜索时，关注原始出处和引用，主动点击链接访问来源，帮助维护知识的完整性和原创性。面对 AI 带来的流量冲击，维基百科的未来发展值得持续关注。</span></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><span>维基百科运营方维基媒体基金会近日表示，由于越来越多用户通过 AI 聊天机器人和搜索引擎直接获取维基百科上的信息，导致其人类访问流量显著下降。这一现象引发了基金会对维基百科未来可持续发展的担忧。</span></p>
<p><span>维基媒体基金会的高级总监 Marshall Miller 在官方博客中指出，虽然人们以新的方式获取知识是受欢迎的，但 AI 工具和社交平台在使用维基百科内容时，应该鼓励用户访问维基百科本身。他强调，维基百科的流量减少将导致志愿者减少，内容生产与扩充受到影响，甚至可能导致个人捐赠的减少，这将直接威胁到维基百科的正常运营。</span></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-08fd7a7305.png"></p>
<p><span>有趣的是，尽管 AI 和搜索引擎使维基百科的直接流量减少，但维基百科的数据对这些平台而言愈发重要。许多大型语言模型都使用维基百科作为核心数据集，而 Google 等平台长期依赖维基百科的文章来生成摘要和知识面板，这也进一步分流了维基百科的访问量。</span></p>
<p><span>Miller 提到，维基百科在2025年5月观察到源自巴西的 “人类访问流量” 异常高。经过调查后，基金会调整了自动检测系统，发现最近的人类页面浏览量同比下降约8%。这一趋势反映出 AI 和社交媒体改变了用户获取信息的方式，搜索引擎越来越多地直接返回基于维基百科内容的答案，让用户无需访问原始页面。</span></p>
<p><span>为了应对 AI 带来的挑战，维基百科正在加强政策和技术能力，规范第三方平台对其内容的使用，并与主要内容再利用方合作。此外，基金会还计划通过 YouTube、TikTok、Roblox 和 Instagram 等平台，向年轻用户推广维基内容。</span></p>
<p><span>Miller 呼吁用户在进行网络搜索时，关注原始出处和引用，主动点击链接访问来源，帮助维护知识的完整性和原创性。面对 AI 带来的流量冲击，维基百科的未来发展值得持续关注。</span></p>]]>
    </description>
    <content:encoded><![CDATA[<p><span>维基百科运营方维基媒体基金会近日表示，由于越来越多用户通过 AI 聊天机器人和搜索引擎直接获取维基百科上的信息，导致其人类访问流量显著下降。这一现象引发了基金会对维基百科未来可持续发展的担忧。</span></p>
<p><span>维基媒体基金会的高级总监 Marshall Miller 在官方博客中指出，虽然人们以新的方式获取知识是受欢迎的，但 AI 工具和社交平台在使用维基百科内容时，应该鼓励用户访问维基百科本身。他强调，维基百科的流量减少将导致志愿者减少，内容生产与扩充受到影响，甚至可能导致个人捐赠的减少，这将直接威胁到维基百科的正常运营。</span></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-08fd7a7305.png"></p>
<p><span>有趣的是，尽管 AI 和搜索引擎使维基百科的直接流量减少，但维基百科的数据对这些平台而言愈发重要。许多大型语言模型都使用维基百科作为核心数据集，而 Google 等平台长期依赖维基百科的文章来生成摘要和知识面板，这也进一步分流了维基百科的访问量。</span></p>
<p><span>Miller 提到，维基百科在2025年5月观察到源自巴西的 “人类访问流量” 异常高。经过调查后，基金会调整了自动检测系统，发现最近的人类页面浏览量同比下降约8%。这一趋势反映出 AI 和社交媒体改变了用户获取信息的方式，搜索引擎越来越多地直接返回基于维基百科内容的答案，让用户无需访问原始页面。</span></p>
<p><span>为了应对 AI 带来的挑战，维基百科正在加强政策和技术能力，规范第三方平台对其内容的使用，并与主要内容再利用方合作。此外，基金会还计划通过 YouTube、TikTok、Roblox 和 Instagram 等平台，向年轻用户推广维基内容。</span></p>
<p><span>Miller 呼吁用户在进行网络搜索时，关注原始出处和引用，主动点击链接访问来源，帮助维护知识的完整性和原创性。面对 AI 带来的流量冲击，维基百科的未来发展值得持续关注。</span></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-08fd7a7305.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-08fd7a7305.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 15:58:47 +0800</pubDate>
  </item><item>
    <title><![CDATA[科技预言家凯文·凯利：AI 不会替代人类工作]]></title>
    <link>https://www.oschina.net/news/377996</link>
    <itunes:title><![CDATA[科技预言家凯文·凯利：AI 不会替代人类工作]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>2025可持续全球领导者大会于10月16日-18日在上海市黄浦区世博园区召开。著名未来学家、《2049》作者、科技预言家、《连线》杂志创始主编凯文·凯利表示，未来人类将会变得非常具有价值，尽管AI变得越来越强大，AI有些东西还是无法进行提升，这就是人类具有价值的原因。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-761d42907e.png"></p>
<p>“比如你招人去做一个事情，其中可以让AI取代它，这就是AI任务。你雇佣人的话他有责任完成这个任务，但是AI没有责任感，它不在乎，比如你把钱给它让它买东西，它会不会找零，只有人有这样的责任心，当然未来它们也许会有。”他说。</p>
<p>&nbsp;他指出，非常重要的一点是，在工作中不断学习的能力。在可见的未来，可能很多任务可以由AI来完成，但是工作本身是属于人的，所以它是对人类进行提升，而不是把人类取代。</p>
<p>他还提到，中国在 AI 应用方面展现出极高效率，五年内中国可能会做出世界上最好的人工智能芯片，这是很多人非常期待的一点，或许未来的超级网络 AI 会在中国出现，这是一个非常好的机会。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>2025可持续全球领导者大会于10月16日-18日在上海市黄浦区世博园区召开。著名未来学家、《2049》作者、科技预言家、《连线》杂志创始主编凯文·凯利表示，未来人类将会变得非常具有价值，尽管AI变得越来越强大，AI有些东西还是无法进行提升，这就是人类具有价值的原因。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-761d42907e.png"></p>
<p>“比如你招人去做一个事情，其中可以让AI取代它，这就是AI任务。你雇佣人的话他有责任完成这个任务，但是AI没有责任感，它不在乎，比如你把钱给它让它买东西，它会不会找零，只有人有这样的责任心，当然未来它们也许会有。”他说。</p>
<p>&nbsp;他指出，非常重要的一点是，在工作中不断学习的能力。在可见的未来，可能很多任务可以由AI来完成，但是工作本身是属于人的，所以它是对人类进行提升，而不是把人类取代。</p>
<p>他还提到，中国在 AI 应用方面展现出极高效率，五年内中国可能会做出世界上最好的人工智能芯片，这是很多人非常期待的一点，或许未来的超级网络 AI 会在中国出现，这是一个非常好的机会。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>2025可持续全球领导者大会于10月16日-18日在上海市黄浦区世博园区召开。著名未来学家、《2049》作者、科技预言家、《连线》杂志创始主编凯文·凯利表示，未来人类将会变得非常具有价值，尽管AI变得越来越强大，AI有些东西还是无法进行提升，这就是人类具有价值的原因。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-761d42907e.png"></p>
<p>“比如你招人去做一个事情，其中可以让AI取代它，这就是AI任务。你雇佣人的话他有责任完成这个任务，但是AI没有责任感，它不在乎，比如你把钱给它让它买东西，它会不会找零，只有人有这样的责任心，当然未来它们也许会有。”他说。</p>
<p>&nbsp;他指出，非常重要的一点是，在工作中不断学习的能力。在可见的未来，可能很多任务可以由AI来完成，但是工作本身是属于人的，所以它是对人类进行提升，而不是把人类取代。</p>
<p>他还提到，中国在 AI 应用方面展现出极高效率，五年内中国可能会做出世界上最好的人工智能芯片，这是很多人非常期待的一点，或许未来的超级网络 AI 会在中国出现，这是一个非常好的机会。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-761d42907e.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-761d42907e.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 15:50:52 +0800</pubDate>
  </item><item>
    <title><![CDATA[Chrome 正在测试新功能：让网站了解你设备的性能]]></title>
    <link>https://www.oschina.net/news/377991</link>
    <itunes:title><![CDATA[Chrome 正在测试新功能：让网站了解你设备的性能]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>谷歌正在为 Chrome 浏览器开发一项名为<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fchromestatus.com%2Ffeature%2F5189864286978048" target="_blank">“CPU Performance API”</a>的新功能，允许网站了解用户设备的性能水平。</p>
<p>据介绍，该功能旨在帮助网页自动根据设备的计算能力调整内容和动画效果，从而在低性能设备上减少卡顿、节省电量，并在高性能设备上提升体验。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-104e87b1a7.png"></p>
<p>这一提案可能与此前的“Compute Pressure API”协同使用，使网页能够实时感知 CPU 负载状况。谷歌表示，这将有助于开发者优化 Web 应用的性能表现，提升整体流畅度。</p>
<p>不过，该功能也引发了隐私担忧。业内人士指出，即使不直接暴露设备型号，网站也可能通过性能数据增强“设备指纹识别”，从而跟踪用户。</p>
<p>除了该提案外，谷歌近期还在测试多项新特性，包括针对 Snapdragon Windows PC 的图形优化、新版搜索框界面，以及桌面端“一键退订”网站通知等改进。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>谷歌正在为 Chrome 浏览器开发一项名为<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fchromestatus.com%2Ffeature%2F5189864286978048" target="_blank">“CPU Performance API”</a>的新功能，允许网站了解用户设备的性能水平。</p>
<p>据介绍，该功能旨在帮助网页自动根据设备的计算能力调整内容和动画效果，从而在低性能设备上减少卡顿、节省电量，并在高性能设备上提升体验。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-104e87b1a7.png"></p>
<p>这一提案可能与此前的“Compute Pressure API”协同使用，使网页能够实时感知 CPU 负载状况。谷歌表示，这将有助于开发者优化 Web 应用的性能表现，提升整体流畅度。</p>
<p>不过，该功能也引发了隐私担忧。业内人士指出，即使不直接暴露设备型号，网站也可能通过性能数据增强“设备指纹识别”，从而跟踪用户。</p>
<p>除了该提案外，谷歌近期还在测试多项新特性，包括针对 Snapdragon Windows PC 的图形优化、新版搜索框界面，以及桌面端“一键退订”网站通知等改进。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>谷歌正在为 Chrome 浏览器开发一项名为<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fchromestatus.com%2Ffeature%2F5189864286978048" target="_blank">“CPU Performance API”</a>的新功能，允许网站了解用户设备的性能水平。</p>
<p>据介绍，该功能旨在帮助网页自动根据设备的计算能力调整内容和动画效果，从而在低性能设备上减少卡顿、节省电量，并在高性能设备上提升体验。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-104e87b1a7.png"></p>
<p>这一提案可能与此前的“Compute Pressure API”协同使用，使网页能够实时感知 CPU 负载状况。谷歌表示，这将有助于开发者优化 Web 应用的性能表现，提升整体流畅度。</p>
<p>不过，该功能也引发了隐私担忧。业内人士指出，即使不直接暴露设备型号，网站也可能通过性能数据增强“设备指纹识别”，从而跟踪用户。</p>
<p>除了该提案外，谷歌近期还在测试多项新特性，包括针对 Snapdragon Windows PC 的图形优化、新版搜索框界面，以及桌面端“一键退订”网站通知等改进。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-104e87b1a7.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-104e87b1a7.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 15:41:53 +0800</pubDate>
  </item><item>
    <title><![CDATA[苹果公布最新研究成果：AI 可自动发现代码漏洞并生成测试用例]]></title>
    <link>https://www.oschina.net/news/377986</link>
    <itunes:title><![CDATA[苹果公布最新研究成果：AI 可自动发现代码漏洞并生成测试用例]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>苹果近日在机器学习研究博客上公布三项最新成果，探讨如何利用大语言模型（LLM）和多智能体系统（AI Agents）改进软件测试、缺陷检测与代码修复流程，目标是让 AI 在质量工程（QE, Quality Engineering）中扮演更自动化、更高效的角色，从而减少人工手工写测试、查 bug 的工作量。</p>
<p>研究显示，AI 不仅能自动识别程序中的潜在缺陷，还能生成高质量的测试用例，大幅降低人工测试成本。</p>
<p>三篇论文的亮点包括：</p>
<p><strong>1、Agentic RAG 框架</strong>：通过多个 AI 代理协作完成测试生成、审查与合规性检查任务，测试准备时间减少约 85%，缺陷检测率提升 35%。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6328d70f49.png"></p>
<p><strong>2、SWE-Gym 平台</strong>：为训练软件工程类 AI 代理而设计，能在真实 GitHub 任务中自动解决 72% 以上的问题，并支持“人类在环”的可控测试。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-b3206630f2.png"></p>
<p><strong>3、ADE-QVAET 模型</strong>：结合量子变分自编码器与 Transformer，用于在开发阶段预测潜在代码缺陷，显著提升预测准确率。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-a64367f819.png"></p>
<p>苹果表示，这些研究有望未来融入其开发生态，例如 Xcode 测试工具链，为工程师提供智能化的 Bug 检测与测试生成能力。这也意味着，AI 正在逐步成为苹果软件开发流程中的关键助手。</p>
<p>论文地址：</p>
<ul>
<li>https://machinelearning.apple.com/research/software-defect-prediction</li>
<li>https://machinelearning.apple.com/research/hybrid-vector-graph</li>
<li>https://machinelearning.apple.com/research/training-software</li>
</ul>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>苹果近日在机器学习研究博客上公布三项最新成果，探讨如何利用大语言模型（LLM）和多智能体系统（AI Agents）改进软件测试、缺陷检测与代码修复流程，目标是让 AI 在质量工程（QE, Quality Engineering）中扮演更自动化、更高效的角色，从而减少人工手工写测试、查 bug 的工作量。</p>
<p>研究显示，AI 不仅能自动识别程序中的潜在缺陷，还能生成高质量的测试用例，大幅降低人工测试成本。</p>
<p>三篇论文的亮点包括：</p>
<p><strong>1、Agentic RAG 框架</strong>：通过多个 AI 代理协作完成测试生成、审查与合规性检查任务，测试准备时间减少约 85%，缺陷检测率提升 35%。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6328d70f49.png"></p>
<p><strong>2、SWE-Gym 平台</strong>：为训练软件工程类 AI 代理而设计，能在真实 GitHub 任务中自动解决 72% 以上的问题，并支持“人类在环”的可控测试。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-b3206630f2.png"></p>
<p><strong>3、ADE-QVAET 模型</strong>：结合量子变分自编码器与 Transformer，用于在开发阶段预测潜在代码缺陷，显著提升预测准确率。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-a64367f819.png"></p>
<p>苹果表示，这些研究有望未来融入其开发生态，例如 Xcode 测试工具链，为工程师提供智能化的 Bug 检测与测试生成能力。这也意味着，AI 正在逐步成为苹果软件开发流程中的关键助手。</p>
<p>论文地址：</p>
<ul>
<li>https://machinelearning.apple.com/research/software-defect-prediction</li>
<li>https://machinelearning.apple.com/research/hybrid-vector-graph</li>
<li>https://machinelearning.apple.com/research/training-software</li>
</ul>]]>
    </description>
    <content:encoded><![CDATA[<p>苹果近日在机器学习研究博客上公布三项最新成果，探讨如何利用大语言模型（LLM）和多智能体系统（AI Agents）改进软件测试、缺陷检测与代码修复流程，目标是让 AI 在质量工程（QE, Quality Engineering）中扮演更自动化、更高效的角色，从而减少人工手工写测试、查 bug 的工作量。</p>
<p>研究显示，AI 不仅能自动识别程序中的潜在缺陷，还能生成高质量的测试用例，大幅降低人工测试成本。</p>
<p>三篇论文的亮点包括：</p>
<p><strong>1、Agentic RAG 框架</strong>：通过多个 AI 代理协作完成测试生成、审查与合规性检查任务，测试准备时间减少约 85%，缺陷检测率提升 35%。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6328d70f49.png"></p>
<p><strong>2、SWE-Gym 平台</strong>：为训练软件工程类 AI 代理而设计，能在真实 GitHub 任务中自动解决 72% 以上的问题，并支持“人类在环”的可控测试。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-b3206630f2.png"></p>
<p><strong>3、ADE-QVAET 模型</strong>：结合量子变分自编码器与 Transformer，用于在开发阶段预测潜在代码缺陷，显著提升预测准确率。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-a64367f819.png"></p>
<p>苹果表示，这些研究有望未来融入其开发生态，例如 Xcode 测试工具链，为工程师提供智能化的 Bug 检测与测试生成能力。这也意味着，AI 正在逐步成为苹果软件开发流程中的关键助手。</p>
<p>论文地址：</p>
<ul>
<li>https://machinelearning.apple.com/research/software-defect-prediction</li>
<li>https://machinelearning.apple.com/research/hybrid-vector-graph</li>
<li>https://machinelearning.apple.com/research/training-software</li>
</ul>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6328d70f49.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6328d70f49.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 15:19:11 +0800</pubDate>
  </item><item>
    <title><![CDATA[甲骨文披露订单已超 5000 亿美元，预期 AI 基建毛利率可达 35%]]></title>
    <link>https://www.oschina.net/news/377984</link>
    <itunes:title><![CDATA[甲骨文披露订单已超 5000 亿美元，预期 AI 基建毛利率可达 35%]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><span>甲骨文在拉斯维加斯年度投资者大会上以具体案例说明了AI基础设施业务的盈利前景。一个为期六年、总收入600亿美元的AI基础设施项目，毛利率可达35%。</span></p>
<p><span>此外甲骨文指出现在剩余履约义务（RPO）超过5000亿美元，并预计到2030财年营收将达到2250亿美元。</span></p>
<p><span>此前，尽管甲骨文与OpenAI、Meta和马斯克旗下xAI等客户签署了大量AI数据中心开发协议，提振了公司估值，但华尔街一直质疑此类业务的盈利性。华尔街上周曾提及，甲骨文部分AI云服务的毛利率仅为14%。 彭博行业研究分析师Anurag Rana表示：</span></p>
<p><span>这一数据披露后，市场对AI基础设施业务盈利能力的信心增强，甲骨文股价收涨超3%，盘中一度上涨超5%，同时也带动同行业公司CoreWeave股价上扬。</span></p>
<p><span><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-01b3949fc5.png"></span></p>
<p><span>甲骨文第一财季业绩强劲，但备受关注的云业务上周被爆利润率逊色，因租用英伟达的先进芯片而面临盈利压力。</span></p>
<p><span>甲骨文上月公布的财报显示强劲的增长动能。在截至今年8月末的2026财年第一财季，甲骨文云业务总收入72亿美元，同比增长28%。当季云基础设施（OCI）业务收入33亿美元，同比增长55%。 最令市场瞩目的是，当时甲骨文公布第一财季的剩余履约义务（RPO）、即积压订单价值同比激增359%，增至4550亿美元。这主要受益于与OpenAI等AI公司签署的大额长期合同。</span></p>
<p><span>但是上周二据媒体报道，甲骨文AI云业务在过去一年中面临多重财务压力。</span></p>
<p><span>在截至8月末的公司上一财季，甲骨文的服务器租赁录得收入9亿美元、毛利1.25亿美元，相当于每1美元销售额获得0.14美元利润，即毛利率14%。这低于许多非科技零售企业的毛利率，而且远低于甲骨文传统软件业务约70%的整体毛利率。</span></p>
<p><span>据报道在某些情况下，甲骨文因小批量租赁英伟达新旧版本的芯片而录得“相当多”的亏损，比如上一财季就因租赁英伟达的新版Blackwell架构芯片而亏损近1亿美元。</span></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><span>甲骨文在拉斯维加斯年度投资者大会上以具体案例说明了AI基础设施业务的盈利前景。一个为期六年、总收入600亿美元的AI基础设施项目，毛利率可达35%。</span></p>
<p><span>此外甲骨文指出现在剩余履约义务（RPO）超过5000亿美元，并预计到2030财年营收将达到2250亿美元。</span></p>
<p><span>此前，尽管甲骨文与OpenAI、Meta和马斯克旗下xAI等客户签署了大量AI数据中心开发协议，提振了公司估值，但华尔街一直质疑此类业务的盈利性。华尔街上周曾提及，甲骨文部分AI云服务的毛利率仅为14%。 彭博行业研究分析师Anurag Rana表示：</span></p>
<p><span>这一数据披露后，市场对AI基础设施业务盈利能力的信心增强，甲骨文股价收涨超3%，盘中一度上涨超5%，同时也带动同行业公司CoreWeave股价上扬。</span></p>
<p><span><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-01b3949fc5.png"></span></p>
<p><span>甲骨文第一财季业绩强劲，但备受关注的云业务上周被爆利润率逊色，因租用英伟达的先进芯片而面临盈利压力。</span></p>
<p><span>甲骨文上月公布的财报显示强劲的增长动能。在截至今年8月末的2026财年第一财季，甲骨文云业务总收入72亿美元，同比增长28%。当季云基础设施（OCI）业务收入33亿美元，同比增长55%。 最令市场瞩目的是，当时甲骨文公布第一财季的剩余履约义务（RPO）、即积压订单价值同比激增359%，增至4550亿美元。这主要受益于与OpenAI等AI公司签署的大额长期合同。</span></p>
<p><span>但是上周二据媒体报道，甲骨文AI云业务在过去一年中面临多重财务压力。</span></p>
<p><span>在截至8月末的公司上一财季，甲骨文的服务器租赁录得收入9亿美元、毛利1.25亿美元，相当于每1美元销售额获得0.14美元利润，即毛利率14%。这低于许多非科技零售企业的毛利率，而且远低于甲骨文传统软件业务约70%的整体毛利率。</span></p>
<p><span>据报道在某些情况下，甲骨文因小批量租赁英伟达新旧版本的芯片而录得“相当多”的亏损，比如上一财季就因租赁英伟达的新版Blackwell架构芯片而亏损近1亿美元。</span></p>]]>
    </description>
    <content:encoded><![CDATA[<p><span>甲骨文在拉斯维加斯年度投资者大会上以具体案例说明了AI基础设施业务的盈利前景。一个为期六年、总收入600亿美元的AI基础设施项目，毛利率可达35%。</span></p>
<p><span>此外甲骨文指出现在剩余履约义务（RPO）超过5000亿美元，并预计到2030财年营收将达到2250亿美元。</span></p>
<p><span>此前，尽管甲骨文与OpenAI、Meta和马斯克旗下xAI等客户签署了大量AI数据中心开发协议，提振了公司估值，但华尔街一直质疑此类业务的盈利性。华尔街上周曾提及，甲骨文部分AI云服务的毛利率仅为14%。 彭博行业研究分析师Anurag Rana表示：</span></p>
<p><span>这一数据披露后，市场对AI基础设施业务盈利能力的信心增强，甲骨文股价收涨超3%，盘中一度上涨超5%，同时也带动同行业公司CoreWeave股价上扬。</span></p>
<p><span><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-01b3949fc5.png"></span></p>
<p><span>甲骨文第一财季业绩强劲，但备受关注的云业务上周被爆利润率逊色，因租用英伟达的先进芯片而面临盈利压力。</span></p>
<p><span>甲骨文上月公布的财报显示强劲的增长动能。在截至今年8月末的2026财年第一财季，甲骨文云业务总收入72亿美元，同比增长28%。当季云基础设施（OCI）业务收入33亿美元，同比增长55%。 最令市场瞩目的是，当时甲骨文公布第一财季的剩余履约义务（RPO）、即积压订单价值同比激增359%，增至4550亿美元。这主要受益于与OpenAI等AI公司签署的大额长期合同。</span></p>
<p><span>但是上周二据媒体报道，甲骨文AI云业务在过去一年中面临多重财务压力。</span></p>
<p><span>在截至8月末的公司上一财季，甲骨文的服务器租赁录得收入9亿美元、毛利1.25亿美元，相当于每1美元销售额获得0.14美元利润，即毛利率14%。这低于许多非科技零售企业的毛利率，而且远低于甲骨文传统软件业务约70%的整体毛利率。</span></p>
<p><span>据报道在某些情况下，甲骨文因小批量租赁英伟达新旧版本的芯片而录得“相当多”的亏损，比如上一财季就因租赁英伟达的新版Blackwell架构芯片而亏损近1亿美元。</span></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-01b3949fc5.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-01b3949fc5.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 15:14:17 +0800</pubDate>
  </item><item>
    <title><![CDATA[MemU - 新一代智能体记忆系统]]></title>
    <link>https://www.oschina.net/p/memu</link>
    <itunes:title><![CDATA[MemU - 新一代智能体记忆系统]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><strong>MemU&nbsp;</strong>是一个面向 AI 应用的开源智能体记忆框架，具有高精度、快速检索和低成本等特点。它就像一个智能“记忆文件夹”，由自主代理驱动，能够适应各种 AI 用例的不同场景。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>借助&nbsp;<strong>MemU 的&nbsp;</strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><strong>agentic architecture</strong><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>，你可以构建能够通过自主内存管理真正记住用户的 AI 应用程序。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>它们通过智能体记忆进化机制学习偏好、上下文和行为模式，在每次交互中不断提升智能水平。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-e920dc7aea.png"></p>
<p><span><span>&nbsp;</span>MemU 与传统替代方案的比较：</span></p>
<table border="1" cellspacing="0">
<thead>
<tr>
<th>特性</th>
<th>传统记忆系统</th>
<th>MemU（代理记忆）</th>
</tr>
</thead>
<tbody>
<tr>
<td><span><span><span><strong>结构</strong></span></span></span></td>
<td><span><span><span>碎片化数据</span></span></span></td>
<td><span><span><span>文档/视频/图像（文件系统）</span></span></span></td>
</tr>
<tr>
<td><span><span><span><strong>内存格式</strong></span></span></span></td>
<td><span><span><span>LLM推理</span></span></span></td>
<td><span><span><span>自主&nbsp;</span></span></span><span>Agent-managed</span></td>
</tr>
<tr>
<td><span><span><span><strong>检索方法</strong></span></span></span></td>
<td><span><span><span>嵌入搜索</span></span></span></td>
<td><span><span><span>嵌入搜索 + 文档搜索</span></span></span></td>
</tr>
<tr>
<td><span><span><span><strong>知识库格式</strong></span></span></span></td>
<td><span><span><span>树/图网络</span></span></span></td>
<td><span><span><span>文档间超链接</span></span></span></td>
</tr>
<tr>
<td><span><span><span><strong>自我进化</strong></span></span></span></td>
<td><span><span><span>No</span></span></span></td>
<td><span><span><span>Yes</span></span></span></td>
</tr>
<tr>
<td><span><span><span><strong>遗忘机制</strong></span></span></span></td>
<td><span><span><span>No</span></span></span></td>
<td><span><span><span>Yes</span></span></span></td>
</tr>
</tbody>
</table>
<p><span>MemU 采用先进的 Agentic 内存管理系统，彻底改变了 AI 应用程序处理和保存信息的方式。充当智能文件系统管理器，无需人工干预即可组织和更新内存。</span></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><strong>MemU&nbsp;</strong>是一个面向 AI 应用的开源智能体记忆框架，具有高精度、快速检索和低成本等特点。它就像一个智能“记忆文件夹”，由自主代理驱动，能够适应各种 AI 用例的不同场景。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>借助&nbsp;<strong>MemU 的&nbsp;</strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><strong>agentic architecture</strong><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>，你可以构建能够通过自主内存管理真正记住用户的 AI 应用程序。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>它们通过智能体记忆进化机制学习偏好、上下文和行为模式，在每次交互中不断提升智能水平。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-e920dc7aea.png"></p>
<p><span><span>&nbsp;</span>MemU 与传统替代方案的比较：</span></p>
<table border="1" cellspacing="0">
<thead>
<tr>
<th>特性</th>
<th>传统记忆系统</th>
<th>MemU（代理记忆）</th>
</tr>
</thead>
<tbody>
<tr>
<td><span><span><span><strong>结构</strong></span></span></span></td>
<td><span><span><span>碎片化数据</span></span></span></td>
<td><span><span><span>文档/视频/图像（文件系统）</span></span></span></td>
</tr>
<tr>
<td><span><span><span><strong>内存格式</strong></span></span></span></td>
<td><span><span><span>LLM推理</span></span></span></td>
<td><span><span><span>自主&nbsp;</span></span></span><span>Agent-managed</span></td>
</tr>
<tr>
<td><span><span><span><strong>检索方法</strong></span></span></span></td>
<td><span><span><span>嵌入搜索</span></span></span></td>
<td><span><span><span>嵌入搜索 + 文档搜索</span></span></span></td>
</tr>
<tr>
<td><span><span><span><strong>知识库格式</strong></span></span></span></td>
<td><span><span><span>树/图网络</span></span></span></td>
<td><span><span><span>文档间超链接</span></span></span></td>
</tr>
<tr>
<td><span><span><span><strong>自我进化</strong></span></span></span></td>
<td><span><span><span>No</span></span></span></td>
<td><span><span><span>Yes</span></span></span></td>
</tr>
<tr>
<td><span><span><span><strong>遗忘机制</strong></span></span></span></td>
<td><span><span><span>No</span></span></span></td>
<td><span><span><span>Yes</span></span></span></td>
</tr>
</tbody>
</table>
<p><span>MemU 采用先进的 Agentic 内存管理系统，彻底改变了 AI 应用程序处理和保存信息的方式。充当智能文件系统管理器，无需人工干预即可组织和更新内存。</span></p>]]>
    </description>
    <content:encoded><![CDATA[<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><strong>MemU&nbsp;</strong>是一个面向 AI 应用的开源智能体记忆框架，具有高精度、快速检索和低成本等特点。它就像一个智能“记忆文件夹”，由自主代理驱动，能够适应各种 AI 用例的不同场景。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>借助&nbsp;<strong>MemU 的&nbsp;</strong></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><strong>agentic architecture</strong><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>，你可以构建能够通过自主内存管理真正记住用户的 AI 应用程序。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>它们通过智能体记忆进化机制学习偏好、上下文和行为模式，在每次交互中不断提升智能水平。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-e920dc7aea.png"></p>
<p><span><span>&nbsp;</span>MemU 与传统替代方案的比较：</span></p>
<table border="1" cellspacing="0">
<thead>
<tr>
<th>特性</th>
<th>传统记忆系统</th>
<th>MemU（代理记忆）</th>
</tr>
</thead>
<tbody>
<tr>
<td><span><span><span><strong>结构</strong></span></span></span></td>
<td><span><span><span>碎片化数据</span></span></span></td>
<td><span><span><span>文档/视频/图像（文件系统）</span></span></span></td>
</tr>
<tr>
<td><span><span><span><strong>内存格式</strong></span></span></span></td>
<td><span><span><span>LLM推理</span></span></span></td>
<td><span><span><span>自主&nbsp;</span></span></span><span>Agent-managed</span></td>
</tr>
<tr>
<td><span><span><span><strong>检索方法</strong></span></span></span></td>
<td><span><span><span>嵌入搜索</span></span></span></td>
<td><span><span><span>嵌入搜索 + 文档搜索</span></span></span></td>
</tr>
<tr>
<td><span><span><span><strong>知识库格式</strong></span></span></span></td>
<td><span><span><span>树/图网络</span></span></span></td>
<td><span><span><span>文档间超链接</span></span></span></td>
</tr>
<tr>
<td><span><span><span><strong>自我进化</strong></span></span></span></td>
<td><span><span><span>No</span></span></span></td>
<td><span><span><span>Yes</span></span></span></td>
</tr>
<tr>
<td><span><span><span><strong>遗忘机制</strong></span></span></span></td>
<td><span><span><span>No</span></span></span></td>
<td><span><span><span>Yes</span></span></span></td>
</tr>
</tbody>
</table>
<p><span>MemU 采用先进的 Agentic 内存管理系统，彻底改变了 AI 应用程序处理和保存信息的方式。充当智能文件系统管理器，无需人工干预即可组织和更新内存。</span></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-e920dc7aea.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-e920dc7aea.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 14:43:11 +0800</pubDate>
  </item><item>
    <title><![CDATA[纽约州率先立法禁用 AI 算法租金操控]]></title>
    <link>https://www.oschina.net/news/377979</link>
    <itunes:title><![CDATA[纽约州率先立法禁用 AI 算法租金操控]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>近期，纽约州州长凯西・霍楚尔签署了一项新<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.nysenate.gov%2Flegislation%2Fbills%2F2025%2FA1417%2Famendment%2Foriginal" target="_blank">法律</a>，禁止房东使用 AI 驱动的价格操控软件。纽约成为首个实施这一禁令的州，此前，泽西市、费城、旧金山和西雅图等城市也曾出台过类似措施。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4b38ef046a.png"></p>
<p>这类算法软件，例如由 RealPage 提供的服务，帮助房东计算<span>最佳</span>租金，甚至能评估每个单元适合多少租户和续租条件。RealPage 声称，其算法可以帮助房东 “优化租金”，实现物业收益的<span>最大</span>化。然而，霍楚尔指出，这些所谓的 “私有数据算法” 实际上造成了 “住房市场的扭曲”，让租户在当前住房供应和可负担性危机中面临更多压力。</p>
<p>新法律不仅明确禁止房东利用这些软件来设置租金，还将那些使用该软件的物业所有者视为共谋者。也就是说，多个房东如果共同利用算法进行价格设定，则被认为是选择不在市场中竞争，构成违法行为。根据霍楚尔的发布声明，2024年，美国租户因使用这种软件而损失的金额高达约38亿美元。</p>
<p>与此同时，ProPublica 在2022年的一项调查中显示，RealPage 的算法与全美租金的飙升有着密切的关系。仅仅两年后，美国政府对 RealPage 提起了诉讼。该法案旨在保护租户，防止 “算法价格共谋”。法案的另一位赞助者、州参议员布拉德・霍伊尔曼 - 西戈尔表示，这项法律将更新现有的反垄断法律，明确规定利用人工智能进行租金价格操控是违法的，并确保设定界限，以防止导致反竞争行为的行为。该法律将在60天后正式生效。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>近期，纽约州州长凯西・霍楚尔签署了一项新<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.nysenate.gov%2Flegislation%2Fbills%2F2025%2FA1417%2Famendment%2Foriginal" target="_blank">法律</a>，禁止房东使用 AI 驱动的价格操控软件。纽约成为首个实施这一禁令的州，此前，泽西市、费城、旧金山和西雅图等城市也曾出台过类似措施。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4b38ef046a.png"></p>
<p>这类算法软件，例如由 RealPage 提供的服务，帮助房东计算<span>最佳</span>租金，甚至能评估每个单元适合多少租户和续租条件。RealPage 声称，其算法可以帮助房东 “优化租金”，实现物业收益的<span>最大</span>化。然而，霍楚尔指出，这些所谓的 “私有数据算法” 实际上造成了 “住房市场的扭曲”，让租户在当前住房供应和可负担性危机中面临更多压力。</p>
<p>新法律不仅明确禁止房东利用这些软件来设置租金，还将那些使用该软件的物业所有者视为共谋者。也就是说，多个房东如果共同利用算法进行价格设定，则被认为是选择不在市场中竞争，构成违法行为。根据霍楚尔的发布声明，2024年，美国租户因使用这种软件而损失的金额高达约38亿美元。</p>
<p>与此同时，ProPublica 在2022年的一项调查中显示，RealPage 的算法与全美租金的飙升有着密切的关系。仅仅两年后，美国政府对 RealPage 提起了诉讼。该法案旨在保护租户，防止 “算法价格共谋”。法案的另一位赞助者、州参议员布拉德・霍伊尔曼 - 西戈尔表示，这项法律将更新现有的反垄断法律，明确规定利用人工智能进行租金价格操控是违法的，并确保设定界限，以防止导致反竞争行为的行为。该法律将在60天后正式生效。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>近期，纽约州州长凯西・霍楚尔签署了一项新<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.nysenate.gov%2Flegislation%2Fbills%2F2025%2FA1417%2Famendment%2Foriginal" target="_blank">法律</a>，禁止房东使用 AI 驱动的价格操控软件。纽约成为首个实施这一禁令的州，此前，泽西市、费城、旧金山和西雅图等城市也曾出台过类似措施。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4b38ef046a.png"></p>
<p>这类算法软件，例如由 RealPage 提供的服务，帮助房东计算<span>最佳</span>租金，甚至能评估每个单元适合多少租户和续租条件。RealPage 声称，其算法可以帮助房东 “优化租金”，实现物业收益的<span>最大</span>化。然而，霍楚尔指出，这些所谓的 “私有数据算法” 实际上造成了 “住房市场的扭曲”，让租户在当前住房供应和可负担性危机中面临更多压力。</p>
<p>新法律不仅明确禁止房东利用这些软件来设置租金，还将那些使用该软件的物业所有者视为共谋者。也就是说，多个房东如果共同利用算法进行价格设定，则被认为是选择不在市场中竞争，构成违法行为。根据霍楚尔的发布声明，2024年，美国租户因使用这种软件而损失的金额高达约38亿美元。</p>
<p>与此同时，ProPublica 在2022年的一项调查中显示，RealPage 的算法与全美租金的飙升有着密切的关系。仅仅两年后，美国政府对 RealPage 提起了诉讼。该法案旨在保护租户，防止 “算法价格共谋”。法案的另一位赞助者、州参议员布拉德・霍伊尔曼 - 西戈尔表示，这项法律将更新现有的反垄断法律，明确规定利用人工智能进行租金价格操控是违法的，并确保设定界限，以防止导致反竞争行为的行为。该法律将在60天后正式生效。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4b38ef046a.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4b38ef046a.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 14:35:30 +0800</pubDate>
  </item><item>
    <title><![CDATA[开源深度学习框架 PyTorch 2.9 正式发布：全面强化 AMD 与 Intel GPU 支持]]></title>
    <link>https://www.oschina.net/news/377974/pytorch-2-9</link>
    <itunes:title><![CDATA[开源深度学习框架 PyTorch 2.9 正式发布：全面强化 AMD 与 Intel GPU 支持]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>开源深度学习框架 PyTorch 2.9 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpytorch.org%2Fblog%2Fpytorch-2-9%2F" target="_blank">现已发布</a>，本次更新重点强化了对 AMD ROCm 与 Intel XPU 平台的支持，让安装与部署更加便捷。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-eafcda5310.png"></p>
<p>新版本引入了跨平台的 wheel 变体机制，可根据系统自动选择合适的硬件支持包，用户无需再手动配置安装参数。同时，PyTorch 2.9 还为 AMD ROCm 7.0 平台加<strong>入了 OCP 微缩格式（mx-fp8、mx-fp4） 支持</strong>，并新增了<strong>对称内存（Symmetric Memory）</strong>功能，使多 GPU 编程更加高效。</p>
<p>此外，Intel GPU 用户可获得 FlexAttention 注意力机制优化，ARM 平台也迎来多项性能提升。</p>
<p>整体来看，PyTorch 2.9 的发布标志着该框架在异构硬件生态上的进一步开放与成熟，为开发者在非 NVIDIA 平台上训练与部署 AI 模型提供了更完善的支持。</p>
<p>下载地址：<em>https://github.com/pytorch/pytorch/releases/tag/v2.9.0</em></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>开源深度学习框架 PyTorch 2.9 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpytorch.org%2Fblog%2Fpytorch-2-9%2F" target="_blank">现已发布</a>，本次更新重点强化了对 AMD ROCm 与 Intel XPU 平台的支持，让安装与部署更加便捷。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-eafcda5310.png"></p>
<p>新版本引入了跨平台的 wheel 变体机制，可根据系统自动选择合适的硬件支持包，用户无需再手动配置安装参数。同时，PyTorch 2.9 还为 AMD ROCm 7.0 平台加<strong>入了 OCP 微缩格式（mx-fp8、mx-fp4） 支持</strong>，并新增了<strong>对称内存（Symmetric Memory）</strong>功能，使多 GPU 编程更加高效。</p>
<p>此外，Intel GPU 用户可获得 FlexAttention 注意力机制优化，ARM 平台也迎来多项性能提升。</p>
<p>整体来看，PyTorch 2.9 的发布标志着该框架在异构硬件生态上的进一步开放与成熟，为开发者在非 NVIDIA 平台上训练与部署 AI 模型提供了更完善的支持。</p>
<p>下载地址：<em>https://github.com/pytorch/pytorch/releases/tag/v2.9.0</em></p>]]>
    </description>
    <content:encoded><![CDATA[<p>开源深度学习框架 PyTorch 2.9 <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fpytorch.org%2Fblog%2Fpytorch-2-9%2F" target="_blank">现已发布</a>，本次更新重点强化了对 AMD ROCm 与 Intel XPU 平台的支持，让安装与部署更加便捷。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-eafcda5310.png"></p>
<p>新版本引入了跨平台的 wheel 变体机制，可根据系统自动选择合适的硬件支持包，用户无需再手动配置安装参数。同时，PyTorch 2.9 还为 AMD ROCm 7.0 平台加<strong>入了 OCP 微缩格式（mx-fp8、mx-fp4） 支持</strong>，并新增了<strong>对称内存（Symmetric Memory）</strong>功能，使多 GPU 编程更加高效。</p>
<p>此外，Intel GPU 用户可获得 FlexAttention 注意力机制优化，ARM 平台也迎来多项性能提升。</p>
<p>整体来看，PyTorch 2.9 的发布标志着该框架在异构硬件生态上的进一步开放与成熟，为开发者在非 NVIDIA 平台上训练与部署 AI 模型提供了更完善的支持。</p>
<p>下载地址：<em>https://github.com/pytorch/pytorch/releases/tag/v2.9.0</em></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-eafcda5310.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-eafcda5310.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 14:23:27 +0800</pubDate>
  </item><item>
    <title><![CDATA[百度正式发布多模态文档解析模型方案 PaddleOCR-VL]]></title>
    <link>https://www.oschina.net/news/377949</link>
    <itunes:title><![CDATA[百度正式发布多模态文档解析模型方案 PaddleOCR-VL]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>百度正式发布并开源自研多模态文档解析模型PaddleOCR-VL。在全球权威文档解析评测榜单OmniBenchDoc V1.5中，PaddleOCR-VL以92.6分取得综合性能全球第一成绩，四大核心能力（文本、表格、公式、阅读顺序）全线SOTA，超越 GPT-4o、Gemini-2.5 Pro、Qwen2.5-VL-72B等主流多模态大模型，以及MonkeyOCR-Pro-3B、MinerU2.5、dots.ocr等OCR专业模型，刷新全球OCR VL模型性能天花板。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-d39fe5eff7.png"></p>
<p>据了解，PaddleOCR-VL其核心模型参数仅0.9B，轻量高效，能够在极低计算开销下，精准识别文本、手写汉字、表格、公式、图表等复杂元素，支持109 种语言，覆盖中文、英语、法语、日语、俄语、阿拉伯语、西班牙语等多语场景，广泛适用于政企文档管理、知识检索、档案数字化、科研信息抽取等文档智能任务。</p>
<p>作为文心4.5衍生模型，PaddleOCR-VL-0.9B通过融合NaViT动态分辨率视觉编码器与ERNIE-4.5-0.3B语言模型，在精度与效率上取得双重突破。</p>
<p>精度方面，在OmniDocBench v1.5上，PaddleOCR-VL实现了文本编辑距离仅0.035、公式识别CDM91.43、表格 TEDS93.52、阅读顺序预测误差值0.043的纪录级表现，模型在复杂文档、手写稿、历史档案识别等高难度场景中亦能表现稳定。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-f4e9b14722.png"></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-8be7377b3a.png"></p>
<p>推理方面，在单张A100GPU上，PaddleOCR-VL每秒可处理1881个Token，推理速度较 MinerU2.5提升14.2%，较 dots.ocr 提升253.01%。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-ec7e365032.png"></p>
<p>区别于传统OCR仅能逐行识别文字，PaddleOCR-VL能够像人一样读懂、理解复杂版面结构，精准提取财报表格、数学公式、课堂手写笔记等多元信息，并在识别后自动还原符合人类阅读习惯的阅读顺序，精准区分标题、正文、图片与图注，确保信息无遗漏、逻辑不混乱。</p>
<p>架构上，PaddleOCR-VL 采用创新的两阶段架构：第一阶段由 PP-DocLayoutV2 模型负责版面检测与阅读顺序预测；第二阶段由 PaddleOCR-VL-0.9B 识别并结构化输出文字、表格、公式、图表等元素。相较端到端方案，能够在复杂版面中更稳定、更高效，有效避免多模态模型常见的幻觉与错位问题。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-00db94dc15.png"></p>
<p>凭借轻量架构与高精度表现，PaddleOCR-VL 在性能、成本和落地性上实现最佳平衡，具备强实用价值。其结构化输出能力还能与 RAG（检索增强生成）系统深度结合，为大模型提供高质量知识输入，成为 AI 知识处理新阶段的重要基础设施。</p>
<p><strong>目前，PaddleOCR-VL 已全面开源：</strong></p>
<p>开源地址：https://github.com/PaddlePaddle/PaddleOCR</p>
<p>技术报告地址：https://ernie.baidu.com/blog/publication/PaddleOCR-VL_Technical_Report.pdf</p>
<p>体验Demo地址：https://aistudio.baidu.com/application/detail/98365</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>百度正式发布并开源自研多模态文档解析模型PaddleOCR-VL。在全球权威文档解析评测榜单OmniBenchDoc V1.5中，PaddleOCR-VL以92.6分取得综合性能全球第一成绩，四大核心能力（文本、表格、公式、阅读顺序）全线SOTA，超越 GPT-4o、Gemini-2.5 Pro、Qwen2.5-VL-72B等主流多模态大模型，以及MonkeyOCR-Pro-3B、MinerU2.5、dots.ocr等OCR专业模型，刷新全球OCR VL模型性能天花板。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-d39fe5eff7.png"></p>
<p>据了解，PaddleOCR-VL其核心模型参数仅0.9B，轻量高效，能够在极低计算开销下，精准识别文本、手写汉字、表格、公式、图表等复杂元素，支持109 种语言，覆盖中文、英语、法语、日语、俄语、阿拉伯语、西班牙语等多语场景，广泛适用于政企文档管理、知识检索、档案数字化、科研信息抽取等文档智能任务。</p>
<p>作为文心4.5衍生模型，PaddleOCR-VL-0.9B通过融合NaViT动态分辨率视觉编码器与ERNIE-4.5-0.3B语言模型，在精度与效率上取得双重突破。</p>
<p>精度方面，在OmniDocBench v1.5上，PaddleOCR-VL实现了文本编辑距离仅0.035、公式识别CDM91.43、表格 TEDS93.52、阅读顺序预测误差值0.043的纪录级表现，模型在复杂文档、手写稿、历史档案识别等高难度场景中亦能表现稳定。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-f4e9b14722.png"></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-8be7377b3a.png"></p>
<p>推理方面，在单张A100GPU上，PaddleOCR-VL每秒可处理1881个Token，推理速度较 MinerU2.5提升14.2%，较 dots.ocr 提升253.01%。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-ec7e365032.png"></p>
<p>区别于传统OCR仅能逐行识别文字，PaddleOCR-VL能够像人一样读懂、理解复杂版面结构，精准提取财报表格、数学公式、课堂手写笔记等多元信息，并在识别后自动还原符合人类阅读习惯的阅读顺序，精准区分标题、正文、图片与图注，确保信息无遗漏、逻辑不混乱。</p>
<p>架构上，PaddleOCR-VL 采用创新的两阶段架构：第一阶段由 PP-DocLayoutV2 模型负责版面检测与阅读顺序预测；第二阶段由 PaddleOCR-VL-0.9B 识别并结构化输出文字、表格、公式、图表等元素。相较端到端方案，能够在复杂版面中更稳定、更高效，有效避免多模态模型常见的幻觉与错位问题。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-00db94dc15.png"></p>
<p>凭借轻量架构与高精度表现，PaddleOCR-VL 在性能、成本和落地性上实现最佳平衡，具备强实用价值。其结构化输出能力还能与 RAG（检索增强生成）系统深度结合，为大模型提供高质量知识输入，成为 AI 知识处理新阶段的重要基础设施。</p>
<p><strong>目前，PaddleOCR-VL 已全面开源：</strong></p>
<p>开源地址：https://github.com/PaddlePaddle/PaddleOCR</p>
<p>技术报告地址：https://ernie.baidu.com/blog/publication/PaddleOCR-VL_Technical_Report.pdf</p>
<p>体验Demo地址：https://aistudio.baidu.com/application/detail/98365</p>]]>
    </description>
    <content:encoded><![CDATA[<p>百度正式发布并开源自研多模态文档解析模型PaddleOCR-VL。在全球权威文档解析评测榜单OmniBenchDoc V1.5中，PaddleOCR-VL以92.6分取得综合性能全球第一成绩，四大核心能力（文本、表格、公式、阅读顺序）全线SOTA，超越 GPT-4o、Gemini-2.5 Pro、Qwen2.5-VL-72B等主流多模态大模型，以及MonkeyOCR-Pro-3B、MinerU2.5、dots.ocr等OCR专业模型，刷新全球OCR VL模型性能天花板。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-d39fe5eff7.png"></p>
<p>据了解，PaddleOCR-VL其核心模型参数仅0.9B，轻量高效，能够在极低计算开销下，精准识别文本、手写汉字、表格、公式、图表等复杂元素，支持109 种语言，覆盖中文、英语、法语、日语、俄语、阿拉伯语、西班牙语等多语场景，广泛适用于政企文档管理、知识检索、档案数字化、科研信息抽取等文档智能任务。</p>
<p>作为文心4.5衍生模型，PaddleOCR-VL-0.9B通过融合NaViT动态分辨率视觉编码器与ERNIE-4.5-0.3B语言模型，在精度与效率上取得双重突破。</p>
<p>精度方面，在OmniDocBench v1.5上，PaddleOCR-VL实现了文本编辑距离仅0.035、公式识别CDM91.43、表格 TEDS93.52、阅读顺序预测误差值0.043的纪录级表现，模型在复杂文档、手写稿、历史档案识别等高难度场景中亦能表现稳定。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-f4e9b14722.png"></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-8be7377b3a.png"></p>
<p>推理方面，在单张A100GPU上，PaddleOCR-VL每秒可处理1881个Token，推理速度较 MinerU2.5提升14.2%，较 dots.ocr 提升253.01%。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-ec7e365032.png"></p>
<p>区别于传统OCR仅能逐行识别文字，PaddleOCR-VL能够像人一样读懂、理解复杂版面结构，精准提取财报表格、数学公式、课堂手写笔记等多元信息，并在识别后自动还原符合人类阅读习惯的阅读顺序，精准区分标题、正文、图片与图注，确保信息无遗漏、逻辑不混乱。</p>
<p>架构上，PaddleOCR-VL 采用创新的两阶段架构：第一阶段由 PP-DocLayoutV2 模型负责版面检测与阅读顺序预测；第二阶段由 PaddleOCR-VL-0.9B 识别并结构化输出文字、表格、公式、图表等元素。相较端到端方案，能够在复杂版面中更稳定、更高效，有效避免多模态模型常见的幻觉与错位问题。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-00db94dc15.png"></p>
<p>凭借轻量架构与高精度表现，PaddleOCR-VL 在性能、成本和落地性上实现最佳平衡，具备强实用价值。其结构化输出能力还能与 RAG（检索增强生成）系统深度结合，为大模型提供高质量知识输入，成为 AI 知识处理新阶段的重要基础设施。</p>
<p><strong>目前，PaddleOCR-VL 已全面开源：</strong></p>
<p>开源地址：https://github.com/PaddlePaddle/PaddleOCR</p>
<p>技术报告地址：https://ernie.baidu.com/blog/publication/PaddleOCR-VL_Technical_Report.pdf</p>
<p>体验Demo地址：https://aistudio.baidu.com/application/detail/98365</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-d39fe5eff7.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-d39fe5eff7.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 12:28:26 +0800</pubDate>
  </item><item>
    <title><![CDATA[Anthropic 预计 2026 年收入将突破 200 亿美元]]></title>
    <link>https://www.oschina.net/news/377945</link>
    <itunes:title><![CDATA[Anthropic 预计 2026 年收入将突破 200 亿美元]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><span>路透社援引两位知情人士的消息报道，知名 AI 初创公司 Anthropic 预计其年收入将在未来两年内实现近三倍的增长。这家公司目前正处于强劲的增长轨道上，主要得益于其快速扩张的企业客户基础。</span></p>
<p><span>Anthropic 预计其年收入目标如下：2025年底&nbsp;预计年收入将达到&nbsp;90亿美元。2026年&nbsp;在基准情景下，收入目标将超过200亿美元；在最乐观的情况下，收入甚至可能达到&nbsp;260亿美元。该公司向路透社透露，截至今年10月，其年化收入已达到约&nbsp;70亿美元。</span></p>
<p><span><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-f5d9816086.png"></span></p>
<p><span>Anthropic 收入的巨大增长主要归功于其企业客户群体，该群体目前贡献了公司约80% 的收入。这表明 Anthropic 的旗舰模型 Claude 及其相关服务正在被大量企业用户采纳和部署。</span></p>
<p><span>近期，这家估值高达1830亿美元的初创公司刚刚完成了新一轮融资，共筹集了130亿美元的资金，为其雄心勃勃的增长计划提供了充足的弹药。</span></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><span>路透社援引两位知情人士的消息报道，知名 AI 初创公司 Anthropic 预计其年收入将在未来两年内实现近三倍的增长。这家公司目前正处于强劲的增长轨道上，主要得益于其快速扩张的企业客户基础。</span></p>
<p><span>Anthropic 预计其年收入目标如下：2025年底&nbsp;预计年收入将达到&nbsp;90亿美元。2026年&nbsp;在基准情景下，收入目标将超过200亿美元；在最乐观的情况下，收入甚至可能达到&nbsp;260亿美元。该公司向路透社透露，截至今年10月，其年化收入已达到约&nbsp;70亿美元。</span></p>
<p><span><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-f5d9816086.png"></span></p>
<p><span>Anthropic 收入的巨大增长主要归功于其企业客户群体，该群体目前贡献了公司约80% 的收入。这表明 Anthropic 的旗舰模型 Claude 及其相关服务正在被大量企业用户采纳和部署。</span></p>
<p><span>近期，这家估值高达1830亿美元的初创公司刚刚完成了新一轮融资，共筹集了130亿美元的资金，为其雄心勃勃的增长计划提供了充足的弹药。</span></p>]]>
    </description>
    <content:encoded><![CDATA[<p><span>路透社援引两位知情人士的消息报道，知名 AI 初创公司 Anthropic 预计其年收入将在未来两年内实现近三倍的增长。这家公司目前正处于强劲的增长轨道上，主要得益于其快速扩张的企业客户基础。</span></p>
<p><span>Anthropic 预计其年收入目标如下：2025年底&nbsp;预计年收入将达到&nbsp;90亿美元。2026年&nbsp;在基准情景下，收入目标将超过200亿美元；在最乐观的情况下，收入甚至可能达到&nbsp;260亿美元。该公司向路透社透露，截至今年10月，其年化收入已达到约&nbsp;70亿美元。</span></p>
<p><span><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-f5d9816086.png"></span></p>
<p><span>Anthropic 收入的巨大增长主要归功于其企业客户群体，该群体目前贡献了公司约80% 的收入。这表明 Anthropic 的旗舰模型 Claude 及其相关服务正在被大量企业用户采纳和部署。</span></p>
<p><span>近期，这家估值高达1830亿美元的初创公司刚刚完成了新一轮融资，共筹集了130亿美元的资金，为其雄心勃勃的增长计划提供了充足的弹药。</span></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-f5d9816086.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-f5d9816086.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 11:53:05 +0800</pubDate>
  </item><item>
    <title><![CDATA[​OpenAI Sora 2 新功能上线，Pro 用户生成视频长达 25 秒]]></title>
    <link>https://www.oschina.net/news/377940</link>
    <itunes:title><![CDATA[​OpenAI Sora 2 新功能上线，Pro 用户生成视频长达 25 秒]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>在最近的一次更新中，OpenAI 宣布了其视频生成平台 Sora2的新功能，吸引了众多用户的关注。</p>
<p>此次更新主要包括两个重要的变化：首先，故事板功能现已在网页版本中向专业用户开放。用户可以在 sora.com 上选择 “故事板” 选项，开始创作属于自己的视觉故事。这个功能让视频创作者能够更直观地规划他们的内容，为创作过程带来了更大的灵活性和便利性。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e6c2f364b7.png"></p>
<p>其次，所有用户在应用程序和网页上均可生成最长15秒的视频，而专业用户在网页上可生成最长25秒的视频。</p>
<p>尽管有诸多新功能上线，但部分用户也反馈了在使用过程中的一些问题。例如，有用户指出在网页上无法看到15秒视频生成的选项，且下载按钮在某些位置无法正常使用，导致无法下载视频。OpenAI 对于用户的反馈非常重视，希望能够持续改善用户体验。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>在最近的一次更新中，OpenAI 宣布了其视频生成平台 Sora2的新功能，吸引了众多用户的关注。</p>
<p>此次更新主要包括两个重要的变化：首先，故事板功能现已在网页版本中向专业用户开放。用户可以在 sora.com 上选择 “故事板” 选项，开始创作属于自己的视觉故事。这个功能让视频创作者能够更直观地规划他们的内容，为创作过程带来了更大的灵活性和便利性。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e6c2f364b7.png"></p>
<p>其次，所有用户在应用程序和网页上均可生成最长15秒的视频，而专业用户在网页上可生成最长25秒的视频。</p>
<p>尽管有诸多新功能上线，但部分用户也反馈了在使用过程中的一些问题。例如，有用户指出在网页上无法看到15秒视频生成的选项，且下载按钮在某些位置无法正常使用，导致无法下载视频。OpenAI 对于用户的反馈非常重视，希望能够持续改善用户体验。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>在最近的一次更新中，OpenAI 宣布了其视频生成平台 Sora2的新功能，吸引了众多用户的关注。</p>
<p>此次更新主要包括两个重要的变化：首先，故事板功能现已在网页版本中向专业用户开放。用户可以在 sora.com 上选择 “故事板” 选项，开始创作属于自己的视觉故事。这个功能让视频创作者能够更直观地规划他们的内容，为创作过程带来了更大的灵活性和便利性。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e6c2f364b7.png"></p>
<p>其次，所有用户在应用程序和网页上均可生成最长15秒的视频，而专业用户在网页上可生成最长25秒的视频。</p>
<p>尽管有诸多新功能上线，但部分用户也反馈了在使用过程中的一些问题。例如，有用户指出在网页上无法看到15秒视频生成的选项，且下载按钮在某些位置无法正常使用，导致无法下载视频。OpenAI 对于用户的反馈非常重视，希望能够持续改善用户体验。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e6c2f364b7.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e6c2f364b7.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 11:32:07 +0800</pubDate>
  </item><item>
    <title><![CDATA[王莆中：美团在 AI 上的投入是百亿人民币级别]]></title>
    <link>https://www.oschina.net/news/377938</link>
    <itunes:title><![CDATA[王莆中：美团在 AI 上的投入是百亿人民币级别]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>10 月 16 日消息，第八届餐饮产业大会上，美团核心本地商业 CEO 王莆中谈到美团在 AI 上的投入是如何回馈到餐饮行业。他透露，美团在 AI 上的投入是不小的，投入的是百亿人民币级别的。</p>
<p>美团大语言模型 LongCat 目前已经开源。LongCat 大模型快而且准，LongCat 是 500B 参数级最快的模型，也是全世界目前为止唯一一个用中国国产芯片做训练的模型。最重要的是融合了美团在餐饮行业万亿级数据去打造为餐饮企业餐饮行业服务的这样一个特点。王莆中强调：「算力、算法都可以花钱买到，只有数据是买不到的。」</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-015e4c98c2.png"></p>
<p>同时，王莆中宣布正式发布一个小工具「袋鼠参谋」，希望 AI 能够真正的进入餐饮行业的决策流程，让决策更加科学，让经营更加高效。这个产品能够为大家开店和科学决策带来很多新的判断的依据。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>10 月 16 日消息，第八届餐饮产业大会上，美团核心本地商业 CEO 王莆中谈到美团在 AI 上的投入是如何回馈到餐饮行业。他透露，美团在 AI 上的投入是不小的，投入的是百亿人民币级别的。</p>
<p>美团大语言模型 LongCat 目前已经开源。LongCat 大模型快而且准，LongCat 是 500B 参数级最快的模型，也是全世界目前为止唯一一个用中国国产芯片做训练的模型。最重要的是融合了美团在餐饮行业万亿级数据去打造为餐饮企业餐饮行业服务的这样一个特点。王莆中强调：「算力、算法都可以花钱买到，只有数据是买不到的。」</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-015e4c98c2.png"></p>
<p>同时，王莆中宣布正式发布一个小工具「袋鼠参谋」，希望 AI 能够真正的进入餐饮行业的决策流程，让决策更加科学，让经营更加高效。这个产品能够为大家开店和科学决策带来很多新的判断的依据。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>10 月 16 日消息，第八届餐饮产业大会上，美团核心本地商业 CEO 王莆中谈到美团在 AI 上的投入是如何回馈到餐饮行业。他透露，美团在 AI 上的投入是不小的，投入的是百亿人民币级别的。</p>
<p>美团大语言模型 LongCat 目前已经开源。LongCat 大模型快而且准，LongCat 是 500B 参数级最快的模型，也是全世界目前为止唯一一个用中国国产芯片做训练的模型。最重要的是融合了美团在餐饮行业万亿级数据去打造为餐饮企业餐饮行业服务的这样一个特点。王莆中强调：「算力、算法都可以花钱买到，只有数据是买不到的。」</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-015e4c98c2.png"></p>
<p>同时，王莆中宣布正式发布一个小工具「袋鼠参谋」，希望 AI 能够真正的进入餐饮行业的决策流程，让决策更加科学，让经营更加高效。这个产品能够为大家开店和科学决策带来很多新的判断的依据。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-015e4c98c2.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-015e4c98c2.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 11:23:52 +0800</pubDate>
  </item><item>
    <title><![CDATA[deepin 25 成功适配瑞莎 Dragon Q6A，开启高性能 ARM 桌面体验]]></title>
    <link>https://www.oschina.net/news/377935</link>
    <itunes:title><![CDATA[deepin 25 成功适配瑞莎 Dragon Q6A，开启高性能 ARM 桌面体验]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<div>
<p>deepin 作为国内领先的 Linux 操作系统发行版，始终致力于将统一、美观、易用的桌面体验带给更广泛的硬件平台。作为多架构支持的关键一环，deepin-ports SIG（特别兴趣小组）在 ARM 架构的适配工作上不断深耕。</p>
<p>近期，deepin 社区宣布，最新的 deepin 25 操作系统已成功适配瑞莎科技（Radxa）推出的 Dragon Q6A 开发板。此次适配覆盖核心硬件驱动与系统功能，为开发者提供稳定的软硬协同基础。</p>
<p>【国产软硬合一新标杆！deepin 25 X 瑞莎 Dragon Q6A 开箱评测，体验真香！】</p>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1B9Wqz5EKT" target="_blank">https://www.bilibili.com/video/BV1B9Wqz5EKT</a></p>
<h1><span><strong>强强联合：高性能硬件&amp;国产操作系统</strong></span></h1>
<p>瑞莎 Dragon Q6A 是一款基于高通 QCS6490 处理器的高性能、低功耗嵌入式开发平台，专为物联网、边缘计算和人工智能设计。主频最高 2.7 GHz，集成高通 Adreno 643 GPU，高通 Hexagon 770 NPU，支持多种扩展接口。</p>
<p>搭载高通跃龙平台 QCS6490 SoC，采用 1+3+4 三丛集 CPU 设计，拥有1× Kryo Prime @ 2.7GHz(Cortex-A78) + 3× Kryo Gold @ 2.4GHz(Cortex-A78) + 4× Kryo Silver @ 1.9GHz(Cortex-A55)，兼顾高性能与低功耗；集成 Qualcomm® Adreno 643 GPU 、VPU 以及 AI 加速单元 NPU，具备先进 AI 加速能力和多媒体处理能力。</p>
<div>
<div>
【Radxa Dragon Q6A】
</div>
</div>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-607328d642.png"></p>
<h1><strong><strong>运行实例：深度体验即刻呈现</strong></strong></h1>
<p>deepin 25 操作系统素以易用性和美观界面著称，此次适配意味着 Dragon Q6A 用户可获得与 X86 平台相近的桌面体验。</p>
<p>【deepin 25 &amp; Radxa Dragon Q6A】</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0a7090ed52.png"></p>
</div>
<div>
<h2><strong>预装软件列表：</strong></h2>
<p>为方便用户快速上手，镜像中已预装一套完整的软件生态，满足日常开发与使用需求：</p>
<ul>
<li><strong>内核与驱动</strong>: 搭载为 Q6A 定制优化的最新 6.15 Linux 内核，集成了 Dragon Q6A 所需的 GPU、无线网络、蓝牙及其他关键硬件驱动和模块，保证系统开箱即用。</li>
<li><strong>系统基础</strong>: 包含 sudo、network-manager、bash-completion 等基础工具，方便用户进行系统管理和网络配置。</li>
<li><strong>桌面体验</strong>: 完整的 deepin 桌面环境 (DDE)，以其现代化的设计、流畅的交互和强大的功能而著称，为用户提供舒适高效的操作体验。预装最新 Treeland 窗口合成器，可在控制中心一键切换 Wayland 桌面。</li>
<li><strong>实用工具</strong>: 使用玲珑软件包管理器预装了文本编辑器、终端、看图工具等常用软件，方便开发者和高级用户使用。</li>
</ul>
<h1><strong>deepin-ports SIG 持续维护</strong></h1>
<p>deepin-ports SIG 已将瑞莎 Dragon Q6A 正式列入 deepin 25 ARM 架构支持设备列表，并将为其提供持续的软件更新和性能优化，确保用户获得稳定、长期的优质体验。</p>
<ul>
<li> <p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeepin-community.github.io%2Fsig-deepin-ports%2Fimages%2Farm64" target="_blank">https://deepin-community.github.io/sig-deepin-ports/images/arm64</a></p> </li>
</ul>
<p>此次适配填补了高通 QCS6490 平台与国产桌面系统的兼容空白，更为开发者在各应用场景下提供 “硬件 + 系统” 一体化开源解决方案，有助于缩短产品开发周期 ，助力相关领域产品快速落地。</p>
</div>
<div>
<div>
<p>本次合作也是 deepin (深度) 社区与硬件伙伴紧密合作的又一重要里程碑，特别感谢瑞莎 (Radxa) 在此过程中给予的大力支持与协作。</p>
<p>期待未来能有更多优秀的硬件厂商加入 deepin 生态建设，共同推动国产操作系统在更广泛的硬件平台上落地生根、蓬勃发展！</p>
</div>
</div>
<div>
<p><strong>关于 deepin（深度）社区</strong></p>
<p>deepin（深度）社区是国内历史悠久、全球规模最大且最活跃的开源操作系统社区之一，也是中国首个桌面操作系统根社区，致力于推动桌面操作系统的开源与创新，为全球个人及组织提供开放透明的共建共治共享平台及超出预期的开源操作系统。</p>
</div>]]>
    </itunes:summary>
    <description>
      <![CDATA[<div>
<p>deepin 作为国内领先的 Linux 操作系统发行版，始终致力于将统一、美观、易用的桌面体验带给更广泛的硬件平台。作为多架构支持的关键一环，deepin-ports SIG（特别兴趣小组）在 ARM 架构的适配工作上不断深耕。</p>
<p>近期，deepin 社区宣布，最新的 deepin 25 操作系统已成功适配瑞莎科技（Radxa）推出的 Dragon Q6A 开发板。此次适配覆盖核心硬件驱动与系统功能，为开发者提供稳定的软硬协同基础。</p>
<p>【国产软硬合一新标杆！deepin 25 X 瑞莎 Dragon Q6A 开箱评测，体验真香！】</p>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1B9Wqz5EKT" target="_blank">https://www.bilibili.com/video/BV1B9Wqz5EKT</a></p>
<h1><span><strong>强强联合：高性能硬件&amp;国产操作系统</strong></span></h1>
<p>瑞莎 Dragon Q6A 是一款基于高通 QCS6490 处理器的高性能、低功耗嵌入式开发平台，专为物联网、边缘计算和人工智能设计。主频最高 2.7 GHz，集成高通 Adreno 643 GPU，高通 Hexagon 770 NPU，支持多种扩展接口。</p>
<p>搭载高通跃龙平台 QCS6490 SoC，采用 1+3+4 三丛集 CPU 设计，拥有1× Kryo Prime @ 2.7GHz(Cortex-A78) + 3× Kryo Gold @ 2.4GHz(Cortex-A78) + 4× Kryo Silver @ 1.9GHz(Cortex-A55)，兼顾高性能与低功耗；集成 Qualcomm® Adreno 643 GPU 、VPU 以及 AI 加速单元 NPU，具备先进 AI 加速能力和多媒体处理能力。</p>
<div>
<div>
【Radxa Dragon Q6A】
</div>
</div>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-607328d642.png"></p>
<h1><strong><strong>运行实例：深度体验即刻呈现</strong></strong></h1>
<p>deepin 25 操作系统素以易用性和美观界面著称，此次适配意味着 Dragon Q6A 用户可获得与 X86 平台相近的桌面体验。</p>
<p>【deepin 25 &amp; Radxa Dragon Q6A】</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0a7090ed52.png"></p>
</div>
<div>
<h2><strong>预装软件列表：</strong></h2>
<p>为方便用户快速上手，镜像中已预装一套完整的软件生态，满足日常开发与使用需求：</p>
<ul>
<li><strong>内核与驱动</strong>: 搭载为 Q6A 定制优化的最新 6.15 Linux 内核，集成了 Dragon Q6A 所需的 GPU、无线网络、蓝牙及其他关键硬件驱动和模块，保证系统开箱即用。</li>
<li><strong>系统基础</strong>: 包含 sudo、network-manager、bash-completion 等基础工具，方便用户进行系统管理和网络配置。</li>
<li><strong>桌面体验</strong>: 完整的 deepin 桌面环境 (DDE)，以其现代化的设计、流畅的交互和强大的功能而著称，为用户提供舒适高效的操作体验。预装最新 Treeland 窗口合成器，可在控制中心一键切换 Wayland 桌面。</li>
<li><strong>实用工具</strong>: 使用玲珑软件包管理器预装了文本编辑器、终端、看图工具等常用软件，方便开发者和高级用户使用。</li>
</ul>
<h1><strong>deepin-ports SIG 持续维护</strong></h1>
<p>deepin-ports SIG 已将瑞莎 Dragon Q6A 正式列入 deepin 25 ARM 架构支持设备列表，并将为其提供持续的软件更新和性能优化，确保用户获得稳定、长期的优质体验。</p>
<ul>
<li> <p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeepin-community.github.io%2Fsig-deepin-ports%2Fimages%2Farm64" target="_blank">https://deepin-community.github.io/sig-deepin-ports/images/arm64</a></p> </li>
</ul>
<p>此次适配填补了高通 QCS6490 平台与国产桌面系统的兼容空白，更为开发者在各应用场景下提供 “硬件 + 系统” 一体化开源解决方案，有助于缩短产品开发周期 ，助力相关领域产品快速落地。</p>
</div>
<div>
<div>
<p>本次合作也是 deepin (深度) 社区与硬件伙伴紧密合作的又一重要里程碑，特别感谢瑞莎 (Radxa) 在此过程中给予的大力支持与协作。</p>
<p>期待未来能有更多优秀的硬件厂商加入 deepin 生态建设，共同推动国产操作系统在更广泛的硬件平台上落地生根、蓬勃发展！</p>
</div>
</div>
<div>
<p><strong>关于 deepin（深度）社区</strong></p>
<p>deepin（深度）社区是国内历史悠久、全球规模最大且最活跃的开源操作系统社区之一，也是中国首个桌面操作系统根社区，致力于推动桌面操作系统的开源与创新，为全球个人及组织提供开放透明的共建共治共享平台及超出预期的开源操作系统。</p>
</div>]]>
    </description>
    <content:encoded><![CDATA[<div>
<p>deepin 作为国内领先的 Linux 操作系统发行版，始终致力于将统一、美观、易用的桌面体验带给更广泛的硬件平台。作为多架构支持的关键一环，deepin-ports SIG（特别兴趣小组）在 ARM 架构的适配工作上不断深耕。</p>
<p>近期，deepin 社区宣布，最新的 deepin 25 操作系统已成功适配瑞莎科技（Radxa）推出的 Dragon Q6A 开发板。此次适配覆盖核心硬件驱动与系统功能，为开发者提供稳定的软硬协同基础。</p>
<p>【国产软硬合一新标杆！deepin 25 X 瑞莎 Dragon Q6A 开箱评测，体验真香！】</p>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1B9Wqz5EKT" target="_blank">https://www.bilibili.com/video/BV1B9Wqz5EKT</a></p>
<h1><span><strong>强强联合：高性能硬件&amp;国产操作系统</strong></span></h1>
<p>瑞莎 Dragon Q6A 是一款基于高通 QCS6490 处理器的高性能、低功耗嵌入式开发平台，专为物联网、边缘计算和人工智能设计。主频最高 2.7 GHz，集成高通 Adreno 643 GPU，高通 Hexagon 770 NPU，支持多种扩展接口。</p>
<p>搭载高通跃龙平台 QCS6490 SoC，采用 1+3+4 三丛集 CPU 设计，拥有1× Kryo Prime @ 2.7GHz(Cortex-A78) + 3× Kryo Gold @ 2.4GHz(Cortex-A78) + 4× Kryo Silver @ 1.9GHz(Cortex-A55)，兼顾高性能与低功耗；集成 Qualcomm® Adreno 643 GPU 、VPU 以及 AI 加速单元 NPU，具备先进 AI 加速能力和多媒体处理能力。</p>
<div>
<div>
【Radxa Dragon Q6A】
</div>
</div>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-607328d642.png"></p>
<h1><strong><strong>运行实例：深度体验即刻呈现</strong></strong></h1>
<p>deepin 25 操作系统素以易用性和美观界面著称，此次适配意味着 Dragon Q6A 用户可获得与 X86 平台相近的桌面体验。</p>
<p>【deepin 25 &amp; Radxa Dragon Q6A】</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0a7090ed52.png"></p>
</div>
<div>
<h2><strong>预装软件列表：</strong></h2>
<p>为方便用户快速上手，镜像中已预装一套完整的软件生态，满足日常开发与使用需求：</p>
<ul>
<li><strong>内核与驱动</strong>: 搭载为 Q6A 定制优化的最新 6.15 Linux 内核，集成了 Dragon Q6A 所需的 GPU、无线网络、蓝牙及其他关键硬件驱动和模块，保证系统开箱即用。</li>
<li><strong>系统基础</strong>: 包含 sudo、network-manager、bash-completion 等基础工具，方便用户进行系统管理和网络配置。</li>
<li><strong>桌面体验</strong>: 完整的 deepin 桌面环境 (DDE)，以其现代化的设计、流畅的交互和强大的功能而著称，为用户提供舒适高效的操作体验。预装最新 Treeland 窗口合成器，可在控制中心一键切换 Wayland 桌面。</li>
<li><strong>实用工具</strong>: 使用玲珑软件包管理器预装了文本编辑器、终端、看图工具等常用软件，方便开发者和高级用户使用。</li>
</ul>
<h1><strong>deepin-ports SIG 持续维护</strong></h1>
<p>deepin-ports SIG 已将瑞莎 Dragon Q6A 正式列入 deepin 25 ARM 架构支持设备列表，并将为其提供持续的软件更新和性能优化，确保用户获得稳定、长期的优质体验。</p>
<ul>
<li> <p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fdeepin-community.github.io%2Fsig-deepin-ports%2Fimages%2Farm64" target="_blank">https://deepin-community.github.io/sig-deepin-ports/images/arm64</a></p> </li>
</ul>
<p>此次适配填补了高通 QCS6490 平台与国产桌面系统的兼容空白，更为开发者在各应用场景下提供 “硬件 + 系统” 一体化开源解决方案，有助于缩短产品开发周期 ，助力相关领域产品快速落地。</p>
</div>
<div>
<div>
<p>本次合作也是 deepin (深度) 社区与硬件伙伴紧密合作的又一重要里程碑，特别感谢瑞莎 (Radxa) 在此过程中给予的大力支持与协作。</p>
<p>期待未来能有更多优秀的硬件厂商加入 deepin 生态建设，共同推动国产操作系统在更广泛的硬件平台上落地生根、蓬勃发展！</p>
</div>
</div>
<div>
<p><strong>关于 deepin（深度）社区</strong></p>
<p>deepin（深度）社区是国内历史悠久、全球规模最大且最活跃的开源操作系统社区之一，也是中国首个桌面操作系统根社区，致力于推动桌面操作系统的开源与创新，为全球个人及组织提供开放透明的共建共治共享平台及超出预期的开源操作系统。</p>
</div>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-607328d642.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-607328d642.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 11:10:06 +0800</pubDate>
  </item><item>
    <title><![CDATA[天猫双十一首日大模型被调用 150 亿次]]></title>
    <link>https://www.oschina.net/news/377933</link>
    <itunes:title><![CDATA[天猫双十一首日大模型被调用 150 亿次]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><span>从天猫双11发布会上获悉，今年双11成为天猫首个AI全面落地的购物节点。AI在淘天的流量分发、消费者体验、电商经营三大维度为消费者与商家提供服务。发布会上，淘宝天猫同步推出6款AI导购应用，涵盖AI万能搜、AI帮我挑、AI试衣、拍立淘、AI清单及品类清单。</span></p>
<p><span>据悉，今年天猫双11首日，大模型被调用150亿次。</span></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-a880bf65a9.png"></p>
<p><span>天猫总裁家洛在接受《科创板日报》等记者采访时表示，现在淘天团队对AI不仅仅是全面拥抱，而是全面的运营、参与以及执行。今年以来，淘宝天猫在AI产研领域重点押注，平台算力已实现40倍提升，对用户行为序列长度的感知周期从半年延长至10年，这一技术突破直接带动用户购买效率提升25%。</span></p>
<p><span>值得关注的是，今年双11期间计划发放的500亿部分消费券，也将由AI“智惠引擎”统一决策发放。据淘天方面试点期数据显示，该引擎的发券转化率较以往提升 15%，精准度与效率显著优于传统模式。</span></p>
<p><span>在京东11.11惊喜开放日活动中，京东公布了双11期间的AI支持方案，包括向商家提供京小智、京点点等智能AI工具，免费开放大模型客服、设计智能体等服务，旨在为商家提供从客服沟通到广告设计的全方位支持。</span></p>
<p><span>抖音电商则延续“内容场智能升级”路线，巨量云图整合大数据与AI大语言模型技术，深度分析消费者行为与内容偏好。通过这一技术，品牌商家能够更准确地定位商品核心卖点，发掘潜力营销场景。</span></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><span>从天猫双11发布会上获悉，今年双11成为天猫首个AI全面落地的购物节点。AI在淘天的流量分发、消费者体验、电商经营三大维度为消费者与商家提供服务。发布会上，淘宝天猫同步推出6款AI导购应用，涵盖AI万能搜、AI帮我挑、AI试衣、拍立淘、AI清单及品类清单。</span></p>
<p><span>据悉，今年天猫双11首日，大模型被调用150亿次。</span></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-a880bf65a9.png"></p>
<p><span>天猫总裁家洛在接受《科创板日报》等记者采访时表示，现在淘天团队对AI不仅仅是全面拥抱，而是全面的运营、参与以及执行。今年以来，淘宝天猫在AI产研领域重点押注，平台算力已实现40倍提升，对用户行为序列长度的感知周期从半年延长至10年，这一技术突破直接带动用户购买效率提升25%。</span></p>
<p><span>值得关注的是，今年双11期间计划发放的500亿部分消费券，也将由AI“智惠引擎”统一决策发放。据淘天方面试点期数据显示，该引擎的发券转化率较以往提升 15%，精准度与效率显著优于传统模式。</span></p>
<p><span>在京东11.11惊喜开放日活动中，京东公布了双11期间的AI支持方案，包括向商家提供京小智、京点点等智能AI工具，免费开放大模型客服、设计智能体等服务，旨在为商家提供从客服沟通到广告设计的全方位支持。</span></p>
<p><span>抖音电商则延续“内容场智能升级”路线，巨量云图整合大数据与AI大语言模型技术，深度分析消费者行为与内容偏好。通过这一技术，品牌商家能够更准确地定位商品核心卖点，发掘潜力营销场景。</span></p>]]>
    </description>
    <content:encoded><![CDATA[<p><span>从天猫双11发布会上获悉，今年双11成为天猫首个AI全面落地的购物节点。AI在淘天的流量分发、消费者体验、电商经营三大维度为消费者与商家提供服务。发布会上，淘宝天猫同步推出6款AI导购应用，涵盖AI万能搜、AI帮我挑、AI试衣、拍立淘、AI清单及品类清单。</span></p>
<p><span>据悉，今年天猫双11首日，大模型被调用150亿次。</span></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-a880bf65a9.png"></p>
<p><span>天猫总裁家洛在接受《科创板日报》等记者采访时表示，现在淘天团队对AI不仅仅是全面拥抱，而是全面的运营、参与以及执行。今年以来，淘宝天猫在AI产研领域重点押注，平台算力已实现40倍提升，对用户行为序列长度的感知周期从半年延长至10年，这一技术突破直接带动用户购买效率提升25%。</span></p>
<p><span>值得关注的是，今年双11期间计划发放的500亿部分消费券，也将由AI“智惠引擎”统一决策发放。据淘天方面试点期数据显示，该引擎的发券转化率较以往提升 15%，精准度与效率显著优于传统模式。</span></p>
<p><span>在京东11.11惊喜开放日活动中，京东公布了双11期间的AI支持方案，包括向商家提供京小智、京点点等智能AI工具，免费开放大模型客服、设计智能体等服务，旨在为商家提供从客服沟通到广告设计的全方位支持。</span></p>
<p><span>抖音电商则延续“内容场智能升级”路线，巨量云图整合大数据与AI大语言模型技术，深度分析消费者行为与内容偏好。通过这一技术，品牌商家能够更准确地定位商品核心卖点，发掘潜力营销场景。</span></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-a880bf65a9.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-a880bf65a9.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 11:06:43 +0800</pubDate>
  </item><item>
    <title><![CDATA[:fire: 全球首个支持 IETF JSONPath (RFC 9535) 标准的 Java 框架发布]]></title>
    <link>https://www.oschina.net/news/377931</link>
    <itunes:title><![CDATA[:fire: 全球首个支持 IETF JSONPath (RFC 9535) 标准的 Java 框架发布]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>基于jdk8。支持：Json Dom 的构建、编码解转换、获取、JsonPath 查询、JsonSchema 验证。</p>
<pre><code><span>&lt;<span>dependency</span>&gt;</span>
<span>&lt;<span>groupId</span>&gt;</span>org.noear<span>&lt;/<span>groupId</span>&gt;</span>
<span>&lt;<span>artifactId</span>&gt;</span>snack4-jsonpath<span>&lt;/<span>artifactId</span>&gt;</span>
<span>&lt;<span>version</span>&gt;</span>4.0.0<span>&lt;/<span>version</span>&gt;</span>
<span>&lt;/<span>dependency</span>&gt;</span>
</code></pre>
<p>Snack-Jsonpath 借鉴了<span>&nbsp;</span><code>Javascript</code><span>&nbsp;</span>所有变量由<span>&nbsp;</span><code>var</code><span>&nbsp;</span>申明，及<span>&nbsp;</span><code>Xml dom</code><span>&nbsp;</span>一切都是<span>&nbsp;</span><code>Node</code><span>&nbsp;</span>的设计。其下一切数据都以<code>ONode</code>表示，<code>ONode</code>也即<span>&nbsp;</span><code>One node</code><span>&nbsp;</span>之意，代表任何类型，也可以转换为任何类型。</p>
<ul>
<li>强调文档树的构建和操控能力</li>
<li>高性能<code>Json path</code>查询（比 jayway.jsonpath 快很多倍）。同时兼容<span>&nbsp;</span><code>jayway.jsonpath</code><span>&nbsp;</span>和<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.rfc-editor.org%2Frfc%2Frfc9535.html" target="_blank">IETF JSONPath (RFC 9535) 标准</a><span>&nbsp;</span>(用<span>&nbsp;</span><code>options</code><span>&nbsp;</span>切换)。为下一个十年提供强劲的 JsonPath 体验。</li>
<li>支持<span>&nbsp;</span><code>Json schema</code><span>&nbsp;</span>架构校验</li>
<li>支持<span>&nbsp;</span><code>json5</code><span>&nbsp;</span>部分特性（无键字段，注释，等...）</li>
<li>优先使用 无参构造函数 + 字段 编解码（可减少注入而触发动作的风险）</li>
</ul>
<p>依赖包清单：</p>
<table cellspacing="0">
<tbody>
<tr>
<th>依赖包</th>
<th>描述</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>org.noear:snack4</code></td>
<td>提供<span>&nbsp;</span><code>json dom</code><span>&nbsp;</span>构建和编解码支持</td>
</tr>
<tr>
<td><code>org.noear:snack4-jsonpath</code></td>
<td>提供<span>&nbsp;</span><code>json path</code><span>&nbsp;</span>查询支持</td>
</tr>
<tr>
<td><code>org.noear:snack4-jsonschema</code></td>
<td>提供<span>&nbsp;</span><code>json schema</code><span>&nbsp;</span>校验支持</td>
</tr>
</tbody>
</table>
<p>开源项目仓库地址：</p>
<ul>
<li><a href="https://gitee.com/noear/snack-jsonpath">https://gitee.com/noear/snack-jsonpath</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fnoear%2Fsnack-jsonpath" target="_blank">https://github.com/noear/snack-jsonpath</a></li>
</ul>
<p>文档资料：</p>
<ul>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsolon.noear.org%2Farticle%2Fsnack" target="_blank">https://solon.noear.org/article/snack</a></li>
</ul>
<h3>1、版本更新说明</h3>
<ul>
<li>重构整个项目（除了名字没变，其它都变了）</li>
<li>单测覆盖率 98%，历时小半年</li>
<li>支持<span>&nbsp;</span><code>IETF JSONPath (RFC 9535)</code><span>&nbsp;</span>标准（全球首个支持该标准的 Java 框架）。同时兼容<span>&nbsp;</span><code>jayway.jsonpath</code></li>
<li>添加 json-schema 支持</li>
</ul>
<h3>2、JSONPath 语法参考</h3>
<table cellspacing="0">
<tbody>
<tr>
<th>语法元素</th>
<th>描述</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>$</code></td>
<td>根节点标识符</td>
</tr>
<tr>
<td><code>@</code></td>
<td>当前节点标识符（仅在过滤选择器中有效）</td>
</tr>
<tr>
<td><code>[&lt;selectors&gt;]</code></td>
<td>子段：选择节点的零个或多个子节点</td>
</tr>
<tr>
<td><code>.name</code></td>
<td>简写<span>&nbsp;</span><code>['name']</code></td>
</tr>
<tr>
<td><code>.*</code></td>
<td>简写<span>&nbsp;</span><code>[*]</code></td>
</tr>
<tr>
<td><code>..[&lt;selectors&gt;]</code></td>
<td>后代段：选择节点的零个或多个后代</td>
</tr>
<tr>
<td><code>..name</code></td>
<td>简写<span>&nbsp;</span><code>..['name']</code></td>
</tr>
<tr>
<td><code>..*</code></td>
<td>简写<span>&nbsp;</span><code>..[*]</code></td>
</tr>
<tr>
<td><code>'name'</code></td>
<td>名称选择器：选择对象的命名子对象</td>
</tr>
<tr>
<td><code>*</code></td>
<td>通配符选择器：选择节点的所有子节点</td>
</tr>
<tr>
<td><code>3</code></td>
<td>索引选择器：选择数组的索引子项（从 0 开始）</td>
</tr>
<tr>
<td><code>0💯5</code></td>
<td>数组切片选择器：数组的<span>&nbsp;</span><code>start🔚step</code></td>
</tr>
<tr>
<td><code>?&lt;logical-expr&gt;</code></td>
<td>过滤选择器：使用逻辑表达式选择特定的子项</td>
</tr>
<tr>
<td><code>fun(@.foo)</code></td>
<td>过滤函数：在过滤表达式中调用函数（IETF 标准）</td>
</tr>
<tr>
<td><code>.fun()</code></td>
<td>聚合函数：作为片段使用（jayway 风格）</td>
</tr>
</tbody>
</table>
<p>过滤选择器语法参考：</p>
<table cellspacing="0">
<tbody>
<tr>
<th>语法</th>
<th>描述</th>
<th>优先级</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>(...)</code></td>
<td>分组</td>
<td>5</td>
</tr>
<tr>
<td><code>name(...)</code></td>
<td>函数扩展</td>
<td>5</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑<span>&nbsp;</span><code>非</code></td>
<td>4</td>
</tr>
<tr>
<td><code>==</code>,<code>!=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code></td>
<td>关系比较符</td>
<td>3</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑<span>&nbsp;</span><code>与</code></td>
<td>2</td>
</tr>
<tr>
<td><code>\|\|</code></td>
<td>逻辑<span>&nbsp;</span><code>或</code></td>
<td>1</td>
</tr>
</tbody>
</table>
<p>IETF JSONPath (RFC 9535) 标准定义操作符（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>==</code></td>
<td>左等于右（注意1不等于'1'）</td>
<td><code>$[?(@.a == 1)]</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>左不等于右</td>
<td><code>$[?(@.a != 1)]</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>左比右小</td>
<td><code>$[?(@.a &lt; 1)]</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>左小于或等于右</td>
<td><code>$[?(@.a &lt;= 1)]</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>左大于右</td>
<td><code>$[?(@.a &gt; 1)]</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>左大于等于右</td>
<td><code>$[?(@.a &gt;= 1)]</code></td>
</tr>
</tbody>
</table>
<p>jayway.jsonpath 增量操作符（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>=~</code></td>
<td>左匹配正则表达式</td>
<td><code>[?(@.s =~ /foo.*?/i)]</code></td>
</tr>
<tr>
<td><code>in</code></td>
<td>左存在于右</td>
<td><code>[?(@.s in ['S', 'M'])]</code></td>
</tr>
<tr>
<td><code>nin</code></td>
<td>左不存在于右</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>subsetof</code></td>
<td>左是右的子集</td>
<td><code>[?(@.s subsetof ['S', 'M', 'L'])]</code></td>
</tr>
<tr>
<td><code>anyof</code></td>
<td>左与右有一个交点</td>
<td><code>[?(@.s anyof ['M', 'L'])]</code></td>
</tr>
<tr>
<td><code>noneof</code></td>
<td>左与右没有交集</td>
<td><code>[?(@.s noneof ['M', 'L'])]</code></td>
</tr>
<tr>
<td><code>size</code></td>
<td>左（数组或字符串）的大小应该与右匹配</td>
<td><code>$[?(@.s size @.expected_size)]</code></td>
</tr>
<tr>
<td><code>empty</code></td>
<td>Left（数组或字符串）应该为空</td>
<td><code>$[?(@.s empty false)]</code></td>
</tr>
</tbody>
</table>
<p>IETF JSONPath (RFC 9535) 标准定义函数（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>函数</th>
<th>描述</th>
<th>参数类型</th>
<th>结果类型</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>length(x)</code></td>
<td>字符串、数组或对象的长度</td>
<td>值</td>
<td>数值</td>
</tr>
<tr>
<td><code>count(x)</code></td>
<td>节点列表的大小</td>
<td>节点列表</td>
<td>数值</td>
</tr>
<tr>
<td><code>match(x,y)</code></td>
<td>正则表达式完全匹配</td>
<td>值，值</td>
<td>逻辑值</td>
</tr>
<tr>
<td><code>search(x,y)</code></td>
<td>正则表达式子字符串匹配</td>
<td>值，值</td>
<td>逻辑值</td>
</tr>
<tr>
<td><code>value(x)</code></td>
<td>节点列表中单个节点的值</td>
<td>节点列表</td>
<td>值</td>
</tr>
</tbody>
</table>
<p>jayway.jsonpath 函数（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>函数</th>
<th>描述</th>
<th>输出类型</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>length()</code></td>
<td>字符串、数组或对象的长度</td>
<td>Integer</td>
</tr>
<tr>
<td><code>min()</code></td>
<td>查找当前数值数组中的最小值</td>
<td>Double</td>
</tr>
<tr>
<td><code>max()</code></td>
<td>查找当前数值数组中的最大值</td>
<td>Double</td>
</tr>
<tr>
<td><code>avg()</code></td>
<td>计算当前数值数组中的平均值</td>
<td>Double</td>
</tr>
<tr>
<td><code>stddev()</code></td>
<td>计算当前数值数组中的标准差</td>
<td>Double</td>
</tr>
<tr>
<td><code>sum()</code></td>
<td>计算当前数值数组中的总和</td>
<td>Double</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>计算当前对象的属性键集合</td>
<td><code>Set&lt;E&gt;</code></td>
</tr>
<tr>
<td><code>concat(X)</code></td>
<td>将一个项或集合和当前数组连接成一个新数组</td>
<td>like input</td>
</tr>
<tr>
<td><code>append(X)</code></td>
<td>将一个项或集合 追加到当前路径的输出数组中</td>
<td>like input</td>
</tr>
<tr>
<td><code>first()</code></td>
<td>返回当前数组的第一个元素</td>
<td>依赖于数组元素类型</td>
</tr>
<tr>
<td><code>last()</code></td>
<td>返回当前数组的最后一个元素</td>
<td>依赖于数组元素类型</td>
</tr>
<tr>
<td><code>index(X)</code></td>
<td>返回当前数组中索引为X的元素。X可以是负数（从末尾开始计算）</td>
<td>依赖于数组元素类型</td>
</tr>
</tbody>
</table>
<p>snack-jsonpath 增量操作符（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>startsWith</code></td>
<td>左（字符串）开头匹配右</td>
<td><code>[?(@.s startsWith 'a')]</code></td>
</tr>
<tr>
<td><code>endsWith</code></td>
<td>左（字符串）结尾匹配右</td>
<td><code>[?(@.s endsWith 'b')]</code></td>
</tr>
<tr>
<td><code>contains</code></td>
<td>左（数组或字符串）包含匹配右</td>
<td><code>[?(@.s contains 'c')]</code></td>
</tr>
</tbody>
</table>
<h3>3、JSONPath 语法示例</h3>
<p>JSON 样本数据</p>
<pre><code><span>{</span> <span>"store"</span><span>:</span> <span>{</span>
<span>"book"</span><span>:</span> <span>[</span>
<span>{</span> <span>"category"</span><span>:</span> <span>"reference"</span><span>,</span>
<span>"author"</span><span>:</span> <span>"Nigel Rees"</span><span>,</span>
<span>"title"</span><span>:</span> <span>"Sayings of the Century"</span><span>,</span>
<span>"price"</span><span>:</span> <span>8.95</span>
<span>}</span><span>,</span>
<span>{</span> <span>"category"</span><span>:</span> <span>"fiction"</span><span>,</span>
<span>"author"</span><span>:</span> <span>"Evelyn Waugh"</span><span>,</span>
<span>"title"</span><span>:</span> <span>"Sword of Honour"</span><span>,</span>
<span>"price"</span><span>:</span> <span>12.99</span>
<span>}</span><span>,</span>
<span>{</span> <span>"category"</span><span>:</span> <span>"fiction"</span><span>,</span>
<span>"author"</span><span>:</span> <span>"Herman Melville"</span><span>,</span>
<span>"title"</span><span>:</span> <span>"Moby Dick"</span><span>,</span>
<span>"isbn"</span><span>:</span> <span>"0-553-21311-3"</span><span>,</span>
<span>"price"</span><span>:</span> <span>8.99</span>
<span>}</span><span>,</span>
<span>{</span> <span>"category"</span><span>:</span> <span>"fiction"</span><span>,</span>
<span>"author"</span><span>:</span> <span>"J. R. R. Tolkien"</span><span>,</span>
<span>"title"</span><span>:</span> <span>"The Lord of the Rings"</span><span>,</span>
<span>"isbn"</span><span>:</span> <span>"0-395-19395-8"</span><span>,</span>
<span>"price"</span><span>:</span> <span>22.99</span>
<span>}</span>
<span>]</span><span>,</span>
<span>"bicycle"</span><span>:</span> <span>{</span>
<span>"color"</span><span>:</span> <span>"red"</span><span>,</span>
<span>"price"</span><span>:</span> <span>399</span>
<span>}</span>
<span>}</span>
<span>}</span>
</code></pre>
<p>示例JSONPath表达式及其应用于示例JSON值时的预期结果</p>
<table cellspacing="0">
<tbody>
<tr>
<th>JSONPath</th>
<th>预期结果</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>$.store.book[*].author</code></td>
<td>书店里所有书的作者</td>
</tr>
<tr>
<td><code>$..autho</code></td>
<td>所有作者</td>
</tr>
<tr>
<td><code>$.store.*</code></td>
<td>商店里的所有东西，包括一些书和一辆红色的自行车</td>
</tr>
<tr>
<td><code>$.store..price</code></td>
<td>商店里所有东西的价格</td>
</tr>
<tr>
<td><code>$..book[2]</code></td>
<td>第三本书</td>
</tr>
<tr>
<td><code>$..book[2].author</code></td>
<td>第三本书的作者</td>
</tr>
<tr>
<td><code>$..book[2].publisher</code></td>
<td>空结果：第三本书没有“publisher”成员</td>
</tr>
<tr>
<td><code>$..book[-1]</code></td>
<td>最后一本书</td>
</tr>
<tr>
<td><code>$..book[0,1]</code><br> <code>$..book[:2]</code></td>
<td>前两本书</td>
</tr>
<tr>
<td><code>$..book[?@.isbn]</code></td>
<td>所有有国际标准书号的书</td>
</tr>
<tr>
<td><code>$..book[?@.price&lt;10]</code></td>
<td>所有比10便宜的书</td>
</tr>
<tr>
<td><code>$..*</code></td>
<td>输入值中包含的所有成员值和数组元素</td>
</tr>
</tbody>
</table>
<h3>4、放几个应用示例看看</h3>
<p>支持<span>&nbsp;</span><code>dom</code><span>&nbsp;</span>操控</p>
<pre><code><span>ONode</span> <span>oNode</span> <span>=</span> <span>new</span> <span>ONode</span>();
oNode.set(<span>"id"</span>, <span>1</span>);
oNode.getOrNew(<span>"layout"</span>).then(o -&gt; {
o.addNew().set(<span>"title"</span>, <span>"开始"</span>).set(<span>"type"</span>, <span>"start"</span>);
o.addNew().set(<span>"title"</span>, <span>"结束"</span>).set(<span>"type"</span>, <span>"end"</span>);
});
oNode.get(<span>"id"</span>).getInt();
oNode.get(<span>"layout"</span>).get(<span>0</span>).get(<span>"title"</span>).getString();
oNode.getOrNew(<span>"list"</span>).fillJson(<span>"[1,2,3,4,5,6]"</span>);
</code></pre>
<p>支持<span>&nbsp;</span><code>json path</code><span>&nbsp;</span>查询、构建、删除</p>
<pre><code>ONode.ofBean(store).select(<span>"$..book[?@.tags contains 'war'].first()"</span>).toBean(Book.class); <em>//RFC9535 规范，可以没有括号</em>
ONode.ofBean(store).select(<span>"$..book[?(!(@.category == 'fiction') &amp;&amp; @.price &lt; 40)].first()"</span>).toBean(Book.class);
ONode.ofJson(store).select(<span>"$.store.book.count()"</span>);
ONode.ofBean(store).create(<span>"$.store.book[0].category"</span>).toJson();
ONode.ofBean(store).delete(<span>"$..book[-1]"</span>);
</code></pre>
<p>支持<span>&nbsp;</span><code>json schema</code><span>&nbsp;</span>校验</p>
<pre><code><span>JsonSchema</span> <span>schema</span> <span>=</span> JsonSchema.ofJson(<span>"{type:'object',properties:{userId:{type:'string'}}}"</span>); <em>//加载架构定义</em>
schema.validate(ONode.load(<span>"{userId:'1'}"</span>)); <em>//校验格式</em>
</code></pre>
<p>支持序列化、反序列化</p>
<pre><code><span>User</span> <span>user</span> <span>=</span> <span>new</span> <span>User</span>();
ONode.ofBean(user).toBean(User.class); <em>//可以作为 bean 转换使用</em>
ONode.ofBean(user).toJson();
ONode.ofJson(<span>"{}"</span>).toBean(User.class);
ONode.ofJson(<span>"[{},{}]"</span>).toBean((<span>new</span> <span>ArrayList</span>&lt;User&gt;(){}).getClass());
<em>//快捷方式</em>
<span>String</span> <span>json</span> <span>=</span> ONode.serialize(user);
<span>User</span> <span>user</span> <span>=</span> ONode.deserialize(json, User.class);
</code></pre>
<h3>5、路径树接口</h3>
<pre><code><em>//case1</em>
<span>ONode</span> <span>o</span> <span>=</span> ONode.ofJson(json);
<span>ONode</span> <span>rst</span> <span>=</span> o.select(<span>"$.data.list[*].mobile"</span>); <em>//自动为查询到的节点，生成 path 属性</em>
List&lt;String&gt; rstPaths = rst.pathList(); <em>//获取结果节点的路径列表</em>
<span>for</span>(ONode n1 : rst.getArray()) {
n1.path(); <em>//当前路径</em>
n1.parent(); <em>//父级节点</em>
}
<em>//case2</em>
<span>ONode</span> <span>o</span> <span>=</span> ONode.ofJson(json).usePaths(); <em>//手动为每个子节点，生成 path 属性</em>
<span>ONode</span> <span>rst</span> <span>=</span> o.get(<span>"data"</span>).get(<span>"list"</span>).get(<span>2</span>);
rst.path();
rst.parent();
</code></pre>
<h3>6、高级定制</h3>
<p>Json 编解码定制</p>
<pre><code><span>Options</span> <span>options</span> <span>=</span> Options.of();
<em>//添加编码器</em>
options.addEncoder(Date.class, (ctx, value, target) -&gt; {
target.setValue(DateUtil.format(data, <span>"yyyy-MM-dd"</span>));
});
<em>//添加解码器</em>
options.addDecoder(Date.class, ...);
<em>//添加创建器（接管类实例化）</em>
options.addCreator(...);
<em>//添加特性</em>
options.addFeature(Feature.Write_PrettyFormat);
<em>//移除特性</em>
options.removeFeature(Feature.Write_PrettyFormat);
<em>//设置日期格式附</em>
options.addFeature(Feature.Write_UseDateFormat); <em>//使用日期格式</em>
options.dateFormat(<span>"yyyy-MM"</span>);
<em>//..</em>
<span>String</span> <span>json</span> <span>=</span> ONode.ofBean(orderModel, options).toJson();
</code></pre>
<p>JsonPath 函数与操作符定制</p>
<pre><code><span>import</span> org.noear.snack4.ONode;
<span>import</span> org.noear.snack4.jsonpath.FunctionLib;
<span>public</span> <span>class</span> <span>FunctionDemo</span> {
<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {
<em>//定制 floor 函数</em>
FunctionLib.register(<span>"floor"</span>, (ctx, argNodes) -&gt; {
<span>ONode</span> <span>arg0</span> <span>=</span> argNodes.get(<span>0</span>); <em>//节点列表（选择器的结果）</em>
<span>if</span> (ctx.isDescendant()) {
<span>for</span> (ONode n1 : arg0.getArray()) {
<span>if</span> (n1.isNumber()) {
n1.setValue(Math.floor(n1.getDouble()));
}
}
<span>return</span> arg0;
} <span>else</span> {
<span>ONode</span> <span>n1</span> <span>=</span> arg0.get(<span>0</span>);
<span>if</span> (n1.isNumber()) {
<span>return</span> ctx.newNode(Math.floor(n1.getDouble()));
} <span>else</span> {
<span>return</span> ctx.newNode();
}
}
});
<em>//检验效果（在 IETF 规范里以子项进行过滤，即 1,2） //out: 1.0</em>
System.out.println(ONode.ofJson(<span>"{'a':1,'b':2}"</span>)
.select(<span>"$.a.floor()"</span>)
.toJson());
<em>//参考 //out: 2.0</em>
System.out.println(ONode.ofJson(<span>"{'a':1,'b':2}"</span>)
.select(<span>"$[?floor(@) &gt; 1].first()"</span>)
.toJson());
}
}
</code></pre>
<pre><code><span>import</span> org.noear.snack4.ONode;
<span>import</span> org.noear.snack4.jsonpath.OperatorLib;
<span>public</span> <span>class</span> <span>OperationDemo</span> {
<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {
<em>//定制操作符</em>
OperatorLib.register(<span>"startsWith"</span>, (ctx, node, term) -&gt; {
<span>ONode</span> <span>leftNode</span> <span>=</span> term.getLeftNode(ctx, node);
<span>if</span> (leftNode.isString()) {
<span>ONode</span> <span>rightNode</span> <span>=</span> term.getRightNode(ctx, node);
<span>if</span> (rightNode.isNull()) {
<span>return</span> <span>false</span>;
}
<span>return</span> leftNode.getString().startsWith(rightNode.getString());
}
<span>return</span> <span>false</span>;
});
<em>//检验效果</em>
<span>assert</span> ONode.ofJson(<span>"{'list':['a','b','c']}"</span>)
.select(<span>"$.list[?@ startsWith 'a']"</span>)
.size() == <span>1</span>;
}
}</code></pre>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>基于jdk8。支持：Json Dom 的构建、编码解转换、获取、JsonPath 查询、JsonSchema 验证。</p>
<pre><code><span>&lt;<span>dependency</span>&gt;</span>
<span>&lt;<span>groupId</span>&gt;</span>org.noear<span>&lt;/<span>groupId</span>&gt;</span>
<span>&lt;<span>artifactId</span>&gt;</span>snack4-jsonpath<span>&lt;/<span>artifactId</span>&gt;</span>
<span>&lt;<span>version</span>&gt;</span>4.0.0<span>&lt;/<span>version</span>&gt;</span>
<span>&lt;/<span>dependency</span>&gt;</span>
</code></pre>
<p>Snack-Jsonpath 借鉴了<span>&nbsp;</span><code>Javascript</code><span>&nbsp;</span>所有变量由<span>&nbsp;</span><code>var</code><span>&nbsp;</span>申明，及<span>&nbsp;</span><code>Xml dom</code><span>&nbsp;</span>一切都是<span>&nbsp;</span><code>Node</code><span>&nbsp;</span>的设计。其下一切数据都以<code>ONode</code>表示，<code>ONode</code>也即<span>&nbsp;</span><code>One node</code><span>&nbsp;</span>之意，代表任何类型，也可以转换为任何类型。</p>
<ul>
<li>强调文档树的构建和操控能力</li>
<li>高性能<code>Json path</code>查询（比 jayway.jsonpath 快很多倍）。同时兼容<span>&nbsp;</span><code>jayway.jsonpath</code><span>&nbsp;</span>和<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.rfc-editor.org%2Frfc%2Frfc9535.html" target="_blank">IETF JSONPath (RFC 9535) 标准</a><span>&nbsp;</span>(用<span>&nbsp;</span><code>options</code><span>&nbsp;</span>切换)。为下一个十年提供强劲的 JsonPath 体验。</li>
<li>支持<span>&nbsp;</span><code>Json schema</code><span>&nbsp;</span>架构校验</li>
<li>支持<span>&nbsp;</span><code>json5</code><span>&nbsp;</span>部分特性（无键字段，注释，等...）</li>
<li>优先使用 无参构造函数 + 字段 编解码（可减少注入而触发动作的风险）</li>
</ul>
<p>依赖包清单：</p>
<table cellspacing="0">
<tbody>
<tr>
<th>依赖包</th>
<th>描述</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>org.noear:snack4</code></td>
<td>提供<span>&nbsp;</span><code>json dom</code><span>&nbsp;</span>构建和编解码支持</td>
</tr>
<tr>
<td><code>org.noear:snack4-jsonpath</code></td>
<td>提供<span>&nbsp;</span><code>json path</code><span>&nbsp;</span>查询支持</td>
</tr>
<tr>
<td><code>org.noear:snack4-jsonschema</code></td>
<td>提供<span>&nbsp;</span><code>json schema</code><span>&nbsp;</span>校验支持</td>
</tr>
</tbody>
</table>
<p>开源项目仓库地址：</p>
<ul>
<li><a href="https://gitee.com/noear/snack-jsonpath">https://gitee.com/noear/snack-jsonpath</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fnoear%2Fsnack-jsonpath" target="_blank">https://github.com/noear/snack-jsonpath</a></li>
</ul>
<p>文档资料：</p>
<ul>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsolon.noear.org%2Farticle%2Fsnack" target="_blank">https://solon.noear.org/article/snack</a></li>
</ul>
<h3>1、版本更新说明</h3>
<ul>
<li>重构整个项目（除了名字没变，其它都变了）</li>
<li>单测覆盖率 98%，历时小半年</li>
<li>支持<span>&nbsp;</span><code>IETF JSONPath (RFC 9535)</code><span>&nbsp;</span>标准（全球首个支持该标准的 Java 框架）。同时兼容<span>&nbsp;</span><code>jayway.jsonpath</code></li>
<li>添加 json-schema 支持</li>
</ul>
<h3>2、JSONPath 语法参考</h3>
<table cellspacing="0">
<tbody>
<tr>
<th>语法元素</th>
<th>描述</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>$</code></td>
<td>根节点标识符</td>
</tr>
<tr>
<td><code>@</code></td>
<td>当前节点标识符（仅在过滤选择器中有效）</td>
</tr>
<tr>
<td><code>[&lt;selectors&gt;]</code></td>
<td>子段：选择节点的零个或多个子节点</td>
</tr>
<tr>
<td><code>.name</code></td>
<td>简写<span>&nbsp;</span><code>['name']</code></td>
</tr>
<tr>
<td><code>.*</code></td>
<td>简写<span>&nbsp;</span><code>[*]</code></td>
</tr>
<tr>
<td><code>..[&lt;selectors&gt;]</code></td>
<td>后代段：选择节点的零个或多个后代</td>
</tr>
<tr>
<td><code>..name</code></td>
<td>简写<span>&nbsp;</span><code>..['name']</code></td>
</tr>
<tr>
<td><code>..*</code></td>
<td>简写<span>&nbsp;</span><code>..[*]</code></td>
</tr>
<tr>
<td><code>'name'</code></td>
<td>名称选择器：选择对象的命名子对象</td>
</tr>
<tr>
<td><code>*</code></td>
<td>通配符选择器：选择节点的所有子节点</td>
</tr>
<tr>
<td><code>3</code></td>
<td>索引选择器：选择数组的索引子项（从 0 开始）</td>
</tr>
<tr>
<td><code>0💯5</code></td>
<td>数组切片选择器：数组的<span>&nbsp;</span><code>start🔚step</code></td>
</tr>
<tr>
<td><code>?&lt;logical-expr&gt;</code></td>
<td>过滤选择器：使用逻辑表达式选择特定的子项</td>
</tr>
<tr>
<td><code>fun(@.foo)</code></td>
<td>过滤函数：在过滤表达式中调用函数（IETF 标准）</td>
</tr>
<tr>
<td><code>.fun()</code></td>
<td>聚合函数：作为片段使用（jayway 风格）</td>
</tr>
</tbody>
</table>
<p>过滤选择器语法参考：</p>
<table cellspacing="0">
<tbody>
<tr>
<th>语法</th>
<th>描述</th>
<th>优先级</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>(...)</code></td>
<td>分组</td>
<td>5</td>
</tr>
<tr>
<td><code>name(...)</code></td>
<td>函数扩展</td>
<td>5</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑<span>&nbsp;</span><code>非</code></td>
<td>4</td>
</tr>
<tr>
<td><code>==</code>,<code>!=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code></td>
<td>关系比较符</td>
<td>3</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑<span>&nbsp;</span><code>与</code></td>
<td>2</td>
</tr>
<tr>
<td><code>\|\|</code></td>
<td>逻辑<span>&nbsp;</span><code>或</code></td>
<td>1</td>
</tr>
</tbody>
</table>
<p>IETF JSONPath (RFC 9535) 标准定义操作符（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>==</code></td>
<td>左等于右（注意1不等于'1'）</td>
<td><code>$[?(@.a == 1)]</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>左不等于右</td>
<td><code>$[?(@.a != 1)]</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>左比右小</td>
<td><code>$[?(@.a &lt; 1)]</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>左小于或等于右</td>
<td><code>$[?(@.a &lt;= 1)]</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>左大于右</td>
<td><code>$[?(@.a &gt; 1)]</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>左大于等于右</td>
<td><code>$[?(@.a &gt;= 1)]</code></td>
</tr>
</tbody>
</table>
<p>jayway.jsonpath 增量操作符（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>=~</code></td>
<td>左匹配正则表达式</td>
<td><code>[?(@.s =~ /foo.*?/i)]</code></td>
</tr>
<tr>
<td><code>in</code></td>
<td>左存在于右</td>
<td><code>[?(@.s in ['S', 'M'])]</code></td>
</tr>
<tr>
<td><code>nin</code></td>
<td>左不存在于右</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>subsetof</code></td>
<td>左是右的子集</td>
<td><code>[?(@.s subsetof ['S', 'M', 'L'])]</code></td>
</tr>
<tr>
<td><code>anyof</code></td>
<td>左与右有一个交点</td>
<td><code>[?(@.s anyof ['M', 'L'])]</code></td>
</tr>
<tr>
<td><code>noneof</code></td>
<td>左与右没有交集</td>
<td><code>[?(@.s noneof ['M', 'L'])]</code></td>
</tr>
<tr>
<td><code>size</code></td>
<td>左（数组或字符串）的大小应该与右匹配</td>
<td><code>$[?(@.s size @.expected_size)]</code></td>
</tr>
<tr>
<td><code>empty</code></td>
<td>Left（数组或字符串）应该为空</td>
<td><code>$[?(@.s empty false)]</code></td>
</tr>
</tbody>
</table>
<p>IETF JSONPath (RFC 9535) 标准定义函数（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>函数</th>
<th>描述</th>
<th>参数类型</th>
<th>结果类型</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>length(x)</code></td>
<td>字符串、数组或对象的长度</td>
<td>值</td>
<td>数值</td>
</tr>
<tr>
<td><code>count(x)</code></td>
<td>节点列表的大小</td>
<td>节点列表</td>
<td>数值</td>
</tr>
<tr>
<td><code>match(x,y)</code></td>
<td>正则表达式完全匹配</td>
<td>值，值</td>
<td>逻辑值</td>
</tr>
<tr>
<td><code>search(x,y)</code></td>
<td>正则表达式子字符串匹配</td>
<td>值，值</td>
<td>逻辑值</td>
</tr>
<tr>
<td><code>value(x)</code></td>
<td>节点列表中单个节点的值</td>
<td>节点列表</td>
<td>值</td>
</tr>
</tbody>
</table>
<p>jayway.jsonpath 函数（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>函数</th>
<th>描述</th>
<th>输出类型</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>length()</code></td>
<td>字符串、数组或对象的长度</td>
<td>Integer</td>
</tr>
<tr>
<td><code>min()</code></td>
<td>查找当前数值数组中的最小值</td>
<td>Double</td>
</tr>
<tr>
<td><code>max()</code></td>
<td>查找当前数值数组中的最大值</td>
<td>Double</td>
</tr>
<tr>
<td><code>avg()</code></td>
<td>计算当前数值数组中的平均值</td>
<td>Double</td>
</tr>
<tr>
<td><code>stddev()</code></td>
<td>计算当前数值数组中的标准差</td>
<td>Double</td>
</tr>
<tr>
<td><code>sum()</code></td>
<td>计算当前数值数组中的总和</td>
<td>Double</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>计算当前对象的属性键集合</td>
<td><code>Set&lt;E&gt;</code></td>
</tr>
<tr>
<td><code>concat(X)</code></td>
<td>将一个项或集合和当前数组连接成一个新数组</td>
<td>like input</td>
</tr>
<tr>
<td><code>append(X)</code></td>
<td>将一个项或集合 追加到当前路径的输出数组中</td>
<td>like input</td>
</tr>
<tr>
<td><code>first()</code></td>
<td>返回当前数组的第一个元素</td>
<td>依赖于数组元素类型</td>
</tr>
<tr>
<td><code>last()</code></td>
<td>返回当前数组的最后一个元素</td>
<td>依赖于数组元素类型</td>
</tr>
<tr>
<td><code>index(X)</code></td>
<td>返回当前数组中索引为X的元素。X可以是负数（从末尾开始计算）</td>
<td>依赖于数组元素类型</td>
</tr>
</tbody>
</table>
<p>snack-jsonpath 增量操作符（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>startsWith</code></td>
<td>左（字符串）开头匹配右</td>
<td><code>[?(@.s startsWith 'a')]</code></td>
</tr>
<tr>
<td><code>endsWith</code></td>
<td>左（字符串）结尾匹配右</td>
<td><code>[?(@.s endsWith 'b')]</code></td>
</tr>
<tr>
<td><code>contains</code></td>
<td>左（数组或字符串）包含匹配右</td>
<td><code>[?(@.s contains 'c')]</code></td>
</tr>
</tbody>
</table>
<h3>3、JSONPath 语法示例</h3>
<p>JSON 样本数据</p>
<pre><code><span>{</span> <span>"store"</span><span>:</span> <span>{</span>
<span>"book"</span><span>:</span> <span>[</span>
<span>{</span> <span>"category"</span><span>:</span> <span>"reference"</span><span>,</span>
<span>"author"</span><span>:</span> <span>"Nigel Rees"</span><span>,</span>
<span>"title"</span><span>:</span> <span>"Sayings of the Century"</span><span>,</span>
<span>"price"</span><span>:</span> <span>8.95</span>
<span>}</span><span>,</span>
<span>{</span> <span>"category"</span><span>:</span> <span>"fiction"</span><span>,</span>
<span>"author"</span><span>:</span> <span>"Evelyn Waugh"</span><span>,</span>
<span>"title"</span><span>:</span> <span>"Sword of Honour"</span><span>,</span>
<span>"price"</span><span>:</span> <span>12.99</span>
<span>}</span><span>,</span>
<span>{</span> <span>"category"</span><span>:</span> <span>"fiction"</span><span>,</span>
<span>"author"</span><span>:</span> <span>"Herman Melville"</span><span>,</span>
<span>"title"</span><span>:</span> <span>"Moby Dick"</span><span>,</span>
<span>"isbn"</span><span>:</span> <span>"0-553-21311-3"</span><span>,</span>
<span>"price"</span><span>:</span> <span>8.99</span>
<span>}</span><span>,</span>
<span>{</span> <span>"category"</span><span>:</span> <span>"fiction"</span><span>,</span>
<span>"author"</span><span>:</span> <span>"J. R. R. Tolkien"</span><span>,</span>
<span>"title"</span><span>:</span> <span>"The Lord of the Rings"</span><span>,</span>
<span>"isbn"</span><span>:</span> <span>"0-395-19395-8"</span><span>,</span>
<span>"price"</span><span>:</span> <span>22.99</span>
<span>}</span>
<span>]</span><span>,</span>
<span>"bicycle"</span><span>:</span> <span>{</span>
<span>"color"</span><span>:</span> <span>"red"</span><span>,</span>
<span>"price"</span><span>:</span> <span>399</span>
<span>}</span>
<span>}</span>
<span>}</span>
</code></pre>
<p>示例JSONPath表达式及其应用于示例JSON值时的预期结果</p>
<table cellspacing="0">
<tbody>
<tr>
<th>JSONPath</th>
<th>预期结果</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>$.store.book[*].author</code></td>
<td>书店里所有书的作者</td>
</tr>
<tr>
<td><code>$..autho</code></td>
<td>所有作者</td>
</tr>
<tr>
<td><code>$.store.*</code></td>
<td>商店里的所有东西，包括一些书和一辆红色的自行车</td>
</tr>
<tr>
<td><code>$.store..price</code></td>
<td>商店里所有东西的价格</td>
</tr>
<tr>
<td><code>$..book[2]</code></td>
<td>第三本书</td>
</tr>
<tr>
<td><code>$..book[2].author</code></td>
<td>第三本书的作者</td>
</tr>
<tr>
<td><code>$..book[2].publisher</code></td>
<td>空结果：第三本书没有“publisher”成员</td>
</tr>
<tr>
<td><code>$..book[-1]</code></td>
<td>最后一本书</td>
</tr>
<tr>
<td><code>$..book[0,1]</code><br> <code>$..book[:2]</code></td>
<td>前两本书</td>
</tr>
<tr>
<td><code>$..book[?@.isbn]</code></td>
<td>所有有国际标准书号的书</td>
</tr>
<tr>
<td><code>$..book[?@.price&lt;10]</code></td>
<td>所有比10便宜的书</td>
</tr>
<tr>
<td><code>$..*</code></td>
<td>输入值中包含的所有成员值和数组元素</td>
</tr>
</tbody>
</table>
<h3>4、放几个应用示例看看</h3>
<p>支持<span>&nbsp;</span><code>dom</code><span>&nbsp;</span>操控</p>
<pre><code><span>ONode</span> <span>oNode</span> <span>=</span> <span>new</span> <span>ONode</span>();
oNode.set(<span>"id"</span>, <span>1</span>);
oNode.getOrNew(<span>"layout"</span>).then(o -&gt; {
o.addNew().set(<span>"title"</span>, <span>"开始"</span>).set(<span>"type"</span>, <span>"start"</span>);
o.addNew().set(<span>"title"</span>, <span>"结束"</span>).set(<span>"type"</span>, <span>"end"</span>);
});
oNode.get(<span>"id"</span>).getInt();
oNode.get(<span>"layout"</span>).get(<span>0</span>).get(<span>"title"</span>).getString();
oNode.getOrNew(<span>"list"</span>).fillJson(<span>"[1,2,3,4,5,6]"</span>);
</code></pre>
<p>支持<span>&nbsp;</span><code>json path</code><span>&nbsp;</span>查询、构建、删除</p>
<pre><code>ONode.ofBean(store).select(<span>"$..book[?@.tags contains 'war'].first()"</span>).toBean(Book.class); <em>//RFC9535 规范，可以没有括号</em>
ONode.ofBean(store).select(<span>"$..book[?(!(@.category == 'fiction') &amp;&amp; @.price &lt; 40)].first()"</span>).toBean(Book.class);
ONode.ofJson(store).select(<span>"$.store.book.count()"</span>);
ONode.ofBean(store).create(<span>"$.store.book[0].category"</span>).toJson();
ONode.ofBean(store).delete(<span>"$..book[-1]"</span>);
</code></pre>
<p>支持<span>&nbsp;</span><code>json schema</code><span>&nbsp;</span>校验</p>
<pre><code><span>JsonSchema</span> <span>schema</span> <span>=</span> JsonSchema.ofJson(<span>"{type:'object',properties:{userId:{type:'string'}}}"</span>); <em>//加载架构定义</em>
schema.validate(ONode.load(<span>"{userId:'1'}"</span>)); <em>//校验格式</em>
</code></pre>
<p>支持序列化、反序列化</p>
<pre><code><span>User</span> <span>user</span> <span>=</span> <span>new</span> <span>User</span>();
ONode.ofBean(user).toBean(User.class); <em>//可以作为 bean 转换使用</em>
ONode.ofBean(user).toJson();
ONode.ofJson(<span>"{}"</span>).toBean(User.class);
ONode.ofJson(<span>"[{},{}]"</span>).toBean((<span>new</span> <span>ArrayList</span>&lt;User&gt;(){}).getClass());
<em>//快捷方式</em>
<span>String</span> <span>json</span> <span>=</span> ONode.serialize(user);
<span>User</span> <span>user</span> <span>=</span> ONode.deserialize(json, User.class);
</code></pre>
<h3>5、路径树接口</h3>
<pre><code><em>//case1</em>
<span>ONode</span> <span>o</span> <span>=</span> ONode.ofJson(json);
<span>ONode</span> <span>rst</span> <span>=</span> o.select(<span>"$.data.list[*].mobile"</span>); <em>//自动为查询到的节点，生成 path 属性</em>
List&lt;String&gt; rstPaths = rst.pathList(); <em>//获取结果节点的路径列表</em>
<span>for</span>(ONode n1 : rst.getArray()) {
n1.path(); <em>//当前路径</em>
n1.parent(); <em>//父级节点</em>
}
<em>//case2</em>
<span>ONode</span> <span>o</span> <span>=</span> ONode.ofJson(json).usePaths(); <em>//手动为每个子节点，生成 path 属性</em>
<span>ONode</span> <span>rst</span> <span>=</span> o.get(<span>"data"</span>).get(<span>"list"</span>).get(<span>2</span>);
rst.path();
rst.parent();
</code></pre>
<h3>6、高级定制</h3>
<p>Json 编解码定制</p>
<pre><code><span>Options</span> <span>options</span> <span>=</span> Options.of();
<em>//添加编码器</em>
options.addEncoder(Date.class, (ctx, value, target) -&gt; {
target.setValue(DateUtil.format(data, <span>"yyyy-MM-dd"</span>));
});
<em>//添加解码器</em>
options.addDecoder(Date.class, ...);
<em>//添加创建器（接管类实例化）</em>
options.addCreator(...);
<em>//添加特性</em>
options.addFeature(Feature.Write_PrettyFormat);
<em>//移除特性</em>
options.removeFeature(Feature.Write_PrettyFormat);
<em>//设置日期格式附</em>
options.addFeature(Feature.Write_UseDateFormat); <em>//使用日期格式</em>
options.dateFormat(<span>"yyyy-MM"</span>);
<em>//..</em>
<span>String</span> <span>json</span> <span>=</span> ONode.ofBean(orderModel, options).toJson();
</code></pre>
<p>JsonPath 函数与操作符定制</p>
<pre><code><span>import</span> org.noear.snack4.ONode;
<span>import</span> org.noear.snack4.jsonpath.FunctionLib;
<span>public</span> <span>class</span> <span>FunctionDemo</span> {
<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {
<em>//定制 floor 函数</em>
FunctionLib.register(<span>"floor"</span>, (ctx, argNodes) -&gt; {
<span>ONode</span> <span>arg0</span> <span>=</span> argNodes.get(<span>0</span>); <em>//节点列表（选择器的结果）</em>
<span>if</span> (ctx.isDescendant()) {
<span>for</span> (ONode n1 : arg0.getArray()) {
<span>if</span> (n1.isNumber()) {
n1.setValue(Math.floor(n1.getDouble()));
}
}
<span>return</span> arg0;
} <span>else</span> {
<span>ONode</span> <span>n1</span> <span>=</span> arg0.get(<span>0</span>);
<span>if</span> (n1.isNumber()) {
<span>return</span> ctx.newNode(Math.floor(n1.getDouble()));
} <span>else</span> {
<span>return</span> ctx.newNode();
}
}
});
<em>//检验效果（在 IETF 规范里以子项进行过滤，即 1,2） //out: 1.0</em>
System.out.println(ONode.ofJson(<span>"{'a':1,'b':2}"</span>)
.select(<span>"$.a.floor()"</span>)
.toJson());
<em>//参考 //out: 2.0</em>
System.out.println(ONode.ofJson(<span>"{'a':1,'b':2}"</span>)
.select(<span>"$[?floor(@) &gt; 1].first()"</span>)
.toJson());
}
}
</code></pre>
<pre><code><span>import</span> org.noear.snack4.ONode;
<span>import</span> org.noear.snack4.jsonpath.OperatorLib;
<span>public</span> <span>class</span> <span>OperationDemo</span> {
<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {
<em>//定制操作符</em>
OperatorLib.register(<span>"startsWith"</span>, (ctx, node, term) -&gt; {
<span>ONode</span> <span>leftNode</span> <span>=</span> term.getLeftNode(ctx, node);
<span>if</span> (leftNode.isString()) {
<span>ONode</span> <span>rightNode</span> <span>=</span> term.getRightNode(ctx, node);
<span>if</span> (rightNode.isNull()) {
<span>return</span> <span>false</span>;
}
<span>return</span> leftNode.getString().startsWith(rightNode.getString());
}
<span>return</span> <span>false</span>;
});
<em>//检验效果</em>
<span>assert</span> ONode.ofJson(<span>"{'list':['a','b','c']}"</span>)
.select(<span>"$.list[?@ startsWith 'a']"</span>)
.size() == <span>1</span>;
}
}</code></pre>]]>
    </description>
    <content:encoded><![CDATA[<p>基于jdk8。支持：Json Dom 的构建、编码解转换、获取、JsonPath 查询、JsonSchema 验证。</p>
<pre><code><span>&lt;<span>dependency</span>&gt;</span>
<span>&lt;<span>groupId</span>&gt;</span>org.noear<span>&lt;/<span>groupId</span>&gt;</span>
<span>&lt;<span>artifactId</span>&gt;</span>snack4-jsonpath<span>&lt;/<span>artifactId</span>&gt;</span>
<span>&lt;<span>version</span>&gt;</span>4.0.0<span>&lt;/<span>version</span>&gt;</span>
<span>&lt;/<span>dependency</span>&gt;</span>
</code></pre>
<p>Snack-Jsonpath 借鉴了<span>&nbsp;</span><code>Javascript</code><span>&nbsp;</span>所有变量由<span>&nbsp;</span><code>var</code><span>&nbsp;</span>申明，及<span>&nbsp;</span><code>Xml dom</code><span>&nbsp;</span>一切都是<span>&nbsp;</span><code>Node</code><span>&nbsp;</span>的设计。其下一切数据都以<code>ONode</code>表示，<code>ONode</code>也即<span>&nbsp;</span><code>One node</code><span>&nbsp;</span>之意，代表任何类型，也可以转换为任何类型。</p>
<ul>
<li>强调文档树的构建和操控能力</li>
<li>高性能<code>Json path</code>查询（比 jayway.jsonpath 快很多倍）。同时兼容<span>&nbsp;</span><code>jayway.jsonpath</code><span>&nbsp;</span>和<span>&nbsp;</span><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.rfc-editor.org%2Frfc%2Frfc9535.html" target="_blank">IETF JSONPath (RFC 9535) 标准</a><span>&nbsp;</span>(用<span>&nbsp;</span><code>options</code><span>&nbsp;</span>切换)。为下一个十年提供强劲的 JsonPath 体验。</li>
<li>支持<span>&nbsp;</span><code>Json schema</code><span>&nbsp;</span>架构校验</li>
<li>支持<span>&nbsp;</span><code>json5</code><span>&nbsp;</span>部分特性（无键字段，注释，等...）</li>
<li>优先使用 无参构造函数 + 字段 编解码（可减少注入而触发动作的风险）</li>
</ul>
<p>依赖包清单：</p>
<table cellspacing="0">
<tbody>
<tr>
<th>依赖包</th>
<th>描述</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>org.noear:snack4</code></td>
<td>提供<span>&nbsp;</span><code>json dom</code><span>&nbsp;</span>构建和编解码支持</td>
</tr>
<tr>
<td><code>org.noear:snack4-jsonpath</code></td>
<td>提供<span>&nbsp;</span><code>json path</code><span>&nbsp;</span>查询支持</td>
</tr>
<tr>
<td><code>org.noear:snack4-jsonschema</code></td>
<td>提供<span>&nbsp;</span><code>json schema</code><span>&nbsp;</span>校验支持</td>
</tr>
</tbody>
</table>
<p>开源项目仓库地址：</p>
<ul>
<li><a href="https://gitee.com/noear/snack-jsonpath">https://gitee.com/noear/snack-jsonpath</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fnoear%2Fsnack-jsonpath" target="_blank">https://github.com/noear/snack-jsonpath</a></li>
</ul>
<p>文档资料：</p>
<ul>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fsolon.noear.org%2Farticle%2Fsnack" target="_blank">https://solon.noear.org/article/snack</a></li>
</ul>
<h3>1、版本更新说明</h3>
<ul>
<li>重构整个项目（除了名字没变，其它都变了）</li>
<li>单测覆盖率 98%，历时小半年</li>
<li>支持<span>&nbsp;</span><code>IETF JSONPath (RFC 9535)</code><span>&nbsp;</span>标准（全球首个支持该标准的 Java 框架）。同时兼容<span>&nbsp;</span><code>jayway.jsonpath</code></li>
<li>添加 json-schema 支持</li>
</ul>
<h3>2、JSONPath 语法参考</h3>
<table cellspacing="0">
<tbody>
<tr>
<th>语法元素</th>
<th>描述</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>$</code></td>
<td>根节点标识符</td>
</tr>
<tr>
<td><code>@</code></td>
<td>当前节点标识符（仅在过滤选择器中有效）</td>
</tr>
<tr>
<td><code>[&lt;selectors&gt;]</code></td>
<td>子段：选择节点的零个或多个子节点</td>
</tr>
<tr>
<td><code>.name</code></td>
<td>简写<span>&nbsp;</span><code>['name']</code></td>
</tr>
<tr>
<td><code>.*</code></td>
<td>简写<span>&nbsp;</span><code>[*]</code></td>
</tr>
<tr>
<td><code>..[&lt;selectors&gt;]</code></td>
<td>后代段：选择节点的零个或多个后代</td>
</tr>
<tr>
<td><code>..name</code></td>
<td>简写<span>&nbsp;</span><code>..['name']</code></td>
</tr>
<tr>
<td><code>..*</code></td>
<td>简写<span>&nbsp;</span><code>..[*]</code></td>
</tr>
<tr>
<td><code>'name'</code></td>
<td>名称选择器：选择对象的命名子对象</td>
</tr>
<tr>
<td><code>*</code></td>
<td>通配符选择器：选择节点的所有子节点</td>
</tr>
<tr>
<td><code>3</code></td>
<td>索引选择器：选择数组的索引子项（从 0 开始）</td>
</tr>
<tr>
<td><code>0💯5</code></td>
<td>数组切片选择器：数组的<span>&nbsp;</span><code>start🔚step</code></td>
</tr>
<tr>
<td><code>?&lt;logical-expr&gt;</code></td>
<td>过滤选择器：使用逻辑表达式选择特定的子项</td>
</tr>
<tr>
<td><code>fun(@.foo)</code></td>
<td>过滤函数：在过滤表达式中调用函数（IETF 标准）</td>
</tr>
<tr>
<td><code>.fun()</code></td>
<td>聚合函数：作为片段使用（jayway 风格）</td>
</tr>
</tbody>
</table>
<p>过滤选择器语法参考：</p>
<table cellspacing="0">
<tbody>
<tr>
<th>语法</th>
<th>描述</th>
<th>优先级</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>(...)</code></td>
<td>分组</td>
<td>5</td>
</tr>
<tr>
<td><code>name(...)</code></td>
<td>函数扩展</td>
<td>5</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑<span>&nbsp;</span><code>非</code></td>
<td>4</td>
</tr>
<tr>
<td><code>==</code>,<code>!=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code></td>
<td>关系比较符</td>
<td>3</td>
</tr>
<tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑<span>&nbsp;</span><code>与</code></td>
<td>2</td>
</tr>
<tr>
<td><code>\|\|</code></td>
<td>逻辑<span>&nbsp;</span><code>或</code></td>
<td>1</td>
</tr>
</tbody>
</table>
<p>IETF JSONPath (RFC 9535) 标准定义操作符（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>==</code></td>
<td>左等于右（注意1不等于'1'）</td>
<td><code>$[?(@.a == 1)]</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>左不等于右</td>
<td><code>$[?(@.a != 1)]</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>左比右小</td>
<td><code>$[?(@.a &lt; 1)]</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>左小于或等于右</td>
<td><code>$[?(@.a &lt;= 1)]</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>左大于右</td>
<td><code>$[?(@.a &gt; 1)]</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>左大于等于右</td>
<td><code>$[?(@.a &gt;= 1)]</code></td>
</tr>
</tbody>
</table>
<p>jayway.jsonpath 增量操作符（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>=~</code></td>
<td>左匹配正则表达式</td>
<td><code>[?(@.s =~ /foo.*?/i)]</code></td>
</tr>
<tr>
<td><code>in</code></td>
<td>左存在于右</td>
<td><code>[?(@.s in ['S', 'M'])]</code></td>
</tr>
<tr>
<td><code>nin</code></td>
<td>左不存在于右</td>
<td>&nbsp;</td>
</tr>
<tr>
<td><code>subsetof</code></td>
<td>左是右的子集</td>
<td><code>[?(@.s subsetof ['S', 'M', 'L'])]</code></td>
</tr>
<tr>
<td><code>anyof</code></td>
<td>左与右有一个交点</td>
<td><code>[?(@.s anyof ['M', 'L'])]</code></td>
</tr>
<tr>
<td><code>noneof</code></td>
<td>左与右没有交集</td>
<td><code>[?(@.s noneof ['M', 'L'])]</code></td>
</tr>
<tr>
<td><code>size</code></td>
<td>左（数组或字符串）的大小应该与右匹配</td>
<td><code>$[?(@.s size @.expected_size)]</code></td>
</tr>
<tr>
<td><code>empty</code></td>
<td>Left（数组或字符串）应该为空</td>
<td><code>$[?(@.s empty false)]</code></td>
</tr>
</tbody>
</table>
<p>IETF JSONPath (RFC 9535) 标准定义函数（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>函数</th>
<th>描述</th>
<th>参数类型</th>
<th>结果类型</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>length(x)</code></td>
<td>字符串、数组或对象的长度</td>
<td>值</td>
<td>数值</td>
</tr>
<tr>
<td><code>count(x)</code></td>
<td>节点列表的大小</td>
<td>节点列表</td>
<td>数值</td>
</tr>
<tr>
<td><code>match(x,y)</code></td>
<td>正则表达式完全匹配</td>
<td>值，值</td>
<td>逻辑值</td>
</tr>
<tr>
<td><code>search(x,y)</code></td>
<td>正则表达式子字符串匹配</td>
<td>值，值</td>
<td>逻辑值</td>
</tr>
<tr>
<td><code>value(x)</code></td>
<td>节点列表中单个节点的值</td>
<td>节点列表</td>
<td>值</td>
</tr>
</tbody>
</table>
<p>jayway.jsonpath 函数（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>函数</th>
<th>描述</th>
<th>输出类型</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>length()</code></td>
<td>字符串、数组或对象的长度</td>
<td>Integer</td>
</tr>
<tr>
<td><code>min()</code></td>
<td>查找当前数值数组中的最小值</td>
<td>Double</td>
</tr>
<tr>
<td><code>max()</code></td>
<td>查找当前数值数组中的最大值</td>
<td>Double</td>
</tr>
<tr>
<td><code>avg()</code></td>
<td>计算当前数值数组中的平均值</td>
<td>Double</td>
</tr>
<tr>
<td><code>stddev()</code></td>
<td>计算当前数值数组中的标准差</td>
<td>Double</td>
</tr>
<tr>
<td><code>sum()</code></td>
<td>计算当前数值数组中的总和</td>
<td>Double</td>
</tr>
<tr>
<td><code>keys()</code></td>
<td>计算当前对象的属性键集合</td>
<td><code>Set&lt;E&gt;</code></td>
</tr>
<tr>
<td><code>concat(X)</code></td>
<td>将一个项或集合和当前数组连接成一个新数组</td>
<td>like input</td>
</tr>
<tr>
<td><code>append(X)</code></td>
<td>将一个项或集合 追加到当前路径的输出数组中</td>
<td>like input</td>
</tr>
<tr>
<td><code>first()</code></td>
<td>返回当前数组的第一个元素</td>
<td>依赖于数组元素类型</td>
</tr>
<tr>
<td><code>last()</code></td>
<td>返回当前数组的最后一个元素</td>
<td>依赖于数组元素类型</td>
</tr>
<tr>
<td><code>index(X)</code></td>
<td>返回当前数组中索引为X的元素。X可以是负数（从末尾开始计算）</td>
<td>依赖于数组元素类型</td>
</tr>
</tbody>
</table>
<p>snack-jsonpath 增量操作符（支持）</p>
<table cellspacing="0">
<tbody>
<tr>
<th>操作符</th>
<th>描述</th>
<th>示例</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>startsWith</code></td>
<td>左（字符串）开头匹配右</td>
<td><code>[?(@.s startsWith 'a')]</code></td>
</tr>
<tr>
<td><code>endsWith</code></td>
<td>左（字符串）结尾匹配右</td>
<td><code>[?(@.s endsWith 'b')]</code></td>
</tr>
<tr>
<td><code>contains</code></td>
<td>左（数组或字符串）包含匹配右</td>
<td><code>[?(@.s contains 'c')]</code></td>
</tr>
</tbody>
</table>
<h3>3、JSONPath 语法示例</h3>
<p>JSON 样本数据</p>
<pre><code><span>{</span> <span>"store"</span><span>:</span> <span>{</span>
<span>"book"</span><span>:</span> <span>[</span>
<span>{</span> <span>"category"</span><span>:</span> <span>"reference"</span><span>,</span>
<span>"author"</span><span>:</span> <span>"Nigel Rees"</span><span>,</span>
<span>"title"</span><span>:</span> <span>"Sayings of the Century"</span><span>,</span>
<span>"price"</span><span>:</span> <span>8.95</span>
<span>}</span><span>,</span>
<span>{</span> <span>"category"</span><span>:</span> <span>"fiction"</span><span>,</span>
<span>"author"</span><span>:</span> <span>"Evelyn Waugh"</span><span>,</span>
<span>"title"</span><span>:</span> <span>"Sword of Honour"</span><span>,</span>
<span>"price"</span><span>:</span> <span>12.99</span>
<span>}</span><span>,</span>
<span>{</span> <span>"category"</span><span>:</span> <span>"fiction"</span><span>,</span>
<span>"author"</span><span>:</span> <span>"Herman Melville"</span><span>,</span>
<span>"title"</span><span>:</span> <span>"Moby Dick"</span><span>,</span>
<span>"isbn"</span><span>:</span> <span>"0-553-21311-3"</span><span>,</span>
<span>"price"</span><span>:</span> <span>8.99</span>
<span>}</span><span>,</span>
<span>{</span> <span>"category"</span><span>:</span> <span>"fiction"</span><span>,</span>
<span>"author"</span><span>:</span> <span>"J. R. R. Tolkien"</span><span>,</span>
<span>"title"</span><span>:</span> <span>"The Lord of the Rings"</span><span>,</span>
<span>"isbn"</span><span>:</span> <span>"0-395-19395-8"</span><span>,</span>
<span>"price"</span><span>:</span> <span>22.99</span>
<span>}</span>
<span>]</span><span>,</span>
<span>"bicycle"</span><span>:</span> <span>{</span>
<span>"color"</span><span>:</span> <span>"red"</span><span>,</span>
<span>"price"</span><span>:</span> <span>399</span>
<span>}</span>
<span>}</span>
<span>}</span>
</code></pre>
<p>示例JSONPath表达式及其应用于示例JSON值时的预期结果</p>
<table cellspacing="0">
<tbody>
<tr>
<th>JSONPath</th>
<th>预期结果</th>
</tr>
</tbody>
<tbody>
<tr>
<td><code>$.store.book[*].author</code></td>
<td>书店里所有书的作者</td>
</tr>
<tr>
<td><code>$..autho</code></td>
<td>所有作者</td>
</tr>
<tr>
<td><code>$.store.*</code></td>
<td>商店里的所有东西，包括一些书和一辆红色的自行车</td>
</tr>
<tr>
<td><code>$.store..price</code></td>
<td>商店里所有东西的价格</td>
</tr>
<tr>
<td><code>$..book[2]</code></td>
<td>第三本书</td>
</tr>
<tr>
<td><code>$..book[2].author</code></td>
<td>第三本书的作者</td>
</tr>
<tr>
<td><code>$..book[2].publisher</code></td>
<td>空结果：第三本书没有“publisher”成员</td>
</tr>
<tr>
<td><code>$..book[-1]</code></td>
<td>最后一本书</td>
</tr>
<tr>
<td><code>$..book[0,1]</code><br> <code>$..book[:2]</code></td>
<td>前两本书</td>
</tr>
<tr>
<td><code>$..book[?@.isbn]</code></td>
<td>所有有国际标准书号的书</td>
</tr>
<tr>
<td><code>$..book[?@.price&lt;10]</code></td>
<td>所有比10便宜的书</td>
</tr>
<tr>
<td><code>$..*</code></td>
<td>输入值中包含的所有成员值和数组元素</td>
</tr>
</tbody>
</table>
<h3>4、放几个应用示例看看</h3>
<p>支持<span>&nbsp;</span><code>dom</code><span>&nbsp;</span>操控</p>
<pre><code><span>ONode</span> <span>oNode</span> <span>=</span> <span>new</span> <span>ONode</span>();
oNode.set(<span>"id"</span>, <span>1</span>);
oNode.getOrNew(<span>"layout"</span>).then(o -&gt; {
o.addNew().set(<span>"title"</span>, <span>"开始"</span>).set(<span>"type"</span>, <span>"start"</span>);
o.addNew().set(<span>"title"</span>, <span>"结束"</span>).set(<span>"type"</span>, <span>"end"</span>);
});
oNode.get(<span>"id"</span>).getInt();
oNode.get(<span>"layout"</span>).get(<span>0</span>).get(<span>"title"</span>).getString();
oNode.getOrNew(<span>"list"</span>).fillJson(<span>"[1,2,3,4,5,6]"</span>);
</code></pre>
<p>支持<span>&nbsp;</span><code>json path</code><span>&nbsp;</span>查询、构建、删除</p>
<pre><code>ONode.ofBean(store).select(<span>"$..book[?@.tags contains 'war'].first()"</span>).toBean(Book.class); <em>//RFC9535 规范，可以没有括号</em>
ONode.ofBean(store).select(<span>"$..book[?(!(@.category == 'fiction') &amp;&amp; @.price &lt; 40)].first()"</span>).toBean(Book.class);
ONode.ofJson(store).select(<span>"$.store.book.count()"</span>);
ONode.ofBean(store).create(<span>"$.store.book[0].category"</span>).toJson();
ONode.ofBean(store).delete(<span>"$..book[-1]"</span>);
</code></pre>
<p>支持<span>&nbsp;</span><code>json schema</code><span>&nbsp;</span>校验</p>
<pre><code><span>JsonSchema</span> <span>schema</span> <span>=</span> JsonSchema.ofJson(<span>"{type:'object',properties:{userId:{type:'string'}}}"</span>); <em>//加载架构定义</em>
schema.validate(ONode.load(<span>"{userId:'1'}"</span>)); <em>//校验格式</em>
</code></pre>
<p>支持序列化、反序列化</p>
<pre><code><span>User</span> <span>user</span> <span>=</span> <span>new</span> <span>User</span>();
ONode.ofBean(user).toBean(User.class); <em>//可以作为 bean 转换使用</em>
ONode.ofBean(user).toJson();
ONode.ofJson(<span>"{}"</span>).toBean(User.class);
ONode.ofJson(<span>"[{},{}]"</span>).toBean((<span>new</span> <span>ArrayList</span>&lt;User&gt;(){}).getClass());
<em>//快捷方式</em>
<span>String</span> <span>json</span> <span>=</span> ONode.serialize(user);
<span>User</span> <span>user</span> <span>=</span> ONode.deserialize(json, User.class);
</code></pre>
<h3>5、路径树接口</h3>
<pre><code><em>//case1</em>
<span>ONode</span> <span>o</span> <span>=</span> ONode.ofJson(json);
<span>ONode</span> <span>rst</span> <span>=</span> o.select(<span>"$.data.list[*].mobile"</span>); <em>//自动为查询到的节点，生成 path 属性</em>
List&lt;String&gt; rstPaths = rst.pathList(); <em>//获取结果节点的路径列表</em>
<span>for</span>(ONode n1 : rst.getArray()) {
n1.path(); <em>//当前路径</em>
n1.parent(); <em>//父级节点</em>
}
<em>//case2</em>
<span>ONode</span> <span>o</span> <span>=</span> ONode.ofJson(json).usePaths(); <em>//手动为每个子节点，生成 path 属性</em>
<span>ONode</span> <span>rst</span> <span>=</span> o.get(<span>"data"</span>).get(<span>"list"</span>).get(<span>2</span>);
rst.path();
rst.parent();
</code></pre>
<h3>6、高级定制</h3>
<p>Json 编解码定制</p>
<pre><code><span>Options</span> <span>options</span> <span>=</span> Options.of();
<em>//添加编码器</em>
options.addEncoder(Date.class, (ctx, value, target) -&gt; {
target.setValue(DateUtil.format(data, <span>"yyyy-MM-dd"</span>));
});
<em>//添加解码器</em>
options.addDecoder(Date.class, ...);
<em>//添加创建器（接管类实例化）</em>
options.addCreator(...);
<em>//添加特性</em>
options.addFeature(Feature.Write_PrettyFormat);
<em>//移除特性</em>
options.removeFeature(Feature.Write_PrettyFormat);
<em>//设置日期格式附</em>
options.addFeature(Feature.Write_UseDateFormat); <em>//使用日期格式</em>
options.dateFormat(<span>"yyyy-MM"</span>);
<em>//..</em>
<span>String</span> <span>json</span> <span>=</span> ONode.ofBean(orderModel, options).toJson();
</code></pre>
<p>JsonPath 函数与操作符定制</p>
<pre><code><span>import</span> org.noear.snack4.ONode;
<span>import</span> org.noear.snack4.jsonpath.FunctionLib;
<span>public</span> <span>class</span> <span>FunctionDemo</span> {
<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {
<em>//定制 floor 函数</em>
FunctionLib.register(<span>"floor"</span>, (ctx, argNodes) -&gt; {
<span>ONode</span> <span>arg0</span> <span>=</span> argNodes.get(<span>0</span>); <em>//节点列表（选择器的结果）</em>
<span>if</span> (ctx.isDescendant()) {
<span>for</span> (ONode n1 : arg0.getArray()) {
<span>if</span> (n1.isNumber()) {
n1.setValue(Math.floor(n1.getDouble()));
}
}
<span>return</span> arg0;
} <span>else</span> {
<span>ONode</span> <span>n1</span> <span>=</span> arg0.get(<span>0</span>);
<span>if</span> (n1.isNumber()) {
<span>return</span> ctx.newNode(Math.floor(n1.getDouble()));
} <span>else</span> {
<span>return</span> ctx.newNode();
}
}
});
<em>//检验效果（在 IETF 规范里以子项进行过滤，即 1,2） //out: 1.0</em>
System.out.println(ONode.ofJson(<span>"{'a':1,'b':2}"</span>)
.select(<span>"$.a.floor()"</span>)
.toJson());
<em>//参考 //out: 2.0</em>
System.out.println(ONode.ofJson(<span>"{'a':1,'b':2}"</span>)
.select(<span>"$[?floor(@) &gt; 1].first()"</span>)
.toJson());
}
}
</code></pre>
<pre><code><span>import</span> org.noear.snack4.ONode;
<span>import</span> org.noear.snack4.jsonpath.OperatorLib;
<span>public</span> <span>class</span> <span>OperationDemo</span> {
<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(String[] args)</span> {
<em>//定制操作符</em>
OperatorLib.register(<span>"startsWith"</span>, (ctx, node, term) -&gt; {
<span>ONode</span> <span>leftNode</span> <span>=</span> term.getLeftNode(ctx, node);
<span>if</span> (leftNode.isString()) {
<span>ONode</span> <span>rightNode</span> <span>=</span> term.getRightNode(ctx, node);
<span>if</span> (rightNode.isNull()) {
<span>return</span> <span>false</span>;
}
<span>return</span> leftNode.getString().startsWith(rightNode.getString());
}
<span>return</span> <span>false</span>;
});
<em>//检验效果</em>
<span>assert</span> ONode.ofJson(<span>"{'list':['a','b','c']}"</span>)
.select(<span>"$.list[?@ startsWith 'a']"</span>)
.size() == <span>1</span>;
}
}</code></pre>]]></content:encoded>
    
    <pubDate>Fri, 17 Oct 2025 11:04:34 +0800</pubDate>
  </item><item>
    <title><![CDATA[美国升级“关键软件”出口管制，开源生态面临地缘政治冲击]]></title>
    <link>https://www.oschina.net/news/377922</link>
    <itunes:title><![CDATA[美国升级“关键软件”出口管制，开源生态面临地缘政治冲击]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>10月11日，美国政府宣布自11月1日起对中国商品加征100%关税，并首次将“所有关键软件”纳入出口管制范围，涵盖操作系统、数据库、工业控制系统、网络防护、身份认证等7大类技术领域。此次管制不仅针对商业软件，更将开源软件纳入监管框架，引发全球开发者社区高度关注。</p>
<h3><strong>开源软件为何被波及？</strong></h3>
<p>根据美国出口管制条例（EAR），若开源软件具备“关键软件”属性（如涉及加密、网络控制或供应链安全），即使代码公开可获取，仍需遵守出口许可要求。例如：</p>
<ul>
<li><strong>Apache基金会</strong>明确声明，其软件通过美国服务器分发，受EAR管辖；</li>
<li><strong>Linux内核</strong>虽由全球开发者协作，但因Linux基金会注册于美国且分发服务器位于境内，同样面临管制风险；</li>
<li><strong>Android系统</strong>（Apache 2.0许可证）虽名义上开源，但美国政府可依据EAR限制其对中国企业的使用。</li>
</ul>
<p>专家指出，美国此举旨在通过技术供应链切断中国获取关键软件能力的路径，开源社区的“无国界”特性被地缘政治重新定义。</p>
<h3><strong>中国信创与工业软件迎机遇</strong></h3>
<p>管制升级倒逼中国加速软件国产化进程。政策层面，国家设定2027年为全面替代完成节点，党政信创专项资金已到位，行业信创从金融、电信扩展至能源、交通等领域。市场层面：</p>
<ul>
<li><strong>基础软件</strong>：统信UOS、麒麟OS等国产操作系统加速适配，用友BIP等企业服务软件实现全栈信创化；</li>
<li><strong>工业软件</strong>：EDA（华大九天）、CAD（中望软件）、PLC（东土科技）等领域国产化率显著提升，部分核心系统已进入规模化推广阶段；</li>
<li><strong>生态建设</strong>：用友BIP联合3900+ISV伙伴、1100+专业服务商构建信创生态链，覆盖20+行业大类。</li>
</ul>
<h3><strong>企业应对策略与挑战</strong></h3>
<ol>
<li><strong>合规审查</strong>：企业需排查开源组件来源，避免使用受管制技术（如加密模块）；</li>
<li><strong>多元化布局</strong>：引入非美开源项目（如Rust语言、欧洲开发的数据库），降低单一技术依赖；</li>
<li><strong>法律支持</strong>：借助专业机构评估出口管制分类编号（ECCNs），规避违规风险。</li>
</ol>
<p>然而，挑战依然存在。国产数据库在金融核心系统替代中面临性能、生态兼容性难题，Oracle等海外产品的深厚积累形成替代壁垒。此外，多数国产软件基于开源技术二次开发，自主可控能力需进一步验证。</p>
<h3><strong>全球开源生态的反思</strong></h3>
<p>此次事件暴露了开源软件的地缘政治脆弱性。Apache、Linux等项目的美国背景使其成为管制工具，开发者需重新评估技术选型的风险。中国工程院院士倪光南呼吁：“必须建立自主可控的基础软件生态，避免将国家数字安全寄托于他国法律框架。”</p>
<p>当前，中美科技竞争已从硬件延伸至软件领域，开源社区的“自由共享”理念正遭遇前所未有的挑战。中国信创产业能否在压力下实现技术突围，将成为全球软件格局重塑的关键变量。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>10月11日，美国政府宣布自11月1日起对中国商品加征100%关税，并首次将“所有关键软件”纳入出口管制范围，涵盖操作系统、数据库、工业控制系统、网络防护、身份认证等7大类技术领域。此次管制不仅针对商业软件，更将开源软件纳入监管框架，引发全球开发者社区高度关注。</p>
<h3><strong>开源软件为何被波及？</strong></h3>
<p>根据美国出口管制条例（EAR），若开源软件具备“关键软件”属性（如涉及加密、网络控制或供应链安全），即使代码公开可获取，仍需遵守出口许可要求。例如：</p>
<ul>
<li><strong>Apache基金会</strong>明确声明，其软件通过美国服务器分发，受EAR管辖；</li>
<li><strong>Linux内核</strong>虽由全球开发者协作，但因Linux基金会注册于美国且分发服务器位于境内，同样面临管制风险；</li>
<li><strong>Android系统</strong>（Apache 2.0许可证）虽名义上开源，但美国政府可依据EAR限制其对中国企业的使用。</li>
</ul>
<p>专家指出，美国此举旨在通过技术供应链切断中国获取关键软件能力的路径，开源社区的“无国界”特性被地缘政治重新定义。</p>
<h3><strong>中国信创与工业软件迎机遇</strong></h3>
<p>管制升级倒逼中国加速软件国产化进程。政策层面，国家设定2027年为全面替代完成节点，党政信创专项资金已到位，行业信创从金融、电信扩展至能源、交通等领域。市场层面：</p>
<ul>
<li><strong>基础软件</strong>：统信UOS、麒麟OS等国产操作系统加速适配，用友BIP等企业服务软件实现全栈信创化；</li>
<li><strong>工业软件</strong>：EDA（华大九天）、CAD（中望软件）、PLC（东土科技）等领域国产化率显著提升，部分核心系统已进入规模化推广阶段；</li>
<li><strong>生态建设</strong>：用友BIP联合3900+ISV伙伴、1100+专业服务商构建信创生态链，覆盖20+行业大类。</li>
</ul>
<h3><strong>企业应对策略与挑战</strong></h3>
<ol>
<li><strong>合规审查</strong>：企业需排查开源组件来源，避免使用受管制技术（如加密模块）；</li>
<li><strong>多元化布局</strong>：引入非美开源项目（如Rust语言、欧洲开发的数据库），降低单一技术依赖；</li>
<li><strong>法律支持</strong>：借助专业机构评估出口管制分类编号（ECCNs），规避违规风险。</li>
</ol>
<p>然而，挑战依然存在。国产数据库在金融核心系统替代中面临性能、生态兼容性难题，Oracle等海外产品的深厚积累形成替代壁垒。此外，多数国产软件基于开源技术二次开发，自主可控能力需进一步验证。</p>
<h3><strong>全球开源生态的反思</strong></h3>
<p>此次事件暴露了开源软件的地缘政治脆弱性。Apache、Linux等项目的美国背景使其成为管制工具，开发者需重新评估技术选型的风险。中国工程院院士倪光南呼吁：“必须建立自主可控的基础软件生态，避免将国家数字安全寄托于他国法律框架。”</p>
<p>当前，中美科技竞争已从硬件延伸至软件领域，开源社区的“自由共享”理念正遭遇前所未有的挑战。中国信创产业能否在压力下实现技术突围，将成为全球软件格局重塑的关键变量。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>10月11日，美国政府宣布自11月1日起对中国商品加征100%关税，并首次将“所有关键软件”纳入出口管制范围，涵盖操作系统、数据库、工业控制系统、网络防护、身份认证等7大类技术领域。此次管制不仅针对商业软件，更将开源软件纳入监管框架，引发全球开发者社区高度关注。</p>
<h3><strong>开源软件为何被波及？</strong></h3>
<p>根据美国出口管制条例（EAR），若开源软件具备“关键软件”属性（如涉及加密、网络控制或供应链安全），即使代码公开可获取，仍需遵守出口许可要求。例如：</p>
<ul>
<li><strong>Apache基金会</strong>明确声明，其软件通过美国服务器分发，受EAR管辖；</li>
<li><strong>Linux内核</strong>虽由全球开发者协作，但因Linux基金会注册于美国且分发服务器位于境内，同样面临管制风险；</li>
<li><strong>Android系统</strong>（Apache 2.0许可证）虽名义上开源，但美国政府可依据EAR限制其对中国企业的使用。</li>
</ul>
<p>专家指出，美国此举旨在通过技术供应链切断中国获取关键软件能力的路径，开源社区的“无国界”特性被地缘政治重新定义。</p>
<h3><strong>中国信创与工业软件迎机遇</strong></h3>
<p>管制升级倒逼中国加速软件国产化进程。政策层面，国家设定2027年为全面替代完成节点，党政信创专项资金已到位，行业信创从金融、电信扩展至能源、交通等领域。市场层面：</p>
<ul>
<li><strong>基础软件</strong>：统信UOS、麒麟OS等国产操作系统加速适配，用友BIP等企业服务软件实现全栈信创化；</li>
<li><strong>工业软件</strong>：EDA（华大九天）、CAD（中望软件）、PLC（东土科技）等领域国产化率显著提升，部分核心系统已进入规模化推广阶段；</li>
<li><strong>生态建设</strong>：用友BIP联合3900+ISV伙伴、1100+专业服务商构建信创生态链，覆盖20+行业大类。</li>
</ul>
<h3><strong>企业应对策略与挑战</strong></h3>
<ol>
<li><strong>合规审查</strong>：企业需排查开源组件来源，避免使用受管制技术（如加密模块）；</li>
<li><strong>多元化布局</strong>：引入非美开源项目（如Rust语言、欧洲开发的数据库），降低单一技术依赖；</li>
<li><strong>法律支持</strong>：借助专业机构评估出口管制分类编号（ECCNs），规避违规风险。</li>
</ol>
<p>然而，挑战依然存在。国产数据库在金融核心系统替代中面临性能、生态兼容性难题，Oracle等海外产品的深厚积累形成替代壁垒。此外，多数国产软件基于开源技术二次开发，自主可控能力需进一步验证。</p>
<h3><strong>全球开源生态的反思</strong></h3>
<p>此次事件暴露了开源软件的地缘政治脆弱性。Apache、Linux等项目的美国背景使其成为管制工具，开发者需重新评估技术选型的风险。中国工程院院士倪光南呼吁：“必须建立自主可控的基础软件生态，避免将国家数字安全寄托于他国法律框架。”</p>
<p>当前，中美科技竞争已从硬件延伸至软件领域，开源社区的“自由共享”理念正遭遇前所未有的挑战。中国信创产业能否在压力下实现技术突围，将成为全球软件格局重塑的关键变量。</p>]]></content:encoded>
    
    <pubDate>Fri, 17 Oct 2025 10:41:03 +0800</pubDate>
  </item><item>
    <title><![CDATA[从 JSON 字符串到 Java 对象：Fastjson 1.2.83 全程解析]]></title>
    <link>https://my.oschina.net/u/5783135/blog/18695791</link>
    <itunes:title><![CDATA[从 JSON 字符串到 Java 对象：Fastjson 1.2.83 全程解析]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<h1>一、概述</h1>
<p>Fastjson 是阿里巴巴开源的高性能 JSON 序列化处理库，其主要以处理<strong>小数据</strong>时速度最快而著称，功能全面。Fastjson1.X版本目前已停止维护，被Fastjson2.X代替，但1.X版本国内被广泛使用，通过学习其技术架构，剖析架构上优缺点，对技术人员提升软件设计工程实践能力很有价值。</p>
<p>首先我们对“序列化 / 反序列化”概念上建立直观认识，把Java对象转化为JSON格式的字符串的过程叫做<strong>序列化</strong>操作，反之则叫<strong>反序列化</strong>。如果把“序列化 / 反序列化”放到整个计算机系统的坐标系里，可以把它看成一次数据的“跨边界搬家”。</p>
<p>对象在“内存世界”里活得很好，但只要一离开进程地址空间（网络、磁盘、数据库、浏览器、异构语言），就必须先打成包裹（序列化），到对岸再拆包裹（反序列化）。</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-7928e1f6ec">
</div>
<h1>二、核心模块架构</h1>
<p>从高层次视图看Fastjson框架的结构，主要可以分为<strong>用户接口层、配置管理层、序列化引擎、反序列化引擎和安全防护层</strong>。其中<strong>用户接口</strong>提供了门面类用户编码直接与门面类交互，降低使用复杂度；<strong>配置管理层</strong>允许用户对框架行为进行配置；<strong>序列化引擎</strong>是序列化操作的核心实现；<strong>反序列引擎</strong>是反序列化操作的核心实现；<strong>安全模块</strong>解决框架安全问题，允许用户针对安全问题设置黑白名单等安全检查功能。下图为Fastjson模块关系图：</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-f5b2666f10">
</div>
<p>模块关系图</p>
<h1>三、项目结构</h1>
<pre><code>com.alibaba.fastjson/
├── JSON.java &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 核心入口类
├── annotation/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 注解定义
├── asm/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# ASM字节码精简库
├── parser/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 解析器模块
│ &nbsp; ├── DefaultJSONParser.java &nbsp;# 默认JSON解析器
│ &nbsp; ├── JSONLexer.java &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 词法分析器接口
│ &nbsp; ├── JSONScanner.java &nbsp; &nbsp; &nbsp; &nbsp;# 词法分析器实现
│ &nbsp; └── deserializer/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# 反序列化器
├── serializer/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 序列化器模块
│ &nbsp; ├── JSONSerializer.java &nbsp; &nbsp;&nbsp;# JSON序列化器
│ &nbsp; ├── SerializeConfig.java &nbsp; &nbsp;# 序列化配置
│ &nbsp; └── ObjectSerializer.java &nbsp;&nbsp;# 对象序列化器接口
├── spi/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# SPI扩展机制
├── support/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# 框架支持
└── util/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 工具类</code></pre>
<h1>3.1 项目结构说明</h1>
<p>主要可以划分为以下几个核心模块（包）：</p>
<p><strong>com.alibaba.fastjson (核心 API 与数据结构)</strong></p>
<ul>
<li>关键类 :
<ul>
<li>JSON.java: 整个库的门面（Facade），提供了最常用、最便捷的静态方法，如 toJSONString() (序列化), parseObject() (反序列化为对象), parseArray() (反序列化为数组)。通常它是用户最先接触到的类。</li>
<li>JSONObject.java: 继承自java.util.HashMap，用于表示 JSON 对象结构（ {key: value} ）。</li>
<li>JSONArray.java: 继承自java.util.ArrayList，用于表示 JSON 数组结构 ( [value1, value2] )。</li>
</ul> </li>
</ul>
<p><strong>com.alibaba.fastjson.serializer (序列化模块)</strong></p>
<p>此模块负责将 Java 对象转换为 JSON 格式的字符串</p>
<ul>
<li>关键类 :
<ul>
<li>JSONSerializer.java: 序列化的核心调度器。它维护了序列化的上下文信息，如对象引用、循环依赖检测、特性（ SerializerFeature ）开关等，并驱动整个序列化过程。</li>
<li>SerializeWriter.java: 一个高度优化的 Writer 实现，专门用于生成 JSON 字符串。它内部使用 char[] 数组来拼接字符串，避免了 String 的不可变性带来的性能损耗，<strong>是 Fastjson 高性能写入的关键</strong>。</li>
<li>JavaBeanSerializer.java: 默认的 JavaBean 序列化器。在未启用 ASM 优化时，它通过<strong>反射获取对象的属性</strong>（ getter 方法）并将其序列化。</li>
<li>ASMSerializerFactory.java: 性能优化的核心 。它使用 ASM 字节码技术在运行时动态生成序列化器类，这些类直接调用 getter 方法并操作SerializeWriter，避免了反射的性能开销。</li>
<li>ObjectSerializer.java: 序列化器接口。用户可以通过实现此接口来为特定类型提供自定义的序列化逻辑。</li>
<li>SerializeConfig.java: 序列化配置类。它维护了 Java 类型到&nbsp;ObjectSerializer&nbsp;的缓存。&nbsp;SerializeConfig.getGlobalInstance()&nbsp;提供了全局唯一的配置实例。</li>
<li>SerializerFeature.java: 序列化特性枚举。定义了各种序列化行为的开关，例如 WriteMapNullValue (输出 null 值的字段)、&nbsp;DisableCircularReferenceDetect&nbsp;(禁用循环引用检测) 等。</li>
</ul> </li>
</ul>
<p><strong>com.alibaba.fastjson.parser (反序列化模块)</strong></p>
<p>此模块负责将 JSON 格式的字符串解析为 Java 对象。</p>
<ul>
<li>关键类 :
<ul>
<li>DefaultJSONParser.java: 反序列化的核心调度器。它负责解析 JSON 字符串的整个过程，管理&nbsp;JSONLexer进行词法分析，并根据 Token (如 { , } , [ , ] , string , number 等)构建 Java 对象。</li>
<li>JSONLexer.java / JSONLexerBase.java: JSON 词法分析器。它负责扫描输入的 JSON 字符串，将其切割成一个个有意义的 Token ，供 DefaultJSONParser 使用。</li>
<li>JavaBeanDeserializer.java: 默认的 JavaBean 反序列化器。在未启用 ASM 优化时，它<strong>通过反射创建对象实例并设置其属性值。</strong></li>
<li>ASMDeserializerFactory.java: 与序列化类似，它<strong>动态生成反序列化器字节码</strong>，直接调用 setter 方法或直接对字段赋值，避免了反射。</li>
<li>ObjectDeserializer.java: 反序列化器接口。用户可以实现此接口来自定义特定类型的反序列化逻辑。</li>
<li>ParserConfig.java: 反序列化配置类。维护了 Java 类型到 ObjectDeserializer 缓存，并负责管理 ASM 生成的类的加载。</li>
<li>Feature.java: 反序列化特性枚举，用于控制解析行为。</li>
</ul> </li>
</ul>
<p><strong>com.alibaba.fastjson.annotation (注解模块)</strong></p>
<p>提供了一系列注解，允许用户通过声明式的方式精细地控制序列化和反序列化的行为。</p>
<ul>
<li>关键注解 :
<ul>
<li>@JSONField: 最核心的注解，可用于字段或方法上，用于自定义字段名、格式化、序列化/反序列化顺序、是否包含等。</li>
<li>@JSONType: 可用于类上，用于配置该类的序列化器、反序列化器、特性开关等。</li>
</ul> </li>
</ul>
<h1>3.2 项目结构小结</h1>
<p>Fastjson 框架在架构设计体现了“关注点分离”的原则，将序列化、反序列化、API、工具类等清晰地划分到不同的模块中。整个框架具有高度的可扩展性，用户可以通过&nbsp;ObjectSerializer&nbsp;/&nbsp;ObjectDeserializer接口和丰富的注解来满足各种复杂的定制化需求。</p>
<h1>四、核心源码分析</h1>
<p>为了更直观说明框架实现原理，本文对部分展示的源代码进行了删减，有些使用了伪代码，如需了解更多实现细节请读者阅读项目源码(https://github.com/alibaba/fastjson)</p>
<p>整体上Fastjson通过统一的门面API（JSON.toJSONString/parseObject）调用核心控制器（JSONSerializer/DefaultJSONParser），利用<strong>ASM字节码生成</strong>或<strong>反射机制</strong>，配合SerializeWriter/JSONLexer进行高效的Java对象与JSON字符串间<strong>双向转换</strong>，同时提供<strong>配置缓存、循环引用检测</strong>和<strong>AutoType安全防护</strong>等优化机制。下图为框架处理数据流：</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-e46406b14e">
</div>
<p>数据流</p>
<h1>4.1 序列化原理介绍</h1>
<p>序列化步骤主要包括：序列化器查找→JavaBean字段解析→字段值转换和JSON字符串构建等过程。下图为序列化处理时序图：</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-81b374241a">
</div>
<p>序列化时序图</p>
<p><strong>序列化入口与初始化</strong></p>
<p>使用JSON.toJSONString()入口，将person对象转换为JSON字符串。</p>
<pre><code>Person&nbsp;person =&nbsp;new&nbsp;Person();
String&nbsp;json =&nbsp;JSON.toJSONString(person);</code></pre>
<p>用户调用toJSONString方法进行对象序列化操作，JSON.java包含了多个toJSONString重载方法，共同完成核心类初始化：SerializeConfig，SerializeWriter，JSONSerializer。</p>
<pre><code>//用户不指定SerializeConfig,默认私有全局配置
public&nbsp;static&nbsp;String&nbsp;toJSONString(Object&nbsp;object, SerializeFilter[] filters,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializerFeature... features) {
&nbsp; &nbsp;return&nbsp;toJSONString(object,&nbsp;SerializeConfig.globalInstance, filters,&nbsp;null,&nbsp;DEFAULT_GENERATE_FEATURE, features);
}
public&nbsp;static&nbsp;String&nbsp;toJSONString(Object&nbsp;object,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializeConfig config,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializeFilter[] filters,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;String&nbsp;dateFormat,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int defaultFeatures,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializerFeature... features) {
&nbsp; &nbsp;&nbsp;SerializeWriter&nbsp;out =&nbsp;new&nbsp;SerializeWriter((Writer)&nbsp;null, defaultFeatures, features);
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;JSONSerializer serializer =&nbsp;new&nbsp;JSONSerializer(out);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//省略其他代码...
&nbsp; &nbsp; &nbsp; &nbsp; serializer.write(object); &nbsp;// 核心序列化调用
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;out.toString();
&nbsp; &nbsp; }&nbsp;finally&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; out.close();
&nbsp; &nbsp; }
}</code></pre>
<p><strong>序列化控制流程</strong></p>
<p><strong>JSONSerializer.write()核心逻辑</strong></p>
<p>write方法的逻辑比较简单，首先处理null值，然后根据类型查找序列器(ObjectSerializer)，最后将序列化逻辑委派给序列化器处理。</p>
<pre><code>public&nbsp;final&nbsp;void&nbsp;write(Object&nbsp;object) {
&nbsp; &nbsp;&nbsp;//如何序列化对象为null，直接写入"null"字符串
&nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; out.writeNull();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;Class&lt;?&gt; clazz =&nbsp;object.getClass();
&nbsp; &nbsp;&nbsp;ObjectSerializer&nbsp;writer =&nbsp;getObjectWriter(clazz); &nbsp;// 类型识别与序列化器选择
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; writer.write(this,&nbsp;object,&nbsp;null,&nbsp;null,&nbsp;0); &nbsp;// 委托给具体序列化器
&nbsp; &nbsp; }&nbsp;catch&nbsp;(IOException&nbsp;e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException(e.getMessage(), e);
&nbsp; &nbsp; }
}</code></pre>
<p><strong>类型识别与序列化器策略</strong></p>
<p>框架采用策略化模式将不同类型序列化逻辑封装成不同的序列化器：</p>
<ul>
<li>基础类型 : 使用专门的Codec（如StringCodec、IntegerCodec）</li>
<li>集合类型 : 使用ListSerializer、MapSerializer等</li>
<li>JavaBean : 使用JavaBeanSerializer或ASM动态生成的序列化器</li>
<li>枚举类型 : 使用EnumSerializer</li>
</ul>
<p>SerializeConfig.getObjectWriter方法负责序列化器查找工作：</p>
<pre><code>
public&nbsp;ObjectSerializer getObjectWriter(Class&lt;?&gt; clazz, boolean create) {
&nbsp; &nbsp;&nbsp;// 第一步：缓存查找
&nbsp; &nbsp; ObjectSerializer writer =&nbsp;get(clazz);
&nbsp; &nbsp;&nbsp;if&nbsp;(writer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;writer;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 第二步：SPI扩展加载（当前线程类加载器）
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(Object o : ServiceLoader.load(AutowiredObjectSerializer.class, classLoader)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!(o instanceof AutowiredObjectSerializer)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;continue;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AutowiredObjectSerializer autowired = (AutowiredObjectSerializer) o;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(Type forType : autowired.getAutowiredFor()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(forType, autowired);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }&nbsp;catch&nbsp;(ClassCastException ex) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// skip
&nbsp; &nbsp; }
&nbsp; &nbsp; writer =&nbsp;get(clazz);
&nbsp; &nbsp;&nbsp;if&nbsp;(writer ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 第三步：SPI扩展加载（JSON类加载器）
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;ClassLoader classLoader = JSON.class.getClassLoader();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(classLoader != Thread.currentThread().getContextClassLoader()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 重复SPI加载逻辑...
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 第四步：模块扩展
&nbsp; &nbsp;&nbsp;for&nbsp;(Module module : modules) {
&nbsp; &nbsp; &nbsp; &nbsp; writer = module.createSerializer(this, clazz);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(writer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;writer;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 第五步：内置类型匹配
&nbsp; &nbsp;&nbsp;if&nbsp;(writer ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; String className = clazz.getName();
&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; superClass;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(Map.class.isAssignableFrom(clazz)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer = MapSerializer.instance);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(List.class.isAssignableFrom(clazz)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer = ListSerializer.instance);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(Collection.class.isAssignableFrom(clazz)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer = CollectionCodec.instance);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(Date.class.isAssignableFrom(clazz)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer = DateCodec.instance);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(clazz.isEnum()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 枚举处理逻辑
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(clazz.isArray()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 数组处理逻辑
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 第六步：JavaBean序列化器创建
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(create) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writer = createJavaBeanSerializer(clazz);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;return&nbsp;writer;
}</code></pre>
<p><strong>JavaBean序列化处理</strong></p>
<p>JavaBeanSerializer的write方法实现了Java对象序列化处理核心逻辑：</p>
<p><strong>方法签名分析：</strong></p>
<pre><code>protected&nbsp;void&nbsp;write(JSONSerializer serializer,&nbsp;//JSON序列化器，提供序列化上下文和输出流
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;object,&nbsp;//待序列化的Java对象
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;fieldName,&nbsp;//字段名称，用于上下文追踪
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Type&nbsp;fieldType,&nbsp;//字段类型信息
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int features,&nbsp;//序列化特性标志位
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;boolean&nbsp;unwrapped&nbsp;//是否展开包装，用于嵌套对象处理
&nbsp; &nbsp; ) throws&nbsp;IOException</code></pre>
<p><strong>序列化流程概览：</strong></p>
<pre><code>// 1. 空值检查和循环引用处理
if&nbsp;(object&nbsp;==&nbsp;null) {
&nbsp; &nbsp;&nbsp;out.writeNull();
&nbsp; &nbsp;&nbsp;return;
}
if&nbsp;(writeReference(serializer,&nbsp;object, features)) {
&nbsp; &nbsp;&nbsp;return;
}
// 2. 字段序列化器选择
final&nbsp;FieldSerializer[] getters;
if&nbsp;(out.sortField) {
&nbsp; &nbsp; getters =&nbsp;this.sortedGetters;
}&nbsp;else&nbsp;{
&nbsp; &nbsp; getters =&nbsp;this.getters;
}
// 3. 上下文设置和格式判断
SerialContext parent = serializer.context;
if&nbsp;(!this.beanInfo.beanType.isEnum()) {
&nbsp; &nbsp; serializer.setContext(parent,&nbsp;object, fieldName,&nbsp;this.beanInfo.features, features);
}
// 4.遍历属性序列化器，完成属性序列化
for&nbsp;(int i =&nbsp;0; i &lt; getters.length; ++i) {
&nbsp; &nbsp; FieldSerializer fieldSerializer = getters[i];
&nbsp; &nbsp;&nbsp;// 获取属性值
&nbsp; &nbsp; Object propertyValue =&nbsp;this.processValue(serializer, fieldSerializer.fieldContext,&nbsp;object, fieldInfoName,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; propertyValue, features);
&nbsp; &nbsp;&nbsp;// 写入属性值 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; fieldSerializer.writeValue(serializer, propertyValue);
}</code></pre>
<p><strong>循环引用检测：</strong></p>
<p>JavaBeanSerializerwriteReference&nbsp;方法执行循环引用检测，Fastjson使用$ref占位符处理循环引用问题，防止对象循环引用造成解析查询栈溢出。</p>
<pre><code>public&nbsp;boolean&nbsp;writeReference(JSONSerializer serializer,&nbsp;Object&nbsp;object, int fieldFeatures) {
&nbsp; &nbsp;&nbsp;SerialContext&nbsp;context = serializer.context;
&nbsp; &nbsp; int mask =&nbsp;SerializerFeature.DisableCircularReferenceDetect.mask;
&nbsp; &nbsp;&nbsp;// 检查是否禁用循环引用检测
&nbsp; &nbsp;&nbsp;if&nbsp;(context ==&nbsp;null&nbsp;|| (context.features&nbsp;&amp; mask) !=&nbsp;0&nbsp;|| (fieldFeatures &amp; mask) !=&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 检查对象是否已存在于引用表中
&nbsp; &nbsp;&nbsp;if&nbsp;(serializer.references&nbsp;!=&nbsp;null&nbsp;&amp;&amp; serializer.references.containsKey(object)) {
&nbsp; &nbsp; &nbsp; &nbsp; serializer.writeReference(object); &nbsp;// 写入引用标记
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;true;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;return&nbsp;false;
}</code></pre>
<p><strong>上下文管理与引用追踪：</strong></p>
<p>序列化采用DFS(深度优先)算法遍历对象树，使用&nbsp;IdentityHashMap&lt;Object, SerialContext&gt; references&nbsp;来追踪对象引用：</p>
<ul>
<li>setContext: 建立序列化上下文，记录对象层次关系</li>
<li>containsReference: 检查对象是否已被序列化</li>
<li>popContext: 序列化完成后清理上下文</li>
</ul>
<pre><code>protected&nbsp;IdentityHashMap&lt;Object,&nbsp;SerialContext&gt; references &nbsp;=&nbsp;null;
protected&nbsp;SerialContext&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context;
//使用链表建立序列化上下文引用链，记录对象层次关系
public&nbsp;void&nbsp;setContext(SerialContext parent,&nbsp;Object&nbsp;object,&nbsp;Object&nbsp;fieldName, int features, int fieldFeatures) {
&nbsp; &nbsp;&nbsp;if&nbsp;(out.disableCircularReferenceDetect) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//构建当前上下文到parent上下文引用链
&nbsp; &nbsp;&nbsp;this.context&nbsp;=&nbsp;new&nbsp;SerialContext(parent,&nbsp;object, fieldName, features, fieldFeatures);
&nbsp; &nbsp;&nbsp;if&nbsp;(references ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; references =&nbsp;new&nbsp;IdentityHashMap&lt;Object,&nbsp;SerialContext&gt;();
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;this.references.put(object, context);
}
//检查对象是否已被序列化,防止重复序列化
public&nbsp;boolean&nbsp;containsReference(Object&nbsp;value) {
&nbsp; &nbsp;&nbsp;if&nbsp;(references ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;SerialContext&nbsp;refContext = references.get(value);
&nbsp; &nbsp;&nbsp;if&nbsp;(refContext ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;if&nbsp;(value ==&nbsp;Collections.emptyMap()) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;Object&nbsp;fieldName = refContext.fieldName;
&nbsp; &nbsp;&nbsp;return&nbsp;fieldName ==&nbsp;null&nbsp;|| fieldName&nbsp;instanceof&nbsp;Integer&nbsp;|| fieldName&nbsp;instanceof&nbsp;String;
}
//清理上下文，将当前序列化上下文指向父亲节点
public&nbsp;void&nbsp;popContext() {
&nbsp; &nbsp;&nbsp;if&nbsp;(context !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.context&nbsp;=&nbsp;this.context.parent;
&nbsp; &nbsp; }
}</code></pre>
<p><strong>字段值转换与序列化</strong></p>
<p><strong>FieldSerializer.writeValue()核心逻辑</strong></p>
<p>FieldSerializer&nbsp;的writeValue方法实现了字段值的序列化操作：</p>
<pre><code>public&nbsp;void&nbsp;writeValue(JSONSerializer serializer, Object propertyValue)&nbsp;throws&nbsp;Exception {
&nbsp; &nbsp;&nbsp;// 运行时类型识别
&nbsp; &nbsp; Class&lt;?&gt; runtimeFieldClass = propertyValue !=&nbsp;null&nbsp;?&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; propertyValue.getClass() :&nbsp;this.fieldInfo.fieldClass;
&nbsp; &nbsp;&nbsp;// 查找属性类型对应的序列化器
&nbsp; &nbsp;&nbsp;ObjectSerializer&nbsp;fieldSerializer&nbsp;=&nbsp;serializer.getObjectWriter(runtimeFieldClass);
&nbsp; &nbsp;&nbsp;// 处理特殊格式和注解
&nbsp; &nbsp;&nbsp;if&nbsp;(format !=&nbsp;null&nbsp;&amp;&amp; !(fieldSerializer&nbsp;instanceof&nbsp;DoubleSerializer)) {
&nbsp; &nbsp; &nbsp; &nbsp; serializer.writeWithFormat(propertyValue, format);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 委托给具体序列化器处理
&nbsp; &nbsp; fieldSerializer.write(serializer, propertyValue, fieldInfo.name,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fieldInfo.fieldType, fieldFeatures);
}</code></pre>
<p><strong>不同类型的序列化策略</strong></p>
<p>基础类型序列化 ：</p>
<ul>
<li>直接调用SerializeWriter的对应方法（writeInt、writeString等）</li>
</ul>
<p>复杂对象序列化 ：</p>
<ul>
<li>递归调用JSONSerializer.write()方法</li>
<li>维护序列化上下文和引用关系</li>
<li>应用过滤器和特性配置</li>
</ul>
<p>ASM定制化序列化器加速，下文会进行详细讲解。</p>
<ul>
<li>为序列化的类动态生成定制化的序列化器，避免反射调用开销</li>
</ul>
<p><strong>JSON字符串构建</strong></p>
<p>SerializeWriter.java采用线程本地缓冲机制，提供高效的字符串构建：</p>
<pre><code>//用于存储存JSON字符串
private&nbsp;final&nbsp;static&nbsp;ThreadLocal&lt;char[]&gt; bufLocal &nbsp; &nbsp; &nbsp; &nbsp; =&nbsp;new&nbsp;ThreadLocal&lt;char[]&gt;();
//将字符串转换为UTF-8字节数组
private&nbsp;final&nbsp;static&nbsp;ThreadLocal&lt;byte[]&gt; bytesBufLocal &nbsp; &nbsp;=&nbsp;new&nbsp;ThreadLocal&lt;byte[]&gt;();</code></pre>
<ul>
<li>字符缓冲区 : 线程本地char[]数组减少内存分配，避免频繁创建临时数组对象。</li>
<li>动态扩容 : 根据内容长度自动调整缓冲区大小。</li>
</ul>
<p>bufLocal初始化创建2048字符的缓冲区，回收阶段当缓冲区大小不超过 BUFFER_THRESHOLD （128KB）时，将其放回ThreadLocal缓存，超过阈值的大缓冲区不缓存，避免内存占用过大。</p>
<p>bytesBufLocal专门用于UTF-8编码转换过程，初始缓冲区大小：8KB（1024 * 8），根据字符数量估算所需字节数（字符数 × 3），只有不超过 BUFFER_THRESHOLD 的缓冲区才会被缓存。</p>
<h1>4.2 序列化小结</h1>
<p>Fastjson通过JSON.toJSONString()门面API调用JSONSerializer控制器，利用ASM字节码生成的高性能序列化器或反射机制遍历Java对象字段，配合SerializeWriter将字段名和值逐步写入缓冲区构建JSON字符串。</p>
<h1>4.3 反序列化流程</h1>
<p>虽然“序列化”与“反序列化”在概念上是对偶的(Serialize ↔ Deserialize)，但在实现层面并不严格对偶，反序列化实现明显比序列化复杂。核心步骤包括：反序列化器查找→ 反序列流程控制→词法分析器（Tokenizer） → 安全检查→反射/ASM 字段填充等，下图为处理时序图：</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-675327763a">
</div>
<p><strong>反序列化入口与反序列化器选择</strong></p>
<p>反序列化从&nbsp;JSON.java的parseObject方法开始：</p>
<pre><code>// JSON.java - 反序列化入口
public&nbsp;static&nbsp;&lt;T&gt; T&nbsp;parseObject(String text, Class&lt;T&gt; clazz,&nbsp;int&nbsp;features)&nbsp;{
&nbsp; &nbsp;&nbsp;if&nbsp;(text ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;DefaultJSONParser&nbsp;parser&nbsp;=&nbsp;new&nbsp;DefaultJSONParser(text, ParserConfig.getGlobalInstance(), features);
&nbsp; &nbsp;&nbsp;T&nbsp;value&nbsp;=&nbsp;(T) parser.parseObject(clazz);
&nbsp; &nbsp; parser.handleResovleTask(value);
&nbsp; &nbsp; parser.close();
&nbsp; &nbsp;&nbsp;return&nbsp;value;
}</code></pre>
<p><strong>查找反序列化器</strong></p>
<p><strong>在 DefaultJSONParser.java 中选择合适的反序列化器：</strong></p>
<pre><code>// DefaultJSONParser.java - 反序列化器选择
public&nbsp;&lt;T&gt; T&nbsp;parseObject(Type&nbsp;type,&nbsp;Object&nbsp;fieldName) {
&nbsp; &nbsp; int token = lexer.token();
&nbsp; &nbsp;&nbsp;if&nbsp;(token ==&nbsp;JSONToken.NULL) {
&nbsp; &nbsp; &nbsp; &nbsp; lexer.nextToken();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T)&nbsp;TypeUtils.optionalEmpty(type);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//从缓存中查找反序列化器
&nbsp; &nbsp;&nbsp;ObjectDeserializer&nbsp;deserializer = config.getDeserializer(type);
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(deserializer.getClass() ==&nbsp;JavaBeanDeserializer.class) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T) ((JavaBeanDeserializer) deserializer).deserialze(this,&nbsp;type, fieldName,&nbsp;0);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T) deserializer.deserialze(this,&nbsp;type, fieldName);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }&nbsp;catch&nbsp;(JSONException e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;e;
&nbsp; &nbsp; }&nbsp;catch&nbsp;(Throwable&nbsp;e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException(e.getMessage(), e);
&nbsp; &nbsp; }
}</code></pre>
<p><strong>ParserConfig.java&nbsp;负责获取对应类型的反序列化器：</strong></p>
<pre><code>// ParserConfig.java - 反序列化器获取
public&nbsp;ObjectDeserializer&nbsp;getDeserializer(Type&nbsp;type) {
&nbsp; &nbsp;&nbsp;ObjectDeserializer&nbsp;deserializer =&nbsp;this.deserializers.get(type);
&nbsp; &nbsp;&nbsp;if&nbsp;(deserializer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;deserializer;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//通过Class查找
&nbsp; &nbsp;&nbsp;if&nbsp;(type&nbsp;instanceof&nbsp;Class&lt;?&gt;) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;getDeserializer((Class&lt;?&gt;)&nbsp;type,&nbsp;type);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//通过泛型参数查找
&nbsp; &nbsp;&nbsp;if&nbsp;(type&nbsp;instanceof&nbsp;ParameterizedType) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Type&nbsp;rawType = ((ParameterizedType)&nbsp;type).getRawType();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(rawType&nbsp;instanceof&nbsp;Class&lt;?&gt;) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;getDeserializer((Class&lt;?&gt;) rawType,&nbsp;type);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;getDeserializer(rawType);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;return&nbsp;JavaObjectDeserializer.instance;
}</code></pre>
<p><strong>反序列化控制流程</strong></p>
<p>JavaBeanDeserializer.java&nbsp;的deserialze实现了反序列化主要处理流程。</p>
<pre><code>// JavaBeanDeserializer.java - 类型识别与字段匹配
public&nbsp;&lt;T&gt; T&nbsp;deserialze(DefaultJSONParser parser, Type&nbsp;type,&nbsp;Object&nbsp;fieldName, int features, int[] setFlags) {
&nbsp; &nbsp;&nbsp;// 1.特殊类型快速处理
&nbsp; &nbsp;&nbsp;if&nbsp;(type&nbsp;==&nbsp;JSON.class&nbsp;||&nbsp;type&nbsp;==&nbsp;JSONObject.class) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T) parser.parse();
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//2.初始化核心组件
&nbsp; &nbsp; final&nbsp;JSONLexer lexer = parser.lexer;
&nbsp; &nbsp;&nbsp;//3.反序列化上下文管理
&nbsp; &nbsp;&nbsp;ParseContext&nbsp;context = parser.getContext();
&nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;!=&nbsp;null&nbsp;&amp;&amp; context !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;context = context.parent;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;ParseContext&nbsp;childContext =&nbsp;null;
&nbsp; &nbsp;&nbsp;//保存解析后字段值
&nbsp; &nbsp;&nbsp;Map&lt;String,&nbsp;Object&gt; fieldValues =&nbsp;null;
&nbsp; &nbsp;&nbsp;// JSON关键字分支预处理
&nbsp; &nbsp;&nbsp;if&nbsp;(token ==&nbsp;JSONToken.RBRACE) {
&nbsp; &nbsp; &nbsp; &nbsp; lexer.nextToken(JSONToken.COMMA);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;object&nbsp;=&nbsp;createInstance(parser,&nbsp;type);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T)&nbsp;object;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//处理其他JSON关键字
&nbsp; &nbsp; ...
&nbsp; &nbsp;&nbsp;//4.字段解析主循环
&nbsp; &nbsp;&nbsp;for&nbsp;(int fieldIndex =&nbsp;0, notMatchCount =&nbsp;0;; fieldIndex++) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;boolean&nbsp;customDeserializer =&nbsp;false;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//这是一个性能优化的设计，通过预排序和索引访问来提高字段匹配的效率，
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//通常情况下JSON串按字段定义顺序排列，因此能快速命中
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldIndex &lt; sortedFieldDeserializers.length&nbsp;&amp;&amp; notMatchCount &lt;&nbsp;16) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldDeserializer = sortedFieldDeserializers[fieldIndex];
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldInfo = fieldDeserializer.fieldInfo;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldClass = fieldInfo.fieldClass;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldAnnotation = fieldInfo.getAnnotation();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldAnnotation !=&nbsp;null&nbsp;&amp;&amp; fieldDeserializer&nbsp;instanceof&nbsp;DefaultFieldDeserializer) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; customDeserializer = ((DefaultFieldDeserializer) fieldDeserializer).customDeserilizer;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Object&nbsp;fieldValue =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if&nbsp;(fieldDeserializer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char[] name_chars = fieldInfo.name_chars;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//指定了自定义发序列化器，后续使用自定义序列化器处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(customDeserializer &amp;&amp; lexer.matchField(name_chars)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchField =&nbsp;true;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 基本类型快速路径匹配
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}&nbsp;else&nbsp;if&nbsp;(fieldClass == int.class&nbsp;|| fieldClass ==&nbsp;Integer.class) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//词法分析,解析int值
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int intVal = lexer.scanFieldInt(name_chars);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(intVal ==&nbsp;0&nbsp;&amp;&amp; lexer.matchStat&nbsp;==&nbsp;JSONLexer.VALUE_NULL) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldValue =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldValue = intVal;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(lexer.matchStat&nbsp;&gt;&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchField =&nbsp;true;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valueParsed =&nbsp;true;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(lexer.matchStat&nbsp;==&nbsp;JSONLexer.NOT_MATCH_NAME) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//增加计算，记录未命中次数以调整匹配策略
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notMatchCount++;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;continue;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}&nbsp;else&nbsp;if(...){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//省略其他基础类型处理 &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 快速匹配失败，动态扫描字段名,通过符号表优化:返回的字符串可能是符号表中的缓存实例
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if&nbsp;(!matchField) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key = lexer.scanSymbol(parser.symbolTable);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// $ref 引用处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;("$ref"&nbsp;== key &amp;&amp; context !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;handleReferenceResolution(lexer, parser, context)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// @type 类型处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;((typeKey !=&nbsp;null&nbsp;&amp;&amp; typeKey.equals(key))
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ||&nbsp;JSON.DEFAULT_TYPE_KEY&nbsp;== key) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//AutoType安全检查
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; config.checkAutoType(typeName, expectClass, lexer.getFeatures());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;handleTypeNameResolution(lexer, parser, config, beanInfo,&nbsp;type, fieldName);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 5.如果对象为空，则创建对象实例
&nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;==&nbsp;null&nbsp;&amp;&amp; fieldInfo ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;object&nbsp;=&nbsp;createInstance(parser,&nbsp;type);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//6. 字段值设置
&nbsp; &nbsp;&nbsp;for&nbsp;(Map.Entry&lt;String,&nbsp;Object&gt; entry : fieldValues.entrySet()) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;FieldDeserializer&nbsp;fieldDeserializer =&nbsp;getFieldDeserializer(entry.getKey());
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldDeserializer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldDeserializer.setValue(object, entry.getValue());
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp;&nbsp;return&nbsp;(T)&nbsp;object;
}</code></pre>
<p><strong>字符串解析阶段（词法分析）</strong></p>
<p>JSONLexerBase内部维护词法解析状态机，实现词法分析核心逻辑，下面展示了Integer值类型处理源码：</p>
<pre><code>&nbsp; &nbsp;&nbsp;public&nbsp;int scanFieldInt(char[] fieldName) {
&nbsp; &nbsp; &nbsp; &nbsp; matchStat = UNKNOWN;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 1. 字段名匹配阶段
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!charArrayCompare(fieldName)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH_NAME;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; int offset = fieldName.length;
&nbsp; &nbsp; &nbsp; &nbsp; char chLocal = charAt(bp + (offset++));
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 2. 负号处理
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;boolean negative = chLocal ==&nbsp;'-';
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(negative) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chLocal = charAt(bp + (offset++));
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 3. 数字解析核心算法
&nbsp; &nbsp; &nbsp; &nbsp; int value;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal &gt;=&nbsp;'0'&nbsp;&amp;&amp; chLocal &lt;=&nbsp;'9') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = chLocal -&nbsp;'0';
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(;;) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chLocal = charAt(bp + (offset++));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal &gt;=&nbsp;'0'&nbsp;&amp;&amp; chLocal &lt;=&nbsp;'9') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = value *&nbsp;10&nbsp;+ (chLocal -&nbsp;'0');// 十进制累加
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(chLocal ==&nbsp;'.') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;&nbsp;// 拒绝浮点数
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 4. 溢出检测
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(value &lt;&nbsp;0&nbsp;//
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || offset &gt;&nbsp;11&nbsp;+&nbsp;3&nbsp;+ fieldName.length) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(value != Integer.MIN_VALUE&nbsp;//
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || offset !=&nbsp;17&nbsp;//
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || !negative) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 5. JSON 结束符处理
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal ==&nbsp;',') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += offset;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.ch =&nbsp;this.charAt(bp);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = VALUE;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.COMMA;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;negative ? -value : value;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal ==&nbsp;'}') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// ... 处理对象结束和嵌套结构
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chLocal = charAt(bp + (offset++));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal ==&nbsp;',') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.COMMA;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += offset;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.ch =&nbsp;this.charAt(bp);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(chLocal ==&nbsp;']') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.RBRACKET;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += offset;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.ch =&nbsp;this.charAt(bp);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(chLocal ==&nbsp;'}') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.RBRACE;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += offset;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.ch =&nbsp;this.charAt(bp);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(chLocal == EOI) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.EOF;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += (offset -&nbsp;1);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch = EOI;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = END;
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;negative ? -value : value;
&nbsp; &nbsp; }</code></pre>
<p><strong>类型安全检查（AutoType检查）</strong></p>
<p>ParserConfig.java&nbsp;中的checkAutoType方法对反序列化类型做黑白名单检查。</p>
<pre><code>// ParserConfig.java - AutoType安全检查
public&nbsp;Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass,&nbsp;int&nbsp;features) {
&nbsp; &nbsp;&nbsp;if&nbsp;(typeName ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;if&nbsp;(typeName.length() &gt;=&nbsp;192&nbsp;|| typeName.length() &lt;&nbsp;3) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("autoType is not support. "&nbsp;+ typeName);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;String&nbsp;className&nbsp;=&nbsp;typeName.replace('$',&nbsp;'.');
&nbsp; &nbsp; Class&lt;?&gt; clazz =&nbsp;null;
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;final&nbsp;long&nbsp;BASIC&nbsp;=&nbsp;0xcbf29ce484222325L;
&nbsp; &nbsp;&nbsp;final&nbsp;long&nbsp;PRIME&nbsp;=&nbsp;0x100000001b3L;
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;final&nbsp;long&nbsp;h1&nbsp;=&nbsp;(BASIC ^ className.charAt(0)) * PRIME;
&nbsp; &nbsp;&nbsp;// hash code编码匹配性能优化
&nbsp; &nbsp;&nbsp;if&nbsp;(h1 ==&nbsp;0xaf64164c86024f1aL) {&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("autoType is not support. "&nbsp;+ typeName);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;if&nbsp;((h1 ^ className.charAt(className.length() -&nbsp;1)) * PRIME ==&nbsp;0x9198507b5af98f0L) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("autoType is not support. "&nbsp;+ typeName);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;final&nbsp;long&nbsp;h3&nbsp;=&nbsp;(((((BASIC ^ className.charAt(0))&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * PRIME)&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ className.charAt(1))&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * PRIME)&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ className.charAt(2))&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * PRIME;
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;if&nbsp;(autoTypeSupport || expectClass !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;long&nbsp;hash&nbsp;=&nbsp;h3;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;3; i &lt; className.length(); ++i) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash ^= className.charAt(i);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash *= PRIME;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(Arrays.binarySearch(denyHashCodes, hash) &gt;=&nbsp;0&nbsp;&amp;&amp; TypeUtils.getClassFromMapping(typeName) ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("autoType is not support. "&nbsp;+ typeName);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(Arrays.binarySearch(acceptHashCodes, hash) &gt;=&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clazz = TypeUtils.loadClass(typeName, defaultClassLoader,&nbsp;false);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(clazz !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;clazz;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// ... 更多安全检查逻辑
&nbsp; &nbsp;&nbsp;return&nbsp;clazz;
}</code></pre>
<p><strong>对象实例化过程</strong></p>
<p><strong>JavaBeanDeserializer.java中的createInstance方法创建对象实例：</strong></p>
<pre><code>// JavaBeanDeserializer.java - 对象实例化
protected&nbsp;Object&nbsp;createInstance(DefaultJSONParser parser, Type&nbsp;type) {
&nbsp; &nbsp;&nbsp;if&nbsp;(type&nbsp;instanceof&nbsp;Class) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(clazz.isInterface()) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 接口类型使用Java反射创建实例
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Class&lt;?&gt; clazz = (Class&lt;?&gt;)&nbsp;type;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ClassLoader&nbsp;loader =&nbsp;Thread.currentThread().getContextClassLoader();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final&nbsp;JSONObject&nbsp;obj =&nbsp;new&nbsp;JSONObject();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;proxy =&nbsp;Proxy.newProxyInstance(loader,&nbsp;new&nbsp;Class&lt;?&gt;[] { clazz }, obj);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;proxy;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;if&nbsp;(beanInfo.defaultConstructor&nbsp;==&nbsp;null&nbsp;&amp;&amp; beanInfo.factoryMethod&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;Object&nbsp;object;
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp;&nbsp;//通过构造器创建实例
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Constructor&lt;?&gt; constructor = beanInfo.defaultConstructor;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(beanInfo.defaultConstructorParameterSize&nbsp;==&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;object&nbsp;= constructor.newInstance();
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ParseContext&nbsp;context = parser.getContext();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(context ==&nbsp;null&nbsp;|| context.object&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("can't create non-static inner class instance.");
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final&nbsp;Class&lt;?&gt; enclosingClass = constructor.getDeclaringClass().getEnclosingClass();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;object&nbsp;= constructor.newInstance(context.object);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }&nbsp;catch&nbsp;(JSONException e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;e;
&nbsp; &nbsp; }&nbsp;catch&nbsp;(Exception&nbsp;e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("create instance error, class "&nbsp;+ clazz.getName(), e);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;return&nbsp;object;
}</code></pre>
<p><strong>FieldDeserializer.java中的setValue方法通过反射实现字段设置：</strong></p>
<pre><code>// FieldDeserializer.java - 属性赋值的核心实现
public&nbsp;void&nbsp;setValue(Object&nbsp;object,&nbsp;Object&nbsp;value) {
&nbsp; &nbsp;&nbsp;if&nbsp;(value ==&nbsp;null&nbsp;&amp;&amp; fieldInfo.fieldClass.isPrimitive()) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(fieldInfo.fieldClass&nbsp;==&nbsp;String.class
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; fieldInfo.format&nbsp;!=&nbsp;null
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; fieldInfo.format.equals("trim")) {
&nbsp; &nbsp; &nbsp; &nbsp; value = ((String) value).trim();
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Method&nbsp;method = fieldInfo.method;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(method !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldInfo.getOnly) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 处理只读属性的特殊情况
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldInfo.fieldClass&nbsp;==&nbsp;AtomicInteger.class) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;AtomicInteger&nbsp;atomic = (AtomicInteger) method.invoke(object);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(atomic !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atomic.set(((AtomicInteger) value).get());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(Map.class.isAssignableFrom(method.getReturnType())) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Map&nbsp;map = (Map) method.invoke(object);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(map !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map.putAll((Map) value);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Collection&nbsp;collection = (Collection) method.invoke(object);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(collection !=&nbsp;null&nbsp;&amp;&amp; value !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collection.clear();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collection.addAll((Collection) value);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 通过setter方法赋值
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; method.invoke(object, value);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 通过字段直接赋值
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final&nbsp;Field&nbsp;field = fieldInfo.field;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(field !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; field.set(object, value);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }&nbsp;catch&nbsp;(Exception&nbsp;e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("set property error, "&nbsp;+ clazz.getName() +&nbsp;"#"&nbsp;+ fieldInfo.name, e);
&nbsp; &nbsp; }
}</code></pre>
<h1>4.4 反序列化小结</h1>
<p>Fastjson通过JSON.parseObject()门面API调用DefaultJSONParser控制器，利用JSONLexer进行词法分析解析JSON字符串，经过AutoType安全检查后使用ASM字节码生成动态反序列化器或反射机制创建Java对象实例并逐字段赋值。</p>
<h1>五、特性讲解</h1>
<h1>5.1 ASM性能优化</h1>
<p>ASM 是 fastjson 类似于 JIT，在运行时把「反射调用」翻译成「直接字段访问 + 方法调用」的字节码，从而把序列化/反序列化性能提升 20% 以上，当然随着JVM对反射性能的优化性能差正在逐渐被缩小。下图是作者使用工具类读取的动态序列化/反序列化器源码片段。</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-a1669be5d0">
</div>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-136f97bda8">
</div>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-82b4e0207e">
</div>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-b9069ddcfd">
</div>
<h1>5.2&nbsp; AutoType机制</h1>
<p>AutoType是 fastjson 的“动态多态还原”方案:</p>
<p>序列化时把具体子类名字写进&nbsp;"@type"，反序列化时先加载类 → 再调 setter → 完成还原。</p>
<p>&nbsp;速度上“指针引用”即可定位序列化器，功能上靠&nbsp;<a href="https://my.oschina.net/fanren1919" target="_blank">@type</a>&nbsp;字段把被擦除的泛型/接口/父类重新映射回具体实现。</p>
<p>在未开启AutoType机制情况下，在将store对象序列化成JSON串后，再反序列化为对象时由于字段的类型为接口无法转换成具体的Dog类型示例；开启AutoType机制后，序列化时将类型一并写入到JSON串内，后续进行反序列化时可以根据这个类型还原成具体的类型实例。</p>
<pre><code>interface&nbsp;Animal&nbsp;{}
class&nbsp;Dog&nbsp;implements&nbsp;Animal&nbsp;{
&nbsp; &nbsp;&nbsp;private&nbsp;String&nbsp;name;
&nbsp; &nbsp;&nbsp;private&nbsp;double weight;
&nbsp; &nbsp;&nbsp;//省略getter,setter
}
class&nbsp;PetStore&nbsp;{
&nbsp; &nbsp;&nbsp;private&nbsp;Animal&nbsp;animal;
}
public&nbsp;static&nbsp;void&nbsp;main(String[] args) {
&nbsp; &nbsp;&nbsp;Animal&nbsp;dog =&nbsp;new&nbsp;Dog("dodi",&nbsp;12);
&nbsp; &nbsp;&nbsp;PetStore&nbsp;store =&nbsp;new&nbsp;PetStore(dog);
&nbsp; &nbsp;&nbsp;String&nbsp;jsonString =&nbsp;JSON.toJSONString(store);
&nbsp; &nbsp;&nbsp;PetStore&nbsp;petStore =&nbsp;JSON.parseObject(jsonString,&nbsp;PetStore.class);
&nbsp; &nbsp;&nbsp;Dog&nbsp;parsedDog = (Dog) petStore.getAnimal();
}</code></pre>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-0051358e13">
</div>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-6a93c6470b">
</div>
<pre><code>public&nbsp;static&nbsp;void&nbsp;main(String[] args) {
&nbsp; &nbsp;&nbsp;Animal&nbsp;dog =&nbsp;new&nbsp;Dog("dodi",&nbsp;12);
&nbsp; &nbsp;&nbsp;PetStore&nbsp;store =&nbsp;new&nbsp;PetStore(dog);
&nbsp; &nbsp;&nbsp;String&nbsp;jsonString =&nbsp;JSON.toJSONString(store,&nbsp;SerializerFeature.WriteClassName);
&nbsp; &nbsp;&nbsp;PetStore&nbsp;petStore =&nbsp;JSON.parseObject(jsonString,&nbsp;PetStore.class);
&nbsp; &nbsp;&nbsp;Dog&nbsp;parsedDog = (Dog) petStore.getAnimal();
}</code></pre>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-e17c314f91">
</div>
<p>AutoType 让 fastjson 在反序列化时根据&nbsp;<a href="https://my.oschina.net/fanren1919" target="_blank">@type</a>&nbsp;字段动态加载任意类，这一“便利”却成为攻击者远程代码执行的快捷通道：通过把JdbcRowSetImpl等 JNDI 敏感类写进 JSON，服务端在调用 setter 的瞬间就会向外部 LDAP/RMI 服务器拉取恶意字节码，完成 RCE；而官方长期依赖“黑名单”堵漏，导致 1.2.25→1.2.80 出现 L 描述符、Throwable 二次反序列化、内部类等连续绕过，形成“补丁-绕过-再补丁”的猫鼠游戏， 虽然在1.2.68 引入 safeMode 但为了兼容性需要使用者手动开启 ，而且实现也不够健壮，开启safeMode仍有利用代码漏洞绕过检查风险，后续版本对safeMode加固并对已知安全漏洞清零，直到最新1.2.83版本安全问题也不能说彻底解决。</p>
<h1>5.3 流式解析</h1>
<p>Fastjson 提供一套 Streaming API，核心类JSONReader&nbsp;/JSONWriter，行业内惯称「流式解析」或「增量解析」，主要用于处理JSON大文件解析。技术上流式解析采用“拉模式（pull parsing）”，底层维护 8 KB 滑动缓冲，词法分析器（Tokenizer）把字节流切成 token 流，语法状态机根据 token 类型驱动反序列化器（ObjectReader）即时产出 Java 对象，对象一旦交付给用户代码处理后，内部引用立即释放。这种方式内存中不会保存所有对象，对象处理完即被丢弃，因此可以处理数据量远大于内存的数据，而不会出现OOM。下面是使用流式解析的示例代码：</p>
<pre><code>// 依赖：com.alibaba:fastjson:1.2.83
try&nbsp;(JSONReader reader =&nbsp;new&nbsp;JSONReader(
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;new&nbsp;InputStreamReader(
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;new&nbsp;FileInputStream("huge-array.json"),&nbsp;StandardCharsets.UTF_8))) {
&nbsp; &nbsp; reader.startArray(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 告诉解析器：根节点是 []
&nbsp; &nbsp;&nbsp;while&nbsp;(reader.hasNext()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 拉取下一条
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Order&nbsp;order = reader.readObject(Order.class);&nbsp;// 瞬时对象
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;processOrder(order);//业务处理
&nbsp; &nbsp; &nbsp; &nbsp; orderRepository.save(order); &nbsp; &nbsp;&nbsp;// 立即落盘，内存即可回收
&nbsp; &nbsp; }
&nbsp; &nbsp; reader.endArray();
}</code></pre>
<h1>六、总结</h1>
<p>Fastjson核心特性在于高速序列化/反序列化，利用ASM在运行时生成字节码动态创建解析器，减少反射；AutoType字段支持多态，却带来反序列化RCE风险，建议关闭AutoType，开启safeMode。选型建议：在选择JSON序列化框架时对于非极端性能要求推荐Jackson，或者使用Fastjson2，其改用LambdaMetafactory替换ASM，性能再提升30%，默认关闭AutoType安全性有保证。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li>FastJson 反序列化漏洞原理分析（https://www.cnblogs.com/Only-xiaoxiao/p/17213248.html）</li>
<li>序列化与反序列化——FastJSON、Jackson、Gson性能测试（https://zhuanlan.zhihu.com/p/529342385）</li>
<li>FASTJSON 2 Autotype机制介绍（https://alibaba.github.io/fastjson2/autotype_cn.html）</li>
<li>&nbsp;</li>
</ul>
<h4>往期回顾</h4>
<p>1.&nbsp;用好 TTL Agent 不踩雷：避开内存泄露与CPU 100%两大核心坑｜得物技术</p>
<p>2.&nbsp;线程池ThreadPoolExecutor源码深度解析｜得物技术</p>
<p>3.&nbsp;基于浏览器扩展 API Mock 工具开发探索｜得物技术</p>
<p>4.&nbsp;破解gh-ost变更导致MySQL表膨胀之谜｜得物技术</p>
<p>5.&nbsp;MySQL单表为何别超2000万行？揭秘B+树与16KB页的生死博弈｜得物技术</p>
<h4>文 /剑九</h4>
<p>关注得物技术，每周更新技术干货</p>
<p>要是觉得文章对你有帮助的话，欢迎评论转发点赞～</p>
<p>未经得物技术许可严禁转载，否则依法追究法律责任。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<h1>一、概述</h1>
<p>Fastjson 是阿里巴巴开源的高性能 JSON 序列化处理库，其主要以处理<strong>小数据</strong>时速度最快而著称，功能全面。Fastjson1.X版本目前已停止维护，被Fastjson2.X代替，但1.X版本国内被广泛使用，通过学习其技术架构，剖析架构上优缺点，对技术人员提升软件设计工程实践能力很有价值。</p>
<p>首先我们对“序列化 / 反序列化”概念上建立直观认识，把Java对象转化为JSON格式的字符串的过程叫做<strong>序列化</strong>操作，反之则叫<strong>反序列化</strong>。如果把“序列化 / 反序列化”放到整个计算机系统的坐标系里，可以把它看成一次数据的“跨边界搬家”。</p>
<p>对象在“内存世界”里活得很好，但只要一离开进程地址空间（网络、磁盘、数据库、浏览器、异构语言），就必须先打成包裹（序列化），到对岸再拆包裹（反序列化）。</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-7928e1f6ec">
</div>
<h1>二、核心模块架构</h1>
<p>从高层次视图看Fastjson框架的结构，主要可以分为<strong>用户接口层、配置管理层、序列化引擎、反序列化引擎和安全防护层</strong>。其中<strong>用户接口</strong>提供了门面类用户编码直接与门面类交互，降低使用复杂度；<strong>配置管理层</strong>允许用户对框架行为进行配置；<strong>序列化引擎</strong>是序列化操作的核心实现；<strong>反序列引擎</strong>是反序列化操作的核心实现；<strong>安全模块</strong>解决框架安全问题，允许用户针对安全问题设置黑白名单等安全检查功能。下图为Fastjson模块关系图：</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-f5b2666f10">
</div>
<p>模块关系图</p>
<h1>三、项目结构</h1>
<pre><code>com.alibaba.fastjson/
├── JSON.java &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 核心入口类
├── annotation/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 注解定义
├── asm/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# ASM字节码精简库
├── parser/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 解析器模块
│ &nbsp; ├── DefaultJSONParser.java &nbsp;# 默认JSON解析器
│ &nbsp; ├── JSONLexer.java &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 词法分析器接口
│ &nbsp; ├── JSONScanner.java &nbsp; &nbsp; &nbsp; &nbsp;# 词法分析器实现
│ &nbsp; └── deserializer/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# 反序列化器
├── serializer/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 序列化器模块
│ &nbsp; ├── JSONSerializer.java &nbsp; &nbsp;&nbsp;# JSON序列化器
│ &nbsp; ├── SerializeConfig.java &nbsp; &nbsp;# 序列化配置
│ &nbsp; └── ObjectSerializer.java &nbsp;&nbsp;# 对象序列化器接口
├── spi/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# SPI扩展机制
├── support/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# 框架支持
└── util/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 工具类</code></pre>
<h1>3.1 项目结构说明</h1>
<p>主要可以划分为以下几个核心模块（包）：</p>
<p><strong>com.alibaba.fastjson (核心 API 与数据结构)</strong></p>
<ul>
<li>关键类 :
<ul>
<li>JSON.java: 整个库的门面（Facade），提供了最常用、最便捷的静态方法，如 toJSONString() (序列化), parseObject() (反序列化为对象), parseArray() (反序列化为数组)。通常它是用户最先接触到的类。</li>
<li>JSONObject.java: 继承自java.util.HashMap，用于表示 JSON 对象结构（ {key: value} ）。</li>
<li>JSONArray.java: 继承自java.util.ArrayList，用于表示 JSON 数组结构 ( [value1, value2] )。</li>
</ul> </li>
</ul>
<p><strong>com.alibaba.fastjson.serializer (序列化模块)</strong></p>
<p>此模块负责将 Java 对象转换为 JSON 格式的字符串</p>
<ul>
<li>关键类 :
<ul>
<li>JSONSerializer.java: 序列化的核心调度器。它维护了序列化的上下文信息，如对象引用、循环依赖检测、特性（ SerializerFeature ）开关等，并驱动整个序列化过程。</li>
<li>SerializeWriter.java: 一个高度优化的 Writer 实现，专门用于生成 JSON 字符串。它内部使用 char[] 数组来拼接字符串，避免了 String 的不可变性带来的性能损耗，<strong>是 Fastjson 高性能写入的关键</strong>。</li>
<li>JavaBeanSerializer.java: 默认的 JavaBean 序列化器。在未启用 ASM 优化时，它通过<strong>反射获取对象的属性</strong>（ getter 方法）并将其序列化。</li>
<li>ASMSerializerFactory.java: 性能优化的核心 。它使用 ASM 字节码技术在运行时动态生成序列化器类，这些类直接调用 getter 方法并操作SerializeWriter，避免了反射的性能开销。</li>
<li>ObjectSerializer.java: 序列化器接口。用户可以通过实现此接口来为特定类型提供自定义的序列化逻辑。</li>
<li>SerializeConfig.java: 序列化配置类。它维护了 Java 类型到&nbsp;ObjectSerializer&nbsp;的缓存。&nbsp;SerializeConfig.getGlobalInstance()&nbsp;提供了全局唯一的配置实例。</li>
<li>SerializerFeature.java: 序列化特性枚举。定义了各种序列化行为的开关，例如 WriteMapNullValue (输出 null 值的字段)、&nbsp;DisableCircularReferenceDetect&nbsp;(禁用循环引用检测) 等。</li>
</ul> </li>
</ul>
<p><strong>com.alibaba.fastjson.parser (反序列化模块)</strong></p>
<p>此模块负责将 JSON 格式的字符串解析为 Java 对象。</p>
<ul>
<li>关键类 :
<ul>
<li>DefaultJSONParser.java: 反序列化的核心调度器。它负责解析 JSON 字符串的整个过程，管理&nbsp;JSONLexer进行词法分析，并根据 Token (如 { , } , [ , ] , string , number 等)构建 Java 对象。</li>
<li>JSONLexer.java / JSONLexerBase.java: JSON 词法分析器。它负责扫描输入的 JSON 字符串，将其切割成一个个有意义的 Token ，供 DefaultJSONParser 使用。</li>
<li>JavaBeanDeserializer.java: 默认的 JavaBean 反序列化器。在未启用 ASM 优化时，它<strong>通过反射创建对象实例并设置其属性值。</strong></li>
<li>ASMDeserializerFactory.java: 与序列化类似，它<strong>动态生成反序列化器字节码</strong>，直接调用 setter 方法或直接对字段赋值，避免了反射。</li>
<li>ObjectDeserializer.java: 反序列化器接口。用户可以实现此接口来自定义特定类型的反序列化逻辑。</li>
<li>ParserConfig.java: 反序列化配置类。维护了 Java 类型到 ObjectDeserializer 缓存，并负责管理 ASM 生成的类的加载。</li>
<li>Feature.java: 反序列化特性枚举，用于控制解析行为。</li>
</ul> </li>
</ul>
<p><strong>com.alibaba.fastjson.annotation (注解模块)</strong></p>
<p>提供了一系列注解，允许用户通过声明式的方式精细地控制序列化和反序列化的行为。</p>
<ul>
<li>关键注解 :
<ul>
<li>@JSONField: 最核心的注解，可用于字段或方法上，用于自定义字段名、格式化、序列化/反序列化顺序、是否包含等。</li>
<li>@JSONType: 可用于类上，用于配置该类的序列化器、反序列化器、特性开关等。</li>
</ul> </li>
</ul>
<h1>3.2 项目结构小结</h1>
<p>Fastjson 框架在架构设计体现了“关注点分离”的原则，将序列化、反序列化、API、工具类等清晰地划分到不同的模块中。整个框架具有高度的可扩展性，用户可以通过&nbsp;ObjectSerializer&nbsp;/&nbsp;ObjectDeserializer接口和丰富的注解来满足各种复杂的定制化需求。</p>
<h1>四、核心源码分析</h1>
<p>为了更直观说明框架实现原理，本文对部分展示的源代码进行了删减，有些使用了伪代码，如需了解更多实现细节请读者阅读项目源码(https://github.com/alibaba/fastjson)</p>
<p>整体上Fastjson通过统一的门面API（JSON.toJSONString/parseObject）调用核心控制器（JSONSerializer/DefaultJSONParser），利用<strong>ASM字节码生成</strong>或<strong>反射机制</strong>，配合SerializeWriter/JSONLexer进行高效的Java对象与JSON字符串间<strong>双向转换</strong>，同时提供<strong>配置缓存、循环引用检测</strong>和<strong>AutoType安全防护</strong>等优化机制。下图为框架处理数据流：</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-e46406b14e">
</div>
<p>数据流</p>
<h1>4.1 序列化原理介绍</h1>
<p>序列化步骤主要包括：序列化器查找→JavaBean字段解析→字段值转换和JSON字符串构建等过程。下图为序列化处理时序图：</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-81b374241a">
</div>
<p>序列化时序图</p>
<p><strong>序列化入口与初始化</strong></p>
<p>使用JSON.toJSONString()入口，将person对象转换为JSON字符串。</p>
<pre><code>Person&nbsp;person =&nbsp;new&nbsp;Person();
String&nbsp;json =&nbsp;JSON.toJSONString(person);</code></pre>
<p>用户调用toJSONString方法进行对象序列化操作，JSON.java包含了多个toJSONString重载方法，共同完成核心类初始化：SerializeConfig，SerializeWriter，JSONSerializer。</p>
<pre><code>//用户不指定SerializeConfig,默认私有全局配置
public&nbsp;static&nbsp;String&nbsp;toJSONString(Object&nbsp;object, SerializeFilter[] filters,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializerFeature... features) {
&nbsp; &nbsp;return&nbsp;toJSONString(object,&nbsp;SerializeConfig.globalInstance, filters,&nbsp;null,&nbsp;DEFAULT_GENERATE_FEATURE, features);
}
public&nbsp;static&nbsp;String&nbsp;toJSONString(Object&nbsp;object,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializeConfig config,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializeFilter[] filters,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;String&nbsp;dateFormat,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int defaultFeatures,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializerFeature... features) {
&nbsp; &nbsp;&nbsp;SerializeWriter&nbsp;out =&nbsp;new&nbsp;SerializeWriter((Writer)&nbsp;null, defaultFeatures, features);
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;JSONSerializer serializer =&nbsp;new&nbsp;JSONSerializer(out);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//省略其他代码...
&nbsp; &nbsp; &nbsp; &nbsp; serializer.write(object); &nbsp;// 核心序列化调用
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;out.toString();
&nbsp; &nbsp; }&nbsp;finally&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; out.close();
&nbsp; &nbsp; }
}</code></pre>
<p><strong>序列化控制流程</strong></p>
<p><strong>JSONSerializer.write()核心逻辑</strong></p>
<p>write方法的逻辑比较简单，首先处理null值，然后根据类型查找序列器(ObjectSerializer)，最后将序列化逻辑委派给序列化器处理。</p>
<pre><code>public&nbsp;final&nbsp;void&nbsp;write(Object&nbsp;object) {
&nbsp; &nbsp;&nbsp;//如何序列化对象为null，直接写入"null"字符串
&nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; out.writeNull();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;Class&lt;?&gt; clazz =&nbsp;object.getClass();
&nbsp; &nbsp;&nbsp;ObjectSerializer&nbsp;writer =&nbsp;getObjectWriter(clazz); &nbsp;// 类型识别与序列化器选择
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; writer.write(this,&nbsp;object,&nbsp;null,&nbsp;null,&nbsp;0); &nbsp;// 委托给具体序列化器
&nbsp; &nbsp; }&nbsp;catch&nbsp;(IOException&nbsp;e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException(e.getMessage(), e);
&nbsp; &nbsp; }
}</code></pre>
<p><strong>类型识别与序列化器策略</strong></p>
<p>框架采用策略化模式将不同类型序列化逻辑封装成不同的序列化器：</p>
<ul>
<li>基础类型 : 使用专门的Codec（如StringCodec、IntegerCodec）</li>
<li>集合类型 : 使用ListSerializer、MapSerializer等</li>
<li>JavaBean : 使用JavaBeanSerializer或ASM动态生成的序列化器</li>
<li>枚举类型 : 使用EnumSerializer</li>
</ul>
<p>SerializeConfig.getObjectWriter方法负责序列化器查找工作：</p>
<pre><code>
public&nbsp;ObjectSerializer getObjectWriter(Class&lt;?&gt; clazz, boolean create) {
&nbsp; &nbsp;&nbsp;// 第一步：缓存查找
&nbsp; &nbsp; ObjectSerializer writer =&nbsp;get(clazz);
&nbsp; &nbsp;&nbsp;if&nbsp;(writer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;writer;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 第二步：SPI扩展加载（当前线程类加载器）
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(Object o : ServiceLoader.load(AutowiredObjectSerializer.class, classLoader)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!(o instanceof AutowiredObjectSerializer)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;continue;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AutowiredObjectSerializer autowired = (AutowiredObjectSerializer) o;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(Type forType : autowired.getAutowiredFor()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(forType, autowired);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }&nbsp;catch&nbsp;(ClassCastException ex) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// skip
&nbsp; &nbsp; }
&nbsp; &nbsp; writer =&nbsp;get(clazz);
&nbsp; &nbsp;&nbsp;if&nbsp;(writer ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 第三步：SPI扩展加载（JSON类加载器）
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;ClassLoader classLoader = JSON.class.getClassLoader();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(classLoader != Thread.currentThread().getContextClassLoader()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 重复SPI加载逻辑...
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 第四步：模块扩展
&nbsp; &nbsp;&nbsp;for&nbsp;(Module module : modules) {
&nbsp; &nbsp; &nbsp; &nbsp; writer = module.createSerializer(this, clazz);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(writer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;writer;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 第五步：内置类型匹配
&nbsp; &nbsp;&nbsp;if&nbsp;(writer ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; String className = clazz.getName();
&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; superClass;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(Map.class.isAssignableFrom(clazz)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer = MapSerializer.instance);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(List.class.isAssignableFrom(clazz)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer = ListSerializer.instance);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(Collection.class.isAssignableFrom(clazz)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer = CollectionCodec.instance);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(Date.class.isAssignableFrom(clazz)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer = DateCodec.instance);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(clazz.isEnum()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 枚举处理逻辑
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(clazz.isArray()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 数组处理逻辑
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 第六步：JavaBean序列化器创建
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(create) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writer = createJavaBeanSerializer(clazz);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;return&nbsp;writer;
}</code></pre>
<p><strong>JavaBean序列化处理</strong></p>
<p>JavaBeanSerializer的write方法实现了Java对象序列化处理核心逻辑：</p>
<p><strong>方法签名分析：</strong></p>
<pre><code>protected&nbsp;void&nbsp;write(JSONSerializer serializer,&nbsp;//JSON序列化器，提供序列化上下文和输出流
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;object,&nbsp;//待序列化的Java对象
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;fieldName,&nbsp;//字段名称，用于上下文追踪
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Type&nbsp;fieldType,&nbsp;//字段类型信息
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int features,&nbsp;//序列化特性标志位
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;boolean&nbsp;unwrapped&nbsp;//是否展开包装，用于嵌套对象处理
&nbsp; &nbsp; ) throws&nbsp;IOException</code></pre>
<p><strong>序列化流程概览：</strong></p>
<pre><code>// 1. 空值检查和循环引用处理
if&nbsp;(object&nbsp;==&nbsp;null) {
&nbsp; &nbsp;&nbsp;out.writeNull();
&nbsp; &nbsp;&nbsp;return;
}
if&nbsp;(writeReference(serializer,&nbsp;object, features)) {
&nbsp; &nbsp;&nbsp;return;
}
// 2. 字段序列化器选择
final&nbsp;FieldSerializer[] getters;
if&nbsp;(out.sortField) {
&nbsp; &nbsp; getters =&nbsp;this.sortedGetters;
}&nbsp;else&nbsp;{
&nbsp; &nbsp; getters =&nbsp;this.getters;
}
// 3. 上下文设置和格式判断
SerialContext parent = serializer.context;
if&nbsp;(!this.beanInfo.beanType.isEnum()) {
&nbsp; &nbsp; serializer.setContext(parent,&nbsp;object, fieldName,&nbsp;this.beanInfo.features, features);
}
// 4.遍历属性序列化器，完成属性序列化
for&nbsp;(int i =&nbsp;0; i &lt; getters.length; ++i) {
&nbsp; &nbsp; FieldSerializer fieldSerializer = getters[i];
&nbsp; &nbsp;&nbsp;// 获取属性值
&nbsp; &nbsp; Object propertyValue =&nbsp;this.processValue(serializer, fieldSerializer.fieldContext,&nbsp;object, fieldInfoName,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; propertyValue, features);
&nbsp; &nbsp;&nbsp;// 写入属性值 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; fieldSerializer.writeValue(serializer, propertyValue);
}</code></pre>
<p><strong>循环引用检测：</strong></p>
<p>JavaBeanSerializerwriteReference&nbsp;方法执行循环引用检测，Fastjson使用$ref占位符处理循环引用问题，防止对象循环引用造成解析查询栈溢出。</p>
<pre><code>public&nbsp;boolean&nbsp;writeReference(JSONSerializer serializer,&nbsp;Object&nbsp;object, int fieldFeatures) {
&nbsp; &nbsp;&nbsp;SerialContext&nbsp;context = serializer.context;
&nbsp; &nbsp; int mask =&nbsp;SerializerFeature.DisableCircularReferenceDetect.mask;
&nbsp; &nbsp;&nbsp;// 检查是否禁用循环引用检测
&nbsp; &nbsp;&nbsp;if&nbsp;(context ==&nbsp;null&nbsp;|| (context.features&nbsp;&amp; mask) !=&nbsp;0&nbsp;|| (fieldFeatures &amp; mask) !=&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 检查对象是否已存在于引用表中
&nbsp; &nbsp;&nbsp;if&nbsp;(serializer.references&nbsp;!=&nbsp;null&nbsp;&amp;&amp; serializer.references.containsKey(object)) {
&nbsp; &nbsp; &nbsp; &nbsp; serializer.writeReference(object); &nbsp;// 写入引用标记
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;true;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;return&nbsp;false;
}</code></pre>
<p><strong>上下文管理与引用追踪：</strong></p>
<p>序列化采用DFS(深度优先)算法遍历对象树，使用&nbsp;IdentityHashMap&lt;Object, SerialContext&gt; references&nbsp;来追踪对象引用：</p>
<ul>
<li>setContext: 建立序列化上下文，记录对象层次关系</li>
<li>containsReference: 检查对象是否已被序列化</li>
<li>popContext: 序列化完成后清理上下文</li>
</ul>
<pre><code>protected&nbsp;IdentityHashMap&lt;Object,&nbsp;SerialContext&gt; references &nbsp;=&nbsp;null;
protected&nbsp;SerialContext&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context;
//使用链表建立序列化上下文引用链，记录对象层次关系
public&nbsp;void&nbsp;setContext(SerialContext parent,&nbsp;Object&nbsp;object,&nbsp;Object&nbsp;fieldName, int features, int fieldFeatures) {
&nbsp; &nbsp;&nbsp;if&nbsp;(out.disableCircularReferenceDetect) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//构建当前上下文到parent上下文引用链
&nbsp; &nbsp;&nbsp;this.context&nbsp;=&nbsp;new&nbsp;SerialContext(parent,&nbsp;object, fieldName, features, fieldFeatures);
&nbsp; &nbsp;&nbsp;if&nbsp;(references ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; references =&nbsp;new&nbsp;IdentityHashMap&lt;Object,&nbsp;SerialContext&gt;();
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;this.references.put(object, context);
}
//检查对象是否已被序列化,防止重复序列化
public&nbsp;boolean&nbsp;containsReference(Object&nbsp;value) {
&nbsp; &nbsp;&nbsp;if&nbsp;(references ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;SerialContext&nbsp;refContext = references.get(value);
&nbsp; &nbsp;&nbsp;if&nbsp;(refContext ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;if&nbsp;(value ==&nbsp;Collections.emptyMap()) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;Object&nbsp;fieldName = refContext.fieldName;
&nbsp; &nbsp;&nbsp;return&nbsp;fieldName ==&nbsp;null&nbsp;|| fieldName&nbsp;instanceof&nbsp;Integer&nbsp;|| fieldName&nbsp;instanceof&nbsp;String;
}
//清理上下文，将当前序列化上下文指向父亲节点
public&nbsp;void&nbsp;popContext() {
&nbsp; &nbsp;&nbsp;if&nbsp;(context !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.context&nbsp;=&nbsp;this.context.parent;
&nbsp; &nbsp; }
}</code></pre>
<p><strong>字段值转换与序列化</strong></p>
<p><strong>FieldSerializer.writeValue()核心逻辑</strong></p>
<p>FieldSerializer&nbsp;的writeValue方法实现了字段值的序列化操作：</p>
<pre><code>public&nbsp;void&nbsp;writeValue(JSONSerializer serializer, Object propertyValue)&nbsp;throws&nbsp;Exception {
&nbsp; &nbsp;&nbsp;// 运行时类型识别
&nbsp; &nbsp; Class&lt;?&gt; runtimeFieldClass = propertyValue !=&nbsp;null&nbsp;?&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; propertyValue.getClass() :&nbsp;this.fieldInfo.fieldClass;
&nbsp; &nbsp;&nbsp;// 查找属性类型对应的序列化器
&nbsp; &nbsp;&nbsp;ObjectSerializer&nbsp;fieldSerializer&nbsp;=&nbsp;serializer.getObjectWriter(runtimeFieldClass);
&nbsp; &nbsp;&nbsp;// 处理特殊格式和注解
&nbsp; &nbsp;&nbsp;if&nbsp;(format !=&nbsp;null&nbsp;&amp;&amp; !(fieldSerializer&nbsp;instanceof&nbsp;DoubleSerializer)) {
&nbsp; &nbsp; &nbsp; &nbsp; serializer.writeWithFormat(propertyValue, format);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 委托给具体序列化器处理
&nbsp; &nbsp; fieldSerializer.write(serializer, propertyValue, fieldInfo.name,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fieldInfo.fieldType, fieldFeatures);
}</code></pre>
<p><strong>不同类型的序列化策略</strong></p>
<p>基础类型序列化 ：</p>
<ul>
<li>直接调用SerializeWriter的对应方法（writeInt、writeString等）</li>
</ul>
<p>复杂对象序列化 ：</p>
<ul>
<li>递归调用JSONSerializer.write()方法</li>
<li>维护序列化上下文和引用关系</li>
<li>应用过滤器和特性配置</li>
</ul>
<p>ASM定制化序列化器加速，下文会进行详细讲解。</p>
<ul>
<li>为序列化的类动态生成定制化的序列化器，避免反射调用开销</li>
</ul>
<p><strong>JSON字符串构建</strong></p>
<p>SerializeWriter.java采用线程本地缓冲机制，提供高效的字符串构建：</p>
<pre><code>//用于存储存JSON字符串
private&nbsp;final&nbsp;static&nbsp;ThreadLocal&lt;char[]&gt; bufLocal &nbsp; &nbsp; &nbsp; &nbsp; =&nbsp;new&nbsp;ThreadLocal&lt;char[]&gt;();
//将字符串转换为UTF-8字节数组
private&nbsp;final&nbsp;static&nbsp;ThreadLocal&lt;byte[]&gt; bytesBufLocal &nbsp; &nbsp;=&nbsp;new&nbsp;ThreadLocal&lt;byte[]&gt;();</code></pre>
<ul>
<li>字符缓冲区 : 线程本地char[]数组减少内存分配，避免频繁创建临时数组对象。</li>
<li>动态扩容 : 根据内容长度自动调整缓冲区大小。</li>
</ul>
<p>bufLocal初始化创建2048字符的缓冲区，回收阶段当缓冲区大小不超过 BUFFER_THRESHOLD （128KB）时，将其放回ThreadLocal缓存，超过阈值的大缓冲区不缓存，避免内存占用过大。</p>
<p>bytesBufLocal专门用于UTF-8编码转换过程，初始缓冲区大小：8KB（1024 * 8），根据字符数量估算所需字节数（字符数 × 3），只有不超过 BUFFER_THRESHOLD 的缓冲区才会被缓存。</p>
<h1>4.2 序列化小结</h1>
<p>Fastjson通过JSON.toJSONString()门面API调用JSONSerializer控制器，利用ASM字节码生成的高性能序列化器或反射机制遍历Java对象字段，配合SerializeWriter将字段名和值逐步写入缓冲区构建JSON字符串。</p>
<h1>4.3 反序列化流程</h1>
<p>虽然“序列化”与“反序列化”在概念上是对偶的(Serialize ↔ Deserialize)，但在实现层面并不严格对偶，反序列化实现明显比序列化复杂。核心步骤包括：反序列化器查找→ 反序列流程控制→词法分析器（Tokenizer） → 安全检查→反射/ASM 字段填充等，下图为处理时序图：</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-675327763a">
</div>
<p><strong>反序列化入口与反序列化器选择</strong></p>
<p>反序列化从&nbsp;JSON.java的parseObject方法开始：</p>
<pre><code>// JSON.java - 反序列化入口
public&nbsp;static&nbsp;&lt;T&gt; T&nbsp;parseObject(String text, Class&lt;T&gt; clazz,&nbsp;int&nbsp;features)&nbsp;{
&nbsp; &nbsp;&nbsp;if&nbsp;(text ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;DefaultJSONParser&nbsp;parser&nbsp;=&nbsp;new&nbsp;DefaultJSONParser(text, ParserConfig.getGlobalInstance(), features);
&nbsp; &nbsp;&nbsp;T&nbsp;value&nbsp;=&nbsp;(T) parser.parseObject(clazz);
&nbsp; &nbsp; parser.handleResovleTask(value);
&nbsp; &nbsp; parser.close();
&nbsp; &nbsp;&nbsp;return&nbsp;value;
}</code></pre>
<p><strong>查找反序列化器</strong></p>
<p><strong>在 DefaultJSONParser.java 中选择合适的反序列化器：</strong></p>
<pre><code>// DefaultJSONParser.java - 反序列化器选择
public&nbsp;&lt;T&gt; T&nbsp;parseObject(Type&nbsp;type,&nbsp;Object&nbsp;fieldName) {
&nbsp; &nbsp; int token = lexer.token();
&nbsp; &nbsp;&nbsp;if&nbsp;(token ==&nbsp;JSONToken.NULL) {
&nbsp; &nbsp; &nbsp; &nbsp; lexer.nextToken();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T)&nbsp;TypeUtils.optionalEmpty(type);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//从缓存中查找反序列化器
&nbsp; &nbsp;&nbsp;ObjectDeserializer&nbsp;deserializer = config.getDeserializer(type);
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(deserializer.getClass() ==&nbsp;JavaBeanDeserializer.class) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T) ((JavaBeanDeserializer) deserializer).deserialze(this,&nbsp;type, fieldName,&nbsp;0);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T) deserializer.deserialze(this,&nbsp;type, fieldName);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }&nbsp;catch&nbsp;(JSONException e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;e;
&nbsp; &nbsp; }&nbsp;catch&nbsp;(Throwable&nbsp;e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException(e.getMessage(), e);
&nbsp; &nbsp; }
}</code></pre>
<p><strong>ParserConfig.java&nbsp;负责获取对应类型的反序列化器：</strong></p>
<pre><code>// ParserConfig.java - 反序列化器获取
public&nbsp;ObjectDeserializer&nbsp;getDeserializer(Type&nbsp;type) {
&nbsp; &nbsp;&nbsp;ObjectDeserializer&nbsp;deserializer =&nbsp;this.deserializers.get(type);
&nbsp; &nbsp;&nbsp;if&nbsp;(deserializer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;deserializer;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//通过Class查找
&nbsp; &nbsp;&nbsp;if&nbsp;(type&nbsp;instanceof&nbsp;Class&lt;?&gt;) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;getDeserializer((Class&lt;?&gt;)&nbsp;type,&nbsp;type);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//通过泛型参数查找
&nbsp; &nbsp;&nbsp;if&nbsp;(type&nbsp;instanceof&nbsp;ParameterizedType) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Type&nbsp;rawType = ((ParameterizedType)&nbsp;type).getRawType();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(rawType&nbsp;instanceof&nbsp;Class&lt;?&gt;) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;getDeserializer((Class&lt;?&gt;) rawType,&nbsp;type);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;getDeserializer(rawType);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;return&nbsp;JavaObjectDeserializer.instance;
}</code></pre>
<p><strong>反序列化控制流程</strong></p>
<p>JavaBeanDeserializer.java&nbsp;的deserialze实现了反序列化主要处理流程。</p>
<pre><code>// JavaBeanDeserializer.java - 类型识别与字段匹配
public&nbsp;&lt;T&gt; T&nbsp;deserialze(DefaultJSONParser parser, Type&nbsp;type,&nbsp;Object&nbsp;fieldName, int features, int[] setFlags) {
&nbsp; &nbsp;&nbsp;// 1.特殊类型快速处理
&nbsp; &nbsp;&nbsp;if&nbsp;(type&nbsp;==&nbsp;JSON.class&nbsp;||&nbsp;type&nbsp;==&nbsp;JSONObject.class) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T) parser.parse();
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//2.初始化核心组件
&nbsp; &nbsp; final&nbsp;JSONLexer lexer = parser.lexer;
&nbsp; &nbsp;&nbsp;//3.反序列化上下文管理
&nbsp; &nbsp;&nbsp;ParseContext&nbsp;context = parser.getContext();
&nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;!=&nbsp;null&nbsp;&amp;&amp; context !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;context = context.parent;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;ParseContext&nbsp;childContext =&nbsp;null;
&nbsp; &nbsp;&nbsp;//保存解析后字段值
&nbsp; &nbsp;&nbsp;Map&lt;String,&nbsp;Object&gt; fieldValues =&nbsp;null;
&nbsp; &nbsp;&nbsp;// JSON关键字分支预处理
&nbsp; &nbsp;&nbsp;if&nbsp;(token ==&nbsp;JSONToken.RBRACE) {
&nbsp; &nbsp; &nbsp; &nbsp; lexer.nextToken(JSONToken.COMMA);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;object&nbsp;=&nbsp;createInstance(parser,&nbsp;type);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T)&nbsp;object;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//处理其他JSON关键字
&nbsp; &nbsp; ...
&nbsp; &nbsp;&nbsp;//4.字段解析主循环
&nbsp; &nbsp;&nbsp;for&nbsp;(int fieldIndex =&nbsp;0, notMatchCount =&nbsp;0;; fieldIndex++) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;boolean&nbsp;customDeserializer =&nbsp;false;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//这是一个性能优化的设计，通过预排序和索引访问来提高字段匹配的效率，
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//通常情况下JSON串按字段定义顺序排列，因此能快速命中
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldIndex &lt; sortedFieldDeserializers.length&nbsp;&amp;&amp; notMatchCount &lt;&nbsp;16) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldDeserializer = sortedFieldDeserializers[fieldIndex];
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldInfo = fieldDeserializer.fieldInfo;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldClass = fieldInfo.fieldClass;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldAnnotation = fieldInfo.getAnnotation();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldAnnotation !=&nbsp;null&nbsp;&amp;&amp; fieldDeserializer&nbsp;instanceof&nbsp;DefaultFieldDeserializer) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; customDeserializer = ((DefaultFieldDeserializer) fieldDeserializer).customDeserilizer;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Object&nbsp;fieldValue =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if&nbsp;(fieldDeserializer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char[] name_chars = fieldInfo.name_chars;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//指定了自定义发序列化器，后续使用自定义序列化器处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(customDeserializer &amp;&amp; lexer.matchField(name_chars)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchField =&nbsp;true;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 基本类型快速路径匹配
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}&nbsp;else&nbsp;if&nbsp;(fieldClass == int.class&nbsp;|| fieldClass ==&nbsp;Integer.class) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//词法分析,解析int值
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int intVal = lexer.scanFieldInt(name_chars);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(intVal ==&nbsp;0&nbsp;&amp;&amp; lexer.matchStat&nbsp;==&nbsp;JSONLexer.VALUE_NULL) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldValue =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldValue = intVal;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(lexer.matchStat&nbsp;&gt;&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchField =&nbsp;true;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valueParsed =&nbsp;true;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(lexer.matchStat&nbsp;==&nbsp;JSONLexer.NOT_MATCH_NAME) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//增加计算，记录未命中次数以调整匹配策略
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notMatchCount++;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;continue;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}&nbsp;else&nbsp;if(...){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//省略其他基础类型处理 &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 快速匹配失败，动态扫描字段名,通过符号表优化:返回的字符串可能是符号表中的缓存实例
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if&nbsp;(!matchField) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key = lexer.scanSymbol(parser.symbolTable);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// $ref 引用处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;("$ref"&nbsp;== key &amp;&amp; context !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;handleReferenceResolution(lexer, parser, context)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// @type 类型处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;((typeKey !=&nbsp;null&nbsp;&amp;&amp; typeKey.equals(key))
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ||&nbsp;JSON.DEFAULT_TYPE_KEY&nbsp;== key) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//AutoType安全检查
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; config.checkAutoType(typeName, expectClass, lexer.getFeatures());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;handleTypeNameResolution(lexer, parser, config, beanInfo,&nbsp;type, fieldName);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 5.如果对象为空，则创建对象实例
&nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;==&nbsp;null&nbsp;&amp;&amp; fieldInfo ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;object&nbsp;=&nbsp;createInstance(parser,&nbsp;type);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//6. 字段值设置
&nbsp; &nbsp;&nbsp;for&nbsp;(Map.Entry&lt;String,&nbsp;Object&gt; entry : fieldValues.entrySet()) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;FieldDeserializer&nbsp;fieldDeserializer =&nbsp;getFieldDeserializer(entry.getKey());
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldDeserializer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldDeserializer.setValue(object, entry.getValue());
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp;&nbsp;return&nbsp;(T)&nbsp;object;
}</code></pre>
<p><strong>字符串解析阶段（词法分析）</strong></p>
<p>JSONLexerBase内部维护词法解析状态机，实现词法分析核心逻辑，下面展示了Integer值类型处理源码：</p>
<pre><code>&nbsp; &nbsp;&nbsp;public&nbsp;int scanFieldInt(char[] fieldName) {
&nbsp; &nbsp; &nbsp; &nbsp; matchStat = UNKNOWN;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 1. 字段名匹配阶段
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!charArrayCompare(fieldName)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH_NAME;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; int offset = fieldName.length;
&nbsp; &nbsp; &nbsp; &nbsp; char chLocal = charAt(bp + (offset++));
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 2. 负号处理
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;boolean negative = chLocal ==&nbsp;'-';
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(negative) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chLocal = charAt(bp + (offset++));
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 3. 数字解析核心算法
&nbsp; &nbsp; &nbsp; &nbsp; int value;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal &gt;=&nbsp;'0'&nbsp;&amp;&amp; chLocal &lt;=&nbsp;'9') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = chLocal -&nbsp;'0';
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(;;) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chLocal = charAt(bp + (offset++));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal &gt;=&nbsp;'0'&nbsp;&amp;&amp; chLocal &lt;=&nbsp;'9') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = value *&nbsp;10&nbsp;+ (chLocal -&nbsp;'0');// 十进制累加
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(chLocal ==&nbsp;'.') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;&nbsp;// 拒绝浮点数
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 4. 溢出检测
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(value &lt;&nbsp;0&nbsp;//
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || offset &gt;&nbsp;11&nbsp;+&nbsp;3&nbsp;+ fieldName.length) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(value != Integer.MIN_VALUE&nbsp;//
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || offset !=&nbsp;17&nbsp;//
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || !negative) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 5. JSON 结束符处理
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal ==&nbsp;',') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += offset;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.ch =&nbsp;this.charAt(bp);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = VALUE;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.COMMA;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;negative ? -value : value;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal ==&nbsp;'}') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// ... 处理对象结束和嵌套结构
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chLocal = charAt(bp + (offset++));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal ==&nbsp;',') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.COMMA;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += offset;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.ch =&nbsp;this.charAt(bp);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(chLocal ==&nbsp;']') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.RBRACKET;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += offset;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.ch =&nbsp;this.charAt(bp);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(chLocal ==&nbsp;'}') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.RBRACE;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += offset;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.ch =&nbsp;this.charAt(bp);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(chLocal == EOI) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.EOF;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += (offset -&nbsp;1);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch = EOI;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = END;
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;negative ? -value : value;
&nbsp; &nbsp; }</code></pre>
<p><strong>类型安全检查（AutoType检查）</strong></p>
<p>ParserConfig.java&nbsp;中的checkAutoType方法对反序列化类型做黑白名单检查。</p>
<pre><code>// ParserConfig.java - AutoType安全检查
public&nbsp;Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass,&nbsp;int&nbsp;features) {
&nbsp; &nbsp;&nbsp;if&nbsp;(typeName ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;if&nbsp;(typeName.length() &gt;=&nbsp;192&nbsp;|| typeName.length() &lt;&nbsp;3) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("autoType is not support. "&nbsp;+ typeName);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;String&nbsp;className&nbsp;=&nbsp;typeName.replace('$',&nbsp;'.');
&nbsp; &nbsp; Class&lt;?&gt; clazz =&nbsp;null;
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;final&nbsp;long&nbsp;BASIC&nbsp;=&nbsp;0xcbf29ce484222325L;
&nbsp; &nbsp;&nbsp;final&nbsp;long&nbsp;PRIME&nbsp;=&nbsp;0x100000001b3L;
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;final&nbsp;long&nbsp;h1&nbsp;=&nbsp;(BASIC ^ className.charAt(0)) * PRIME;
&nbsp; &nbsp;&nbsp;// hash code编码匹配性能优化
&nbsp; &nbsp;&nbsp;if&nbsp;(h1 ==&nbsp;0xaf64164c86024f1aL) {&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("autoType is not support. "&nbsp;+ typeName);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;if&nbsp;((h1 ^ className.charAt(className.length() -&nbsp;1)) * PRIME ==&nbsp;0x9198507b5af98f0L) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("autoType is not support. "&nbsp;+ typeName);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;final&nbsp;long&nbsp;h3&nbsp;=&nbsp;(((((BASIC ^ className.charAt(0))&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * PRIME)&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ className.charAt(1))&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * PRIME)&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ className.charAt(2))&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * PRIME;
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;if&nbsp;(autoTypeSupport || expectClass !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;long&nbsp;hash&nbsp;=&nbsp;h3;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;3; i &lt; className.length(); ++i) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash ^= className.charAt(i);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash *= PRIME;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(Arrays.binarySearch(denyHashCodes, hash) &gt;=&nbsp;0&nbsp;&amp;&amp; TypeUtils.getClassFromMapping(typeName) ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("autoType is not support. "&nbsp;+ typeName);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(Arrays.binarySearch(acceptHashCodes, hash) &gt;=&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clazz = TypeUtils.loadClass(typeName, defaultClassLoader,&nbsp;false);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(clazz !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;clazz;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// ... 更多安全检查逻辑
&nbsp; &nbsp;&nbsp;return&nbsp;clazz;
}</code></pre>
<p><strong>对象实例化过程</strong></p>
<p><strong>JavaBeanDeserializer.java中的createInstance方法创建对象实例：</strong></p>
<pre><code>// JavaBeanDeserializer.java - 对象实例化
protected&nbsp;Object&nbsp;createInstance(DefaultJSONParser parser, Type&nbsp;type) {
&nbsp; &nbsp;&nbsp;if&nbsp;(type&nbsp;instanceof&nbsp;Class) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(clazz.isInterface()) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 接口类型使用Java反射创建实例
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Class&lt;?&gt; clazz = (Class&lt;?&gt;)&nbsp;type;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ClassLoader&nbsp;loader =&nbsp;Thread.currentThread().getContextClassLoader();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final&nbsp;JSONObject&nbsp;obj =&nbsp;new&nbsp;JSONObject();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;proxy =&nbsp;Proxy.newProxyInstance(loader,&nbsp;new&nbsp;Class&lt;?&gt;[] { clazz }, obj);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;proxy;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;if&nbsp;(beanInfo.defaultConstructor&nbsp;==&nbsp;null&nbsp;&amp;&amp; beanInfo.factoryMethod&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;Object&nbsp;object;
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp;&nbsp;//通过构造器创建实例
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Constructor&lt;?&gt; constructor = beanInfo.defaultConstructor;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(beanInfo.defaultConstructorParameterSize&nbsp;==&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;object&nbsp;= constructor.newInstance();
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ParseContext&nbsp;context = parser.getContext();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(context ==&nbsp;null&nbsp;|| context.object&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("can't create non-static inner class instance.");
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final&nbsp;Class&lt;?&gt; enclosingClass = constructor.getDeclaringClass().getEnclosingClass();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;object&nbsp;= constructor.newInstance(context.object);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }&nbsp;catch&nbsp;(JSONException e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;e;
&nbsp; &nbsp; }&nbsp;catch&nbsp;(Exception&nbsp;e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("create instance error, class "&nbsp;+ clazz.getName(), e);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;return&nbsp;object;
}</code></pre>
<p><strong>FieldDeserializer.java中的setValue方法通过反射实现字段设置：</strong></p>
<pre><code>// FieldDeserializer.java - 属性赋值的核心实现
public&nbsp;void&nbsp;setValue(Object&nbsp;object,&nbsp;Object&nbsp;value) {
&nbsp; &nbsp;&nbsp;if&nbsp;(value ==&nbsp;null&nbsp;&amp;&amp; fieldInfo.fieldClass.isPrimitive()) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(fieldInfo.fieldClass&nbsp;==&nbsp;String.class
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; fieldInfo.format&nbsp;!=&nbsp;null
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; fieldInfo.format.equals("trim")) {
&nbsp; &nbsp; &nbsp; &nbsp; value = ((String) value).trim();
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Method&nbsp;method = fieldInfo.method;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(method !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldInfo.getOnly) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 处理只读属性的特殊情况
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldInfo.fieldClass&nbsp;==&nbsp;AtomicInteger.class) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;AtomicInteger&nbsp;atomic = (AtomicInteger) method.invoke(object);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(atomic !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atomic.set(((AtomicInteger) value).get());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(Map.class.isAssignableFrom(method.getReturnType())) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Map&nbsp;map = (Map) method.invoke(object);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(map !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map.putAll((Map) value);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Collection&nbsp;collection = (Collection) method.invoke(object);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(collection !=&nbsp;null&nbsp;&amp;&amp; value !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collection.clear();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collection.addAll((Collection) value);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 通过setter方法赋值
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; method.invoke(object, value);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 通过字段直接赋值
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final&nbsp;Field&nbsp;field = fieldInfo.field;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(field !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; field.set(object, value);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }&nbsp;catch&nbsp;(Exception&nbsp;e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("set property error, "&nbsp;+ clazz.getName() +&nbsp;"#"&nbsp;+ fieldInfo.name, e);
&nbsp; &nbsp; }
}</code></pre>
<h1>4.4 反序列化小结</h1>
<p>Fastjson通过JSON.parseObject()门面API调用DefaultJSONParser控制器，利用JSONLexer进行词法分析解析JSON字符串，经过AutoType安全检查后使用ASM字节码生成动态反序列化器或反射机制创建Java对象实例并逐字段赋值。</p>
<h1>五、特性讲解</h1>
<h1>5.1 ASM性能优化</h1>
<p>ASM 是 fastjson 类似于 JIT，在运行时把「反射调用」翻译成「直接字段访问 + 方法调用」的字节码，从而把序列化/反序列化性能提升 20% 以上，当然随着JVM对反射性能的优化性能差正在逐渐被缩小。下图是作者使用工具类读取的动态序列化/反序列化器源码片段。</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-a1669be5d0">
</div>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-136f97bda8">
</div>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-82b4e0207e">
</div>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-b9069ddcfd">
</div>
<h1>5.2&nbsp; AutoType机制</h1>
<p>AutoType是 fastjson 的“动态多态还原”方案:</p>
<p>序列化时把具体子类名字写进&nbsp;"@type"，反序列化时先加载类 → 再调 setter → 完成还原。</p>
<p>&nbsp;速度上“指针引用”即可定位序列化器，功能上靠&nbsp;<a href="https://my.oschina.net/fanren1919" target="_blank">@type</a>&nbsp;字段把被擦除的泛型/接口/父类重新映射回具体实现。</p>
<p>在未开启AutoType机制情况下，在将store对象序列化成JSON串后，再反序列化为对象时由于字段的类型为接口无法转换成具体的Dog类型示例；开启AutoType机制后，序列化时将类型一并写入到JSON串内，后续进行反序列化时可以根据这个类型还原成具体的类型实例。</p>
<pre><code>interface&nbsp;Animal&nbsp;{}
class&nbsp;Dog&nbsp;implements&nbsp;Animal&nbsp;{
&nbsp; &nbsp;&nbsp;private&nbsp;String&nbsp;name;
&nbsp; &nbsp;&nbsp;private&nbsp;double weight;
&nbsp; &nbsp;&nbsp;//省略getter,setter
}
class&nbsp;PetStore&nbsp;{
&nbsp; &nbsp;&nbsp;private&nbsp;Animal&nbsp;animal;
}
public&nbsp;static&nbsp;void&nbsp;main(String[] args) {
&nbsp; &nbsp;&nbsp;Animal&nbsp;dog =&nbsp;new&nbsp;Dog("dodi",&nbsp;12);
&nbsp; &nbsp;&nbsp;PetStore&nbsp;store =&nbsp;new&nbsp;PetStore(dog);
&nbsp; &nbsp;&nbsp;String&nbsp;jsonString =&nbsp;JSON.toJSONString(store);
&nbsp; &nbsp;&nbsp;PetStore&nbsp;petStore =&nbsp;JSON.parseObject(jsonString,&nbsp;PetStore.class);
&nbsp; &nbsp;&nbsp;Dog&nbsp;parsedDog = (Dog) petStore.getAnimal();
}</code></pre>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-0051358e13">
</div>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-6a93c6470b">
</div>
<pre><code>public&nbsp;static&nbsp;void&nbsp;main(String[] args) {
&nbsp; &nbsp;&nbsp;Animal&nbsp;dog =&nbsp;new&nbsp;Dog("dodi",&nbsp;12);
&nbsp; &nbsp;&nbsp;PetStore&nbsp;store =&nbsp;new&nbsp;PetStore(dog);
&nbsp; &nbsp;&nbsp;String&nbsp;jsonString =&nbsp;JSON.toJSONString(store,&nbsp;SerializerFeature.WriteClassName);
&nbsp; &nbsp;&nbsp;PetStore&nbsp;petStore =&nbsp;JSON.parseObject(jsonString,&nbsp;PetStore.class);
&nbsp; &nbsp;&nbsp;Dog&nbsp;parsedDog = (Dog) petStore.getAnimal();
}</code></pre>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-e17c314f91">
</div>
<p>AutoType 让 fastjson 在反序列化时根据&nbsp;<a href="https://my.oschina.net/fanren1919" target="_blank">@type</a>&nbsp;字段动态加载任意类，这一“便利”却成为攻击者远程代码执行的快捷通道：通过把JdbcRowSetImpl等 JNDI 敏感类写进 JSON，服务端在调用 setter 的瞬间就会向外部 LDAP/RMI 服务器拉取恶意字节码，完成 RCE；而官方长期依赖“黑名单”堵漏，导致 1.2.25→1.2.80 出现 L 描述符、Throwable 二次反序列化、内部类等连续绕过，形成“补丁-绕过-再补丁”的猫鼠游戏， 虽然在1.2.68 引入 safeMode 但为了兼容性需要使用者手动开启 ，而且实现也不够健壮，开启safeMode仍有利用代码漏洞绕过检查风险，后续版本对safeMode加固并对已知安全漏洞清零，直到最新1.2.83版本安全问题也不能说彻底解决。</p>
<h1>5.3 流式解析</h1>
<p>Fastjson 提供一套 Streaming API，核心类JSONReader&nbsp;/JSONWriter，行业内惯称「流式解析」或「增量解析」，主要用于处理JSON大文件解析。技术上流式解析采用“拉模式（pull parsing）”，底层维护 8 KB 滑动缓冲，词法分析器（Tokenizer）把字节流切成 token 流，语法状态机根据 token 类型驱动反序列化器（ObjectReader）即时产出 Java 对象，对象一旦交付给用户代码处理后，内部引用立即释放。这种方式内存中不会保存所有对象，对象处理完即被丢弃，因此可以处理数据量远大于内存的数据，而不会出现OOM。下面是使用流式解析的示例代码：</p>
<pre><code>// 依赖：com.alibaba:fastjson:1.2.83
try&nbsp;(JSONReader reader =&nbsp;new&nbsp;JSONReader(
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;new&nbsp;InputStreamReader(
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;new&nbsp;FileInputStream("huge-array.json"),&nbsp;StandardCharsets.UTF_8))) {
&nbsp; &nbsp; reader.startArray(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 告诉解析器：根节点是 []
&nbsp; &nbsp;&nbsp;while&nbsp;(reader.hasNext()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 拉取下一条
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Order&nbsp;order = reader.readObject(Order.class);&nbsp;// 瞬时对象
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;processOrder(order);//业务处理
&nbsp; &nbsp; &nbsp; &nbsp; orderRepository.save(order); &nbsp; &nbsp;&nbsp;// 立即落盘，内存即可回收
&nbsp; &nbsp; }
&nbsp; &nbsp; reader.endArray();
}</code></pre>
<h1>六、总结</h1>
<p>Fastjson核心特性在于高速序列化/反序列化，利用ASM在运行时生成字节码动态创建解析器，减少反射；AutoType字段支持多态，却带来反序列化RCE风险，建议关闭AutoType，开启safeMode。选型建议：在选择JSON序列化框架时对于非极端性能要求推荐Jackson，或者使用Fastjson2，其改用LambdaMetafactory替换ASM，性能再提升30%，默认关闭AutoType安全性有保证。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li>FastJson 反序列化漏洞原理分析（https://www.cnblogs.com/Only-xiaoxiao/p/17213248.html）</li>
<li>序列化与反序列化——FastJSON、Jackson、Gson性能测试（https://zhuanlan.zhihu.com/p/529342385）</li>
<li>FASTJSON 2 Autotype机制介绍（https://alibaba.github.io/fastjson2/autotype_cn.html）</li>
<li>&nbsp;</li>
</ul>
<h4>往期回顾</h4>
<p>1.&nbsp;用好 TTL Agent 不踩雷：避开内存泄露与CPU 100%两大核心坑｜得物技术</p>
<p>2.&nbsp;线程池ThreadPoolExecutor源码深度解析｜得物技术</p>
<p>3.&nbsp;基于浏览器扩展 API Mock 工具开发探索｜得物技术</p>
<p>4.&nbsp;破解gh-ost变更导致MySQL表膨胀之谜｜得物技术</p>
<p>5.&nbsp;MySQL单表为何别超2000万行？揭秘B+树与16KB页的生死博弈｜得物技术</p>
<h4>文 /剑九</h4>
<p>关注得物技术，每周更新技术干货</p>
<p>要是觉得文章对你有帮助的话，欢迎评论转发点赞～</p>
<p>未经得物技术许可严禁转载，否则依法追究法律责任。</p>]]>
    </description>
    <content:encoded><![CDATA[<h1>一、概述</h1>
<p>Fastjson 是阿里巴巴开源的高性能 JSON 序列化处理库，其主要以处理<strong>小数据</strong>时速度最快而著称，功能全面。Fastjson1.X版本目前已停止维护，被Fastjson2.X代替，但1.X版本国内被广泛使用，通过学习其技术架构，剖析架构上优缺点，对技术人员提升软件设计工程实践能力很有价值。</p>
<p>首先我们对“序列化 / 反序列化”概念上建立直观认识，把Java对象转化为JSON格式的字符串的过程叫做<strong>序列化</strong>操作，反之则叫<strong>反序列化</strong>。如果把“序列化 / 反序列化”放到整个计算机系统的坐标系里，可以把它看成一次数据的“跨边界搬家”。</p>
<p>对象在“内存世界”里活得很好，但只要一离开进程地址空间（网络、磁盘、数据库、浏览器、异构语言），就必须先打成包裹（序列化），到对岸再拆包裹（反序列化）。</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-7928e1f6ec">
</div>
<h1>二、核心模块架构</h1>
<p>从高层次视图看Fastjson框架的结构，主要可以分为<strong>用户接口层、配置管理层、序列化引擎、反序列化引擎和安全防护层</strong>。其中<strong>用户接口</strong>提供了门面类用户编码直接与门面类交互，降低使用复杂度；<strong>配置管理层</strong>允许用户对框架行为进行配置；<strong>序列化引擎</strong>是序列化操作的核心实现；<strong>反序列引擎</strong>是反序列化操作的核心实现；<strong>安全模块</strong>解决框架安全问题，允许用户针对安全问题设置黑白名单等安全检查功能。下图为Fastjson模块关系图：</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-f5b2666f10">
</div>
<p>模块关系图</p>
<h1>三、项目结构</h1>
<pre><code>com.alibaba.fastjson/
├── JSON.java &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 核心入口类
├── annotation/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 注解定义
├── asm/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# ASM字节码精简库
├── parser/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 解析器模块
│ &nbsp; ├── DefaultJSONParser.java &nbsp;# 默认JSON解析器
│ &nbsp; ├── JSONLexer.java &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 词法分析器接口
│ &nbsp; ├── JSONScanner.java &nbsp; &nbsp; &nbsp; &nbsp;# 词法分析器实现
│ &nbsp; └── deserializer/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# 反序列化器
├── serializer/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 序列化器模块
│ &nbsp; ├── JSONSerializer.java &nbsp; &nbsp;&nbsp;# JSON序列化器
│ &nbsp; ├── SerializeConfig.java &nbsp; &nbsp;# 序列化配置
│ &nbsp; └── ObjectSerializer.java &nbsp;&nbsp;# 对象序列化器接口
├── spi/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# SPI扩展机制
├── support/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;# 框架支持
└── util/ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;# 工具类</code></pre>
<h1>3.1 项目结构说明</h1>
<p>主要可以划分为以下几个核心模块（包）：</p>
<p><strong>com.alibaba.fastjson (核心 API 与数据结构)</strong></p>
<ul>
<li>关键类 :
<ul>
<li>JSON.java: 整个库的门面（Facade），提供了最常用、最便捷的静态方法，如 toJSONString() (序列化), parseObject() (反序列化为对象), parseArray() (反序列化为数组)。通常它是用户最先接触到的类。</li>
<li>JSONObject.java: 继承自java.util.HashMap，用于表示 JSON 对象结构（ {key: value} ）。</li>
<li>JSONArray.java: 继承自java.util.ArrayList，用于表示 JSON 数组结构 ( [value1, value2] )。</li>
</ul> </li>
</ul>
<p><strong>com.alibaba.fastjson.serializer (序列化模块)</strong></p>
<p>此模块负责将 Java 对象转换为 JSON 格式的字符串</p>
<ul>
<li>关键类 :
<ul>
<li>JSONSerializer.java: 序列化的核心调度器。它维护了序列化的上下文信息，如对象引用、循环依赖检测、特性（ SerializerFeature ）开关等，并驱动整个序列化过程。</li>
<li>SerializeWriter.java: 一个高度优化的 Writer 实现，专门用于生成 JSON 字符串。它内部使用 char[] 数组来拼接字符串，避免了 String 的不可变性带来的性能损耗，<strong>是 Fastjson 高性能写入的关键</strong>。</li>
<li>JavaBeanSerializer.java: 默认的 JavaBean 序列化器。在未启用 ASM 优化时，它通过<strong>反射获取对象的属性</strong>（ getter 方法）并将其序列化。</li>
<li>ASMSerializerFactory.java: 性能优化的核心 。它使用 ASM 字节码技术在运行时动态生成序列化器类，这些类直接调用 getter 方法并操作SerializeWriter，避免了反射的性能开销。</li>
<li>ObjectSerializer.java: 序列化器接口。用户可以通过实现此接口来为特定类型提供自定义的序列化逻辑。</li>
<li>SerializeConfig.java: 序列化配置类。它维护了 Java 类型到&nbsp;ObjectSerializer&nbsp;的缓存。&nbsp;SerializeConfig.getGlobalInstance()&nbsp;提供了全局唯一的配置实例。</li>
<li>SerializerFeature.java: 序列化特性枚举。定义了各种序列化行为的开关，例如 WriteMapNullValue (输出 null 值的字段)、&nbsp;DisableCircularReferenceDetect&nbsp;(禁用循环引用检测) 等。</li>
</ul> </li>
</ul>
<p><strong>com.alibaba.fastjson.parser (反序列化模块)</strong></p>
<p>此模块负责将 JSON 格式的字符串解析为 Java 对象。</p>
<ul>
<li>关键类 :
<ul>
<li>DefaultJSONParser.java: 反序列化的核心调度器。它负责解析 JSON 字符串的整个过程，管理&nbsp;JSONLexer进行词法分析，并根据 Token (如 { , } , [ , ] , string , number 等)构建 Java 对象。</li>
<li>JSONLexer.java / JSONLexerBase.java: JSON 词法分析器。它负责扫描输入的 JSON 字符串，将其切割成一个个有意义的 Token ，供 DefaultJSONParser 使用。</li>
<li>JavaBeanDeserializer.java: 默认的 JavaBean 反序列化器。在未启用 ASM 优化时，它<strong>通过反射创建对象实例并设置其属性值。</strong></li>
<li>ASMDeserializerFactory.java: 与序列化类似，它<strong>动态生成反序列化器字节码</strong>，直接调用 setter 方法或直接对字段赋值，避免了反射。</li>
<li>ObjectDeserializer.java: 反序列化器接口。用户可以实现此接口来自定义特定类型的反序列化逻辑。</li>
<li>ParserConfig.java: 反序列化配置类。维护了 Java 类型到 ObjectDeserializer 缓存，并负责管理 ASM 生成的类的加载。</li>
<li>Feature.java: 反序列化特性枚举，用于控制解析行为。</li>
</ul> </li>
</ul>
<p><strong>com.alibaba.fastjson.annotation (注解模块)</strong></p>
<p>提供了一系列注解，允许用户通过声明式的方式精细地控制序列化和反序列化的行为。</p>
<ul>
<li>关键注解 :
<ul>
<li>@JSONField: 最核心的注解，可用于字段或方法上，用于自定义字段名、格式化、序列化/反序列化顺序、是否包含等。</li>
<li>@JSONType: 可用于类上，用于配置该类的序列化器、反序列化器、特性开关等。</li>
</ul> </li>
</ul>
<h1>3.2 项目结构小结</h1>
<p>Fastjson 框架在架构设计体现了“关注点分离”的原则，将序列化、反序列化、API、工具类等清晰地划分到不同的模块中。整个框架具有高度的可扩展性，用户可以通过&nbsp;ObjectSerializer&nbsp;/&nbsp;ObjectDeserializer接口和丰富的注解来满足各种复杂的定制化需求。</p>
<h1>四、核心源码分析</h1>
<p>为了更直观说明框架实现原理，本文对部分展示的源代码进行了删减，有些使用了伪代码，如需了解更多实现细节请读者阅读项目源码(https://github.com/alibaba/fastjson)</p>
<p>整体上Fastjson通过统一的门面API（JSON.toJSONString/parseObject）调用核心控制器（JSONSerializer/DefaultJSONParser），利用<strong>ASM字节码生成</strong>或<strong>反射机制</strong>，配合SerializeWriter/JSONLexer进行高效的Java对象与JSON字符串间<strong>双向转换</strong>，同时提供<strong>配置缓存、循环引用检测</strong>和<strong>AutoType安全防护</strong>等优化机制。下图为框架处理数据流：</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-e46406b14e">
</div>
<p>数据流</p>
<h1>4.1 序列化原理介绍</h1>
<p>序列化步骤主要包括：序列化器查找→JavaBean字段解析→字段值转换和JSON字符串构建等过程。下图为序列化处理时序图：</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-81b374241a">
</div>
<p>序列化时序图</p>
<p><strong>序列化入口与初始化</strong></p>
<p>使用JSON.toJSONString()入口，将person对象转换为JSON字符串。</p>
<pre><code>Person&nbsp;person =&nbsp;new&nbsp;Person();
String&nbsp;json =&nbsp;JSON.toJSONString(person);</code></pre>
<p>用户调用toJSONString方法进行对象序列化操作，JSON.java包含了多个toJSONString重载方法，共同完成核心类初始化：SerializeConfig，SerializeWriter，JSONSerializer。</p>
<pre><code>//用户不指定SerializeConfig,默认私有全局配置
public&nbsp;static&nbsp;String&nbsp;toJSONString(Object&nbsp;object, SerializeFilter[] filters,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializerFeature... features) {
&nbsp; &nbsp;return&nbsp;toJSONString(object,&nbsp;SerializeConfig.globalInstance, filters,&nbsp;null,&nbsp;DEFAULT_GENERATE_FEATURE, features);
}
public&nbsp;static&nbsp;String&nbsp;toJSONString(Object&nbsp;object,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializeConfig config,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializeFilter[] filters,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;String&nbsp;dateFormat,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int defaultFeatures,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; SerializerFeature... features) {
&nbsp; &nbsp;&nbsp;SerializeWriter&nbsp;out =&nbsp;new&nbsp;SerializeWriter((Writer)&nbsp;null, defaultFeatures, features);
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;JSONSerializer serializer =&nbsp;new&nbsp;JSONSerializer(out);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//省略其他代码...
&nbsp; &nbsp; &nbsp; &nbsp; serializer.write(object); &nbsp;// 核心序列化调用
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;out.toString();
&nbsp; &nbsp; }&nbsp;finally&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; out.close();
&nbsp; &nbsp; }
}</code></pre>
<p><strong>序列化控制流程</strong></p>
<p><strong>JSONSerializer.write()核心逻辑</strong></p>
<p>write方法的逻辑比较简单，首先处理null值，然后根据类型查找序列器(ObjectSerializer)，最后将序列化逻辑委派给序列化器处理。</p>
<pre><code>public&nbsp;final&nbsp;void&nbsp;write(Object&nbsp;object) {
&nbsp; &nbsp;&nbsp;//如何序列化对象为null，直接写入"null"字符串
&nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; out.writeNull();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;Class&lt;?&gt; clazz =&nbsp;object.getClass();
&nbsp; &nbsp;&nbsp;ObjectSerializer&nbsp;writer =&nbsp;getObjectWriter(clazz); &nbsp;// 类型识别与序列化器选择
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; writer.write(this,&nbsp;object,&nbsp;null,&nbsp;null,&nbsp;0); &nbsp;// 委托给具体序列化器
&nbsp; &nbsp; }&nbsp;catch&nbsp;(IOException&nbsp;e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException(e.getMessage(), e);
&nbsp; &nbsp; }
}</code></pre>
<p><strong>类型识别与序列化器策略</strong></p>
<p>框架采用策略化模式将不同类型序列化逻辑封装成不同的序列化器：</p>
<ul>
<li>基础类型 : 使用专门的Codec（如StringCodec、IntegerCodec）</li>
<li>集合类型 : 使用ListSerializer、MapSerializer等</li>
<li>JavaBean : 使用JavaBeanSerializer或ASM动态生成的序列化器</li>
<li>枚举类型 : 使用EnumSerializer</li>
</ul>
<p>SerializeConfig.getObjectWriter方法负责序列化器查找工作：</p>
<pre><code>
public&nbsp;ObjectSerializer getObjectWriter(Class&lt;?&gt; clazz, boolean create) {
&nbsp; &nbsp;&nbsp;// 第一步：缓存查找
&nbsp; &nbsp; ObjectSerializer writer =&nbsp;get(clazz);
&nbsp; &nbsp;&nbsp;if&nbsp;(writer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;writer;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 第二步：SPI扩展加载（当前线程类加载器）
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(Object o : ServiceLoader.load(AutowiredObjectSerializer.class, classLoader)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!(o instanceof AutowiredObjectSerializer)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;continue;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AutowiredObjectSerializer autowired = (AutowiredObjectSerializer) o;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(Type forType : autowired.getAutowiredFor()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(forType, autowired);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }&nbsp;catch&nbsp;(ClassCastException ex) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// skip
&nbsp; &nbsp; }
&nbsp; &nbsp; writer =&nbsp;get(clazz);
&nbsp; &nbsp;&nbsp;if&nbsp;(writer ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 第三步：SPI扩展加载（JSON类加载器）
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;ClassLoader classLoader = JSON.class.getClassLoader();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(classLoader != Thread.currentThread().getContextClassLoader()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 重复SPI加载逻辑...
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 第四步：模块扩展
&nbsp; &nbsp;&nbsp;for&nbsp;(Module module : modules) {
&nbsp; &nbsp; &nbsp; &nbsp; writer = module.createSerializer(this, clazz);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(writer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;writer;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 第五步：内置类型匹配
&nbsp; &nbsp;&nbsp;if&nbsp;(writer ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; String className = clazz.getName();
&nbsp; &nbsp; &nbsp; &nbsp; Class&lt;?&gt; superClass;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(Map.class.isAssignableFrom(clazz)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer = MapSerializer.instance);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(List.class.isAssignableFrom(clazz)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer = ListSerializer.instance);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(Collection.class.isAssignableFrom(clazz)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer = CollectionCodec.instance);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(Date.class.isAssignableFrom(clazz)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer = DateCodec.instance);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(clazz.isEnum()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 枚举处理逻辑
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(clazz.isArray()) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 数组处理逻辑
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 第六步：JavaBean序列化器创建
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(create) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; writer = createJavaBeanSerializer(clazz);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; put(clazz, writer);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;return&nbsp;writer;
}</code></pre>
<p><strong>JavaBean序列化处理</strong></p>
<p>JavaBeanSerializer的write方法实现了Java对象序列化处理核心逻辑：</p>
<p><strong>方法签名分析：</strong></p>
<pre><code>protected&nbsp;void&nbsp;write(JSONSerializer serializer,&nbsp;//JSON序列化器，提供序列化上下文和输出流
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;object,&nbsp;//待序列化的Java对象
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;fieldName,&nbsp;//字段名称，用于上下文追踪
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Type&nbsp;fieldType,&nbsp;//字段类型信息
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int features,&nbsp;//序列化特性标志位
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;boolean&nbsp;unwrapped&nbsp;//是否展开包装，用于嵌套对象处理
&nbsp; &nbsp; ) throws&nbsp;IOException</code></pre>
<p><strong>序列化流程概览：</strong></p>
<pre><code>// 1. 空值检查和循环引用处理
if&nbsp;(object&nbsp;==&nbsp;null) {
&nbsp; &nbsp;&nbsp;out.writeNull();
&nbsp; &nbsp;&nbsp;return;
}
if&nbsp;(writeReference(serializer,&nbsp;object, features)) {
&nbsp; &nbsp;&nbsp;return;
}
// 2. 字段序列化器选择
final&nbsp;FieldSerializer[] getters;
if&nbsp;(out.sortField) {
&nbsp; &nbsp; getters =&nbsp;this.sortedGetters;
}&nbsp;else&nbsp;{
&nbsp; &nbsp; getters =&nbsp;this.getters;
}
// 3. 上下文设置和格式判断
SerialContext parent = serializer.context;
if&nbsp;(!this.beanInfo.beanType.isEnum()) {
&nbsp; &nbsp; serializer.setContext(parent,&nbsp;object, fieldName,&nbsp;this.beanInfo.features, features);
}
// 4.遍历属性序列化器，完成属性序列化
for&nbsp;(int i =&nbsp;0; i &lt; getters.length; ++i) {
&nbsp; &nbsp; FieldSerializer fieldSerializer = getters[i];
&nbsp; &nbsp;&nbsp;// 获取属性值
&nbsp; &nbsp; Object propertyValue =&nbsp;this.processValue(serializer, fieldSerializer.fieldContext,&nbsp;object, fieldInfoName,
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; propertyValue, features);
&nbsp; &nbsp;&nbsp;// 写入属性值 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
&nbsp; &nbsp; fieldSerializer.writeValue(serializer, propertyValue);
}</code></pre>
<p><strong>循环引用检测：</strong></p>
<p>JavaBeanSerializerwriteReference&nbsp;方法执行循环引用检测，Fastjson使用$ref占位符处理循环引用问题，防止对象循环引用造成解析查询栈溢出。</p>
<pre><code>public&nbsp;boolean&nbsp;writeReference(JSONSerializer serializer,&nbsp;Object&nbsp;object, int fieldFeatures) {
&nbsp; &nbsp;&nbsp;SerialContext&nbsp;context = serializer.context;
&nbsp; &nbsp; int mask =&nbsp;SerializerFeature.DisableCircularReferenceDetect.mask;
&nbsp; &nbsp;&nbsp;// 检查是否禁用循环引用检测
&nbsp; &nbsp;&nbsp;if&nbsp;(context ==&nbsp;null&nbsp;|| (context.features&nbsp;&amp; mask) !=&nbsp;0&nbsp;|| (fieldFeatures &amp; mask) !=&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 检查对象是否已存在于引用表中
&nbsp; &nbsp;&nbsp;if&nbsp;(serializer.references&nbsp;!=&nbsp;null&nbsp;&amp;&amp; serializer.references.containsKey(object)) {
&nbsp; &nbsp; &nbsp; &nbsp; serializer.writeReference(object); &nbsp;// 写入引用标记
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;true;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;return&nbsp;false;
}</code></pre>
<p><strong>上下文管理与引用追踪：</strong></p>
<p>序列化采用DFS(深度优先)算法遍历对象树，使用&nbsp;IdentityHashMap&lt;Object, SerialContext&gt; references&nbsp;来追踪对象引用：</p>
<ul>
<li>setContext: 建立序列化上下文，记录对象层次关系</li>
<li>containsReference: 检查对象是否已被序列化</li>
<li>popContext: 序列化完成后清理上下文</li>
</ul>
<pre><code>protected&nbsp;IdentityHashMap&lt;Object,&nbsp;SerialContext&gt; references &nbsp;=&nbsp;null;
protected&nbsp;SerialContext&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; context;
//使用链表建立序列化上下文引用链，记录对象层次关系
public&nbsp;void&nbsp;setContext(SerialContext parent,&nbsp;Object&nbsp;object,&nbsp;Object&nbsp;fieldName, int features, int fieldFeatures) {
&nbsp; &nbsp;&nbsp;if&nbsp;(out.disableCircularReferenceDetect) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//构建当前上下文到parent上下文引用链
&nbsp; &nbsp;&nbsp;this.context&nbsp;=&nbsp;new&nbsp;SerialContext(parent,&nbsp;object, fieldName, features, fieldFeatures);
&nbsp; &nbsp;&nbsp;if&nbsp;(references ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; references =&nbsp;new&nbsp;IdentityHashMap&lt;Object,&nbsp;SerialContext&gt;();
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;this.references.put(object, context);
}
//检查对象是否已被序列化,防止重复序列化
public&nbsp;boolean&nbsp;containsReference(Object&nbsp;value) {
&nbsp; &nbsp;&nbsp;if&nbsp;(references ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;SerialContext&nbsp;refContext = references.get(value);
&nbsp; &nbsp;&nbsp;if&nbsp;(refContext ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;if&nbsp;(value ==&nbsp;Collections.emptyMap()) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;false;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;Object&nbsp;fieldName = refContext.fieldName;
&nbsp; &nbsp;&nbsp;return&nbsp;fieldName ==&nbsp;null&nbsp;|| fieldName&nbsp;instanceof&nbsp;Integer&nbsp;|| fieldName&nbsp;instanceof&nbsp;String;
}
//清理上下文，将当前序列化上下文指向父亲节点
public&nbsp;void&nbsp;popContext() {
&nbsp; &nbsp;&nbsp;if&nbsp;(context !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.context&nbsp;=&nbsp;this.context.parent;
&nbsp; &nbsp; }
}</code></pre>
<p><strong>字段值转换与序列化</strong></p>
<p><strong>FieldSerializer.writeValue()核心逻辑</strong></p>
<p>FieldSerializer&nbsp;的writeValue方法实现了字段值的序列化操作：</p>
<pre><code>public&nbsp;void&nbsp;writeValue(JSONSerializer serializer, Object propertyValue)&nbsp;throws&nbsp;Exception {
&nbsp; &nbsp;&nbsp;// 运行时类型识别
&nbsp; &nbsp; Class&lt;?&gt; runtimeFieldClass = propertyValue !=&nbsp;null&nbsp;?&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; propertyValue.getClass() :&nbsp;this.fieldInfo.fieldClass;
&nbsp; &nbsp;&nbsp;// 查找属性类型对应的序列化器
&nbsp; &nbsp;&nbsp;ObjectSerializer&nbsp;fieldSerializer&nbsp;=&nbsp;serializer.getObjectWriter(runtimeFieldClass);
&nbsp; &nbsp;&nbsp;// 处理特殊格式和注解
&nbsp; &nbsp;&nbsp;if&nbsp;(format !=&nbsp;null&nbsp;&amp;&amp; !(fieldSerializer&nbsp;instanceof&nbsp;DoubleSerializer)) {
&nbsp; &nbsp; &nbsp; &nbsp; serializer.writeWithFormat(propertyValue, format);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 委托给具体序列化器处理
&nbsp; &nbsp; fieldSerializer.write(serializer, propertyValue, fieldInfo.name,&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;fieldInfo.fieldType, fieldFeatures);
}</code></pre>
<p><strong>不同类型的序列化策略</strong></p>
<p>基础类型序列化 ：</p>
<ul>
<li>直接调用SerializeWriter的对应方法（writeInt、writeString等）</li>
</ul>
<p>复杂对象序列化 ：</p>
<ul>
<li>递归调用JSONSerializer.write()方法</li>
<li>维护序列化上下文和引用关系</li>
<li>应用过滤器和特性配置</li>
</ul>
<p>ASM定制化序列化器加速，下文会进行详细讲解。</p>
<ul>
<li>为序列化的类动态生成定制化的序列化器，避免反射调用开销</li>
</ul>
<p><strong>JSON字符串构建</strong></p>
<p>SerializeWriter.java采用线程本地缓冲机制，提供高效的字符串构建：</p>
<pre><code>//用于存储存JSON字符串
private&nbsp;final&nbsp;static&nbsp;ThreadLocal&lt;char[]&gt; bufLocal &nbsp; &nbsp; &nbsp; &nbsp; =&nbsp;new&nbsp;ThreadLocal&lt;char[]&gt;();
//将字符串转换为UTF-8字节数组
private&nbsp;final&nbsp;static&nbsp;ThreadLocal&lt;byte[]&gt; bytesBufLocal &nbsp; &nbsp;=&nbsp;new&nbsp;ThreadLocal&lt;byte[]&gt;();</code></pre>
<ul>
<li>字符缓冲区 : 线程本地char[]数组减少内存分配，避免频繁创建临时数组对象。</li>
<li>动态扩容 : 根据内容长度自动调整缓冲区大小。</li>
</ul>
<p>bufLocal初始化创建2048字符的缓冲区，回收阶段当缓冲区大小不超过 BUFFER_THRESHOLD （128KB）时，将其放回ThreadLocal缓存，超过阈值的大缓冲区不缓存，避免内存占用过大。</p>
<p>bytesBufLocal专门用于UTF-8编码转换过程，初始缓冲区大小：8KB（1024 * 8），根据字符数量估算所需字节数（字符数 × 3），只有不超过 BUFFER_THRESHOLD 的缓冲区才会被缓存。</p>
<h1>4.2 序列化小结</h1>
<p>Fastjson通过JSON.toJSONString()门面API调用JSONSerializer控制器，利用ASM字节码生成的高性能序列化器或反射机制遍历Java对象字段，配合SerializeWriter将字段名和值逐步写入缓冲区构建JSON字符串。</p>
<h1>4.3 反序列化流程</h1>
<p>虽然“序列化”与“反序列化”在概念上是对偶的(Serialize ↔ Deserialize)，但在实现层面并不严格对偶，反序列化实现明显比序列化复杂。核心步骤包括：反序列化器查找→ 反序列流程控制→词法分析器（Tokenizer） → 安全检查→反射/ASM 字段填充等，下图为处理时序图：</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-675327763a">
</div>
<p><strong>反序列化入口与反序列化器选择</strong></p>
<p>反序列化从&nbsp;JSON.java的parseObject方法开始：</p>
<pre><code>// JSON.java - 反序列化入口
public&nbsp;static&nbsp;&lt;T&gt; T&nbsp;parseObject(String text, Class&lt;T&gt; clazz,&nbsp;int&nbsp;features)&nbsp;{
&nbsp; &nbsp;&nbsp;if&nbsp;(text ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;DefaultJSONParser&nbsp;parser&nbsp;=&nbsp;new&nbsp;DefaultJSONParser(text, ParserConfig.getGlobalInstance(), features);
&nbsp; &nbsp;&nbsp;T&nbsp;value&nbsp;=&nbsp;(T) parser.parseObject(clazz);
&nbsp; &nbsp; parser.handleResovleTask(value);
&nbsp; &nbsp; parser.close();
&nbsp; &nbsp;&nbsp;return&nbsp;value;
}</code></pre>
<p><strong>查找反序列化器</strong></p>
<p><strong>在 DefaultJSONParser.java 中选择合适的反序列化器：</strong></p>
<pre><code>// DefaultJSONParser.java - 反序列化器选择
public&nbsp;&lt;T&gt; T&nbsp;parseObject(Type&nbsp;type,&nbsp;Object&nbsp;fieldName) {
&nbsp; &nbsp; int token = lexer.token();
&nbsp; &nbsp;&nbsp;if&nbsp;(token ==&nbsp;JSONToken.NULL) {
&nbsp; &nbsp; &nbsp; &nbsp; lexer.nextToken();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T)&nbsp;TypeUtils.optionalEmpty(type);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//从缓存中查找反序列化器
&nbsp; &nbsp;&nbsp;ObjectDeserializer&nbsp;deserializer = config.getDeserializer(type);
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(deserializer.getClass() ==&nbsp;JavaBeanDeserializer.class) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T) ((JavaBeanDeserializer) deserializer).deserialze(this,&nbsp;type, fieldName,&nbsp;0);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T) deserializer.deserialze(this,&nbsp;type, fieldName);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }&nbsp;catch&nbsp;(JSONException e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;e;
&nbsp; &nbsp; }&nbsp;catch&nbsp;(Throwable&nbsp;e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException(e.getMessage(), e);
&nbsp; &nbsp; }
}</code></pre>
<p><strong>ParserConfig.java&nbsp;负责获取对应类型的反序列化器：</strong></p>
<pre><code>// ParserConfig.java - 反序列化器获取
public&nbsp;ObjectDeserializer&nbsp;getDeserializer(Type&nbsp;type) {
&nbsp; &nbsp;&nbsp;ObjectDeserializer&nbsp;deserializer =&nbsp;this.deserializers.get(type);
&nbsp; &nbsp;&nbsp;if&nbsp;(deserializer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;deserializer;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//通过Class查找
&nbsp; &nbsp;&nbsp;if&nbsp;(type&nbsp;instanceof&nbsp;Class&lt;?&gt;) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;getDeserializer((Class&lt;?&gt;)&nbsp;type,&nbsp;type);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//通过泛型参数查找
&nbsp; &nbsp;&nbsp;if&nbsp;(type&nbsp;instanceof&nbsp;ParameterizedType) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Type&nbsp;rawType = ((ParameterizedType)&nbsp;type).getRawType();
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(rawType&nbsp;instanceof&nbsp;Class&lt;?&gt;) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;getDeserializer((Class&lt;?&gt;) rawType,&nbsp;type);
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;getDeserializer(rawType);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;return&nbsp;JavaObjectDeserializer.instance;
}</code></pre>
<p><strong>反序列化控制流程</strong></p>
<p>JavaBeanDeserializer.java&nbsp;的deserialze实现了反序列化主要处理流程。</p>
<pre><code>// JavaBeanDeserializer.java - 类型识别与字段匹配
public&nbsp;&lt;T&gt; T&nbsp;deserialze(DefaultJSONParser parser, Type&nbsp;type,&nbsp;Object&nbsp;fieldName, int features, int[] setFlags) {
&nbsp; &nbsp;&nbsp;// 1.特殊类型快速处理
&nbsp; &nbsp;&nbsp;if&nbsp;(type&nbsp;==&nbsp;JSON.class&nbsp;||&nbsp;type&nbsp;==&nbsp;JSONObject.class) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T) parser.parse();
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//2.初始化核心组件
&nbsp; &nbsp; final&nbsp;JSONLexer lexer = parser.lexer;
&nbsp; &nbsp;&nbsp;//3.反序列化上下文管理
&nbsp; &nbsp;&nbsp;ParseContext&nbsp;context = parser.getContext();
&nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;!=&nbsp;null&nbsp;&amp;&amp; context !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;context = context.parent;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;ParseContext&nbsp;childContext =&nbsp;null;
&nbsp; &nbsp;&nbsp;//保存解析后字段值
&nbsp; &nbsp;&nbsp;Map&lt;String,&nbsp;Object&gt; fieldValues =&nbsp;null;
&nbsp; &nbsp;&nbsp;// JSON关键字分支预处理
&nbsp; &nbsp;&nbsp;if&nbsp;(token ==&nbsp;JSONToken.RBRACE) {
&nbsp; &nbsp; &nbsp; &nbsp; lexer.nextToken(JSONToken.COMMA);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;object&nbsp;=&nbsp;createInstance(parser,&nbsp;type);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;(T)&nbsp;object;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//处理其他JSON关键字
&nbsp; &nbsp; ...
&nbsp; &nbsp;&nbsp;//4.字段解析主循环
&nbsp; &nbsp;&nbsp;for&nbsp;(int fieldIndex =&nbsp;0, notMatchCount =&nbsp;0;; fieldIndex++) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;boolean&nbsp;customDeserializer =&nbsp;false;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//这是一个性能优化的设计，通过预排序和索引访问来提高字段匹配的效率，
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//通常情况下JSON串按字段定义顺序排列，因此能快速命中
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldIndex &lt; sortedFieldDeserializers.length&nbsp;&amp;&amp; notMatchCount &lt;&nbsp;16) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldDeserializer = sortedFieldDeserializers[fieldIndex];
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldInfo = fieldDeserializer.fieldInfo;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldClass = fieldInfo.fieldClass;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldAnnotation = fieldInfo.getAnnotation();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldAnnotation !=&nbsp;null&nbsp;&amp;&amp; fieldDeserializer&nbsp;instanceof&nbsp;DefaultFieldDeserializer) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; customDeserializer = ((DefaultFieldDeserializer) fieldDeserializer).customDeserilizer;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Object&nbsp;fieldValue =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if&nbsp;(fieldDeserializer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; char[] name_chars = fieldInfo.name_chars;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//指定了自定义发序列化器，后续使用自定义序列化器处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(customDeserializer &amp;&amp; lexer.matchField(name_chars)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchField =&nbsp;true;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 基本类型快速路径匹配
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}&nbsp;else&nbsp;if&nbsp;(fieldClass == int.class&nbsp;|| fieldClass ==&nbsp;Integer.class) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//词法分析,解析int值
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int intVal = lexer.scanFieldInt(name_chars);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(intVal ==&nbsp;0&nbsp;&amp;&amp; lexer.matchStat&nbsp;==&nbsp;JSONLexer.VALUE_NULL) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldValue =&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldValue = intVal;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(lexer.matchStat&nbsp;&gt;&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchField =&nbsp;true;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; valueParsed =&nbsp;true;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(lexer.matchStat&nbsp;==&nbsp;JSONLexer.NOT_MATCH_NAME) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//增加计算，记录未命中次数以调整匹配策略
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; notMatchCount++;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;continue;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}&nbsp;else&nbsp;if(...){
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;//省略其他基础类型处理 &nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 快速匹配失败，动态扫描字段名,通过符号表优化:返回的字符串可能是符号表中的缓存实例
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if&nbsp;(!matchField) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key = lexer.scanSymbol(parser.symbolTable);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// $ref 引用处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;("$ref"&nbsp;== key &amp;&amp; context !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;handleReferenceResolution(lexer, parser, context)
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// @type 类型处理
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;((typeKey !=&nbsp;null&nbsp;&amp;&amp; typeKey.equals(key))
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ||&nbsp;JSON.DEFAULT_TYPE_KEY&nbsp;== key) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;//AutoType安全检查
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; config.checkAutoType(typeName, expectClass, lexer.getFeatures());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;handleTypeNameResolution(lexer, parser, config, beanInfo,&nbsp;type, fieldName);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// 5.如果对象为空，则创建对象实例
&nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;==&nbsp;null&nbsp;&amp;&amp; fieldInfo ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;object&nbsp;=&nbsp;createInstance(parser,&nbsp;type);
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(object&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;//6. 字段值设置
&nbsp; &nbsp;&nbsp;for&nbsp;(Map.Entry&lt;String,&nbsp;Object&gt; entry : fieldValues.entrySet()) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;FieldDeserializer&nbsp;fieldDeserializer =&nbsp;getFieldDeserializer(entry.getKey());
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldDeserializer !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; fieldDeserializer.setValue(object, entry.getValue());
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp;}
&nbsp; &nbsp;&nbsp;return&nbsp;(T)&nbsp;object;
}</code></pre>
<p><strong>字符串解析阶段（词法分析）</strong></p>
<p>JSONLexerBase内部维护词法解析状态机，实现词法分析核心逻辑，下面展示了Integer值类型处理源码：</p>
<pre><code>&nbsp; &nbsp;&nbsp;public&nbsp;int scanFieldInt(char[] fieldName) {
&nbsp; &nbsp; &nbsp; &nbsp; matchStat = UNKNOWN;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 1. 字段名匹配阶段
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(!charArrayCompare(fieldName)) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH_NAME;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; int offset = fieldName.length;
&nbsp; &nbsp; &nbsp; &nbsp; char chLocal = charAt(bp + (offset++));
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 2. 负号处理
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;final&nbsp;boolean negative = chLocal ==&nbsp;'-';
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(negative) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chLocal = charAt(bp + (offset++));
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 3. 数字解析核心算法
&nbsp; &nbsp; &nbsp; &nbsp; int value;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal &gt;=&nbsp;'0'&nbsp;&amp;&amp; chLocal &lt;=&nbsp;'9') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = chLocal -&nbsp;'0';
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(;;) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chLocal = charAt(bp + (offset++));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal &gt;=&nbsp;'0'&nbsp;&amp;&amp; chLocal &lt;=&nbsp;'9') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; value = value *&nbsp;10&nbsp;+ (chLocal -&nbsp;'0');// 十进制累加
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(chLocal ==&nbsp;'.') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;&nbsp;// 拒绝浮点数
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;break;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 4. 溢出检测
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(value &lt;&nbsp;0&nbsp;//
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || offset &gt;&nbsp;11&nbsp;+&nbsp;3&nbsp;+ fieldName.length) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(value != Integer.MIN_VALUE&nbsp;//
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || offset !=&nbsp;17&nbsp;//
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; || !negative) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 5. JSON 结束符处理
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal ==&nbsp;',') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += offset;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.ch =&nbsp;this.charAt(bp);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = VALUE;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.COMMA;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;negative ? -value : value;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal ==&nbsp;'}') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// ... 处理对象结束和嵌套结构
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chLocal = charAt(bp + (offset++));
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(chLocal ==&nbsp;',') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.COMMA;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += offset;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.ch =&nbsp;this.charAt(bp);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(chLocal ==&nbsp;']') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.RBRACKET;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += offset;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.ch =&nbsp;this.charAt(bp);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(chLocal ==&nbsp;'}') {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.RBRACE;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += offset;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;this.ch =&nbsp;this.charAt(bp);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(chLocal == EOI) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; token = JSONToken.EOF;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; bp += (offset -&nbsp;1);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ch = EOI;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = END;
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; matchStat = NOT_MATCH;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;0;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;negative ? -value : value;
&nbsp; &nbsp; }</code></pre>
<p><strong>类型安全检查（AutoType检查）</strong></p>
<p>ParserConfig.java&nbsp;中的checkAutoType方法对反序列化类型做黑白名单检查。</p>
<pre><code>// ParserConfig.java - AutoType安全检查
public&nbsp;Class&lt;?&gt; checkAutoType(String typeName, Class&lt;?&gt; expectClass,&nbsp;int&nbsp;features) {
&nbsp; &nbsp;&nbsp;if&nbsp;(typeName ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;if&nbsp;(typeName.length() &gt;=&nbsp;192&nbsp;|| typeName.length() &lt;&nbsp;3) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("autoType is not support. "&nbsp;+ typeName);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;String&nbsp;className&nbsp;=&nbsp;typeName.replace('$',&nbsp;'.');
&nbsp; &nbsp; Class&lt;?&gt; clazz =&nbsp;null;
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;final&nbsp;long&nbsp;BASIC&nbsp;=&nbsp;0xcbf29ce484222325L;
&nbsp; &nbsp;&nbsp;final&nbsp;long&nbsp;PRIME&nbsp;=&nbsp;0x100000001b3L;
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;final&nbsp;long&nbsp;h1&nbsp;=&nbsp;(BASIC ^ className.charAt(0)) * PRIME;
&nbsp; &nbsp;&nbsp;// hash code编码匹配性能优化
&nbsp; &nbsp;&nbsp;if&nbsp;(h1 ==&nbsp;0xaf64164c86024f1aL) {&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("autoType is not support. "&nbsp;+ typeName);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;if&nbsp;((h1 ^ className.charAt(className.length() -&nbsp;1)) * PRIME ==&nbsp;0x9198507b5af98f0L) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("autoType is not support. "&nbsp;+ typeName);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;final&nbsp;long&nbsp;h3&nbsp;=&nbsp;(((((BASIC ^ className.charAt(0))&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * PRIME)&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ className.charAt(1))&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * PRIME)&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ^ className.charAt(2))&nbsp;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * PRIME;
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;if&nbsp;(autoTypeSupport || expectClass !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;long&nbsp;hash&nbsp;=&nbsp;h3;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;for&nbsp;(int&nbsp;i&nbsp;=&nbsp;3; i &lt; className.length(); ++i) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash ^= className.charAt(i);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; hash *= PRIME;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(Arrays.binarySearch(denyHashCodes, hash) &gt;=&nbsp;0&nbsp;&amp;&amp; TypeUtils.getClassFromMapping(typeName) ==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("autoType is not support. "&nbsp;+ typeName);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(Arrays.binarySearch(acceptHashCodes, hash) &gt;=&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; clazz = TypeUtils.loadClass(typeName, defaultClassLoader,&nbsp;false);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(clazz !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;clazz;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;// ... 更多安全检查逻辑
&nbsp; &nbsp;&nbsp;return&nbsp;clazz;
}</code></pre>
<p><strong>对象实例化过程</strong></p>
<p><strong>JavaBeanDeserializer.java中的createInstance方法创建对象实例：</strong></p>
<pre><code>// JavaBeanDeserializer.java - 对象实例化
protected&nbsp;Object&nbsp;createInstance(DefaultJSONParser parser, Type&nbsp;type) {
&nbsp; &nbsp;&nbsp;if&nbsp;(type&nbsp;instanceof&nbsp;Class) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(clazz.isInterface()) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 接口类型使用Java反射创建实例
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Class&lt;?&gt; clazz = (Class&lt;?&gt;)&nbsp;type;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ClassLoader&nbsp;loader =&nbsp;Thread.currentThread().getContextClassLoader();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final&nbsp;JSONObject&nbsp;obj =&nbsp;new&nbsp;JSONObject();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Object&nbsp;proxy =&nbsp;Proxy.newProxyInstance(loader,&nbsp;new&nbsp;Class&lt;?&gt;[] { clazz }, obj);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;proxy;
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;if&nbsp;(beanInfo.defaultConstructor&nbsp;==&nbsp;null&nbsp;&amp;&amp; beanInfo.factoryMethod&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return&nbsp;null;
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;Object&nbsp;object;
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp;&nbsp;//通过构造器创建实例
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Constructor&lt;?&gt; constructor = beanInfo.defaultConstructor;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(beanInfo.defaultConstructorParameterSize&nbsp;==&nbsp;0) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;object&nbsp;= constructor.newInstance();
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;ParseContext&nbsp;context = parser.getContext();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(context ==&nbsp;null&nbsp;|| context.object&nbsp;==&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("can't create non-static inner class instance.");
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final&nbsp;Class&lt;?&gt; enclosingClass = constructor.getDeclaringClass().getEnclosingClass();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;object&nbsp;= constructor.newInstance(context.object);
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }&nbsp;catch&nbsp;(JSONException e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;e;
&nbsp; &nbsp; }&nbsp;catch&nbsp;(Exception&nbsp;e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("create instance error, class "&nbsp;+ clazz.getName(), e);
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;return&nbsp;object;
}</code></pre>
<p><strong>FieldDeserializer.java中的setValue方法通过反射实现字段设置：</strong></p>
<pre><code>// FieldDeserializer.java - 属性赋值的核心实现
public&nbsp;void&nbsp;setValue(Object&nbsp;object,&nbsp;Object&nbsp;value) {
&nbsp; &nbsp;&nbsp;if&nbsp;(value ==&nbsp;null&nbsp;&amp;&amp; fieldInfo.fieldClass.isPrimitive()) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;return;
&nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(fieldInfo.fieldClass&nbsp;==&nbsp;String.class
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; fieldInfo.format&nbsp;!=&nbsp;null
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &amp;&amp; fieldInfo.format.equals("trim")) {
&nbsp; &nbsp; &nbsp; &nbsp; value = ((String) value).trim();
&nbsp; &nbsp; }
&nbsp; &nbsp;&nbsp;
&nbsp; &nbsp;&nbsp;try&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Method&nbsp;method = fieldInfo.method;
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(method !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldInfo.getOnly) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 处理只读属性的特殊情况
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(fieldInfo.fieldClass&nbsp;==&nbsp;AtomicInteger.class) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;AtomicInteger&nbsp;atomic = (AtomicInteger) method.invoke(object);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(atomic !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; atomic.set(((AtomicInteger) value).get());
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;if&nbsp;(Map.class.isAssignableFrom(method.getReturnType())) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Map&nbsp;map = (Map) method.invoke(object);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(map !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; map.putAll((Map) value);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Collection&nbsp;collection = (Collection) method.invoke(object);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(collection !=&nbsp;null&nbsp;&amp;&amp; value !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collection.clear();
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; collection.addAll((Collection) value);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 通过setter方法赋值
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; method.invoke(object, value);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }&nbsp;else&nbsp;{
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 通过字段直接赋值
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; final&nbsp;Field&nbsp;field = fieldInfo.field;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;if&nbsp;(field !=&nbsp;null) {
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; field.set(object, value);
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; &nbsp; &nbsp; }
&nbsp; &nbsp; }&nbsp;catch&nbsp;(Exception&nbsp;e) {
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;throw&nbsp;new&nbsp;JSONException("set property error, "&nbsp;+ clazz.getName() +&nbsp;"#"&nbsp;+ fieldInfo.name, e);
&nbsp; &nbsp; }
}</code></pre>
<h1>4.4 反序列化小结</h1>
<p>Fastjson通过JSON.parseObject()门面API调用DefaultJSONParser控制器，利用JSONLexer进行词法分析解析JSON字符串，经过AutoType安全检查后使用ASM字节码生成动态反序列化器或反射机制创建Java对象实例并逐字段赋值。</p>
<h1>五、特性讲解</h1>
<h1>5.1 ASM性能优化</h1>
<p>ASM 是 fastjson 类似于 JIT，在运行时把「反射调用」翻译成「直接字段访问 + 方法调用」的字节码，从而把序列化/反序列化性能提升 20% 以上，当然随着JVM对反射性能的优化性能差正在逐渐被缩小。下图是作者使用工具类读取的动态序列化/反序列化器源码片段。</p>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-a1669be5d0">
</div>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-136f97bda8">
</div>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-82b4e0207e">
</div>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-b9069ddcfd">
</div>
<h1>5.2&nbsp; AutoType机制</h1>
<p>AutoType是 fastjson 的“动态多态还原”方案:</p>
<p>序列化时把具体子类名字写进&nbsp;"@type"，反序列化时先加载类 → 再调 setter → 完成还原。</p>
<p>&nbsp;速度上“指针引用”即可定位序列化器，功能上靠&nbsp;<a href="https://my.oschina.net/fanren1919" target="_blank">@type</a>&nbsp;字段把被擦除的泛型/接口/父类重新映射回具体实现。</p>
<p>在未开启AutoType机制情况下，在将store对象序列化成JSON串后，再反序列化为对象时由于字段的类型为接口无法转换成具体的Dog类型示例；开启AutoType机制后，序列化时将类型一并写入到JSON串内，后续进行反序列化时可以根据这个类型还原成具体的类型实例。</p>
<pre><code>interface&nbsp;Animal&nbsp;{}
class&nbsp;Dog&nbsp;implements&nbsp;Animal&nbsp;{
&nbsp; &nbsp;&nbsp;private&nbsp;String&nbsp;name;
&nbsp; &nbsp;&nbsp;private&nbsp;double weight;
&nbsp; &nbsp;&nbsp;//省略getter,setter
}
class&nbsp;PetStore&nbsp;{
&nbsp; &nbsp;&nbsp;private&nbsp;Animal&nbsp;animal;
}
public&nbsp;static&nbsp;void&nbsp;main(String[] args) {
&nbsp; &nbsp;&nbsp;Animal&nbsp;dog =&nbsp;new&nbsp;Dog("dodi",&nbsp;12);
&nbsp; &nbsp;&nbsp;PetStore&nbsp;store =&nbsp;new&nbsp;PetStore(dog);
&nbsp; &nbsp;&nbsp;String&nbsp;jsonString =&nbsp;JSON.toJSONString(store);
&nbsp; &nbsp;&nbsp;PetStore&nbsp;petStore =&nbsp;JSON.parseObject(jsonString,&nbsp;PetStore.class);
&nbsp; &nbsp;&nbsp;Dog&nbsp;parsedDog = (Dog) petStore.getAnimal();
}</code></pre>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-0051358e13">
</div>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-6a93c6470b">
</div>
<pre><code>public&nbsp;static&nbsp;void&nbsp;main(String[] args) {
&nbsp; &nbsp;&nbsp;Animal&nbsp;dog =&nbsp;new&nbsp;Dog("dodi",&nbsp;12);
&nbsp; &nbsp;&nbsp;PetStore&nbsp;store =&nbsp;new&nbsp;PetStore(dog);
&nbsp; &nbsp;&nbsp;String&nbsp;jsonString =&nbsp;JSON.toJSONString(store,&nbsp;SerializerFeature.WriteClassName);
&nbsp; &nbsp;&nbsp;PetStore&nbsp;petStore =&nbsp;JSON.parseObject(jsonString,&nbsp;PetStore.class);
&nbsp; &nbsp;&nbsp;Dog&nbsp;parsedDog = (Dog) petStore.getAnimal();
}</code></pre>
<div>
<img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-e17c314f91">
</div>
<p>AutoType 让 fastjson 在反序列化时根据&nbsp;<a href="https://my.oschina.net/fanren1919" target="_blank">@type</a>&nbsp;字段动态加载任意类，这一“便利”却成为攻击者远程代码执行的快捷通道：通过把JdbcRowSetImpl等 JNDI 敏感类写进 JSON，服务端在调用 setter 的瞬间就会向外部 LDAP/RMI 服务器拉取恶意字节码，完成 RCE；而官方长期依赖“黑名单”堵漏，导致 1.2.25→1.2.80 出现 L 描述符、Throwable 二次反序列化、内部类等连续绕过，形成“补丁-绕过-再补丁”的猫鼠游戏， 虽然在1.2.68 引入 safeMode 但为了兼容性需要使用者手动开启 ，而且实现也不够健壮，开启safeMode仍有利用代码漏洞绕过检查风险，后续版本对safeMode加固并对已知安全漏洞清零，直到最新1.2.83版本安全问题也不能说彻底解决。</p>
<h1>5.3 流式解析</h1>
<p>Fastjson 提供一套 Streaming API，核心类JSONReader&nbsp;/JSONWriter，行业内惯称「流式解析」或「增量解析」，主要用于处理JSON大文件解析。技术上流式解析采用“拉模式（pull parsing）”，底层维护 8 KB 滑动缓冲，词法分析器（Tokenizer）把字节流切成 token 流，语法状态机根据 token 类型驱动反序列化器（ObjectReader）即时产出 Java 对象，对象一旦交付给用户代码处理后，内部引用立即释放。这种方式内存中不会保存所有对象，对象处理完即被丢弃，因此可以处理数据量远大于内存的数据，而不会出现OOM。下面是使用流式解析的示例代码：</p>
<pre><code>// 依赖：com.alibaba:fastjson:1.2.83
try&nbsp;(JSONReader reader =&nbsp;new&nbsp;JSONReader(
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;new&nbsp;InputStreamReader(
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;new&nbsp;FileInputStream("huge-array.json"),&nbsp;StandardCharsets.UTF_8))) {
&nbsp; &nbsp; reader.startArray(); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 告诉解析器：根节点是 []
&nbsp; &nbsp;&nbsp;while&nbsp;(reader.hasNext()) { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;// 拉取下一条
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;Order&nbsp;order = reader.readObject(Order.class);&nbsp;// 瞬时对象
&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;processOrder(order);//业务处理
&nbsp; &nbsp; &nbsp; &nbsp; orderRepository.save(order); &nbsp; &nbsp;&nbsp;// 立即落盘，内存即可回收
&nbsp; &nbsp; }
&nbsp; &nbsp; reader.endArray();
}</code></pre>
<h1>六、总结</h1>
<p>Fastjson核心特性在于高速序列化/反序列化，利用ASM在运行时生成字节码动态创建解析器，减少反射；AutoType字段支持多态，却带来反序列化RCE风险，建议关闭AutoType，开启safeMode。选型建议：在选择JSON序列化框架时对于非极端性能要求推荐Jackson，或者使用Fastjson2，其改用LambdaMetafactory替换ASM，性能再提升30%，默认关闭AutoType安全性有保证。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li>FastJson 反序列化漏洞原理分析（https://www.cnblogs.com/Only-xiaoxiao/p/17213248.html）</li>
<li>序列化与反序列化——FastJSON、Jackson、Gson性能测试（https://zhuanlan.zhihu.com/p/529342385）</li>
<li>FASTJSON 2 Autotype机制介绍（https://alibaba.github.io/fastjson2/autotype_cn.html）</li>
<li>&nbsp;</li>
</ul>
<h4>往期回顾</h4>
<p>1.&nbsp;用好 TTL Agent 不踩雷：避开内存泄露与CPU 100%两大核心坑｜得物技术</p>
<p>2.&nbsp;线程池ThreadPoolExecutor源码深度解析｜得物技术</p>
<p>3.&nbsp;基于浏览器扩展 API Mock 工具开发探索｜得物技术</p>
<p>4.&nbsp;破解gh-ost变更导致MySQL表膨胀之谜｜得物技术</p>
<p>5.&nbsp;MySQL单表为何别超2000万行？揭秘B+树与16KB页的生死博弈｜得物技术</p>
<h4>文 /剑九</h4>
<p>关注得物技术，每周更新技术干货</p>
<p>要是觉得文章对你有帮助的话，欢迎评论转发点赞～</p>
<p>未经得物技术许可严禁转载，否则依法追究法律责任。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-7928e1f6ec"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/mp.toutiao.com-7928e1f6ec" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 10:40:17 +0800</pubDate>
  </item><item>
    <title><![CDATA[Manus 1.5 正式发布，迄今为止最强大的代理系统]]></title>
    <link>https://www.oschina.net/news/377914/manus-1-5-release</link>
    <itunes:title><![CDATA[Manus 1.5 正式发布，迄今为止最强大的代理系统]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>通用 AI Agent 工具 Manus 宣布推出全新版本 Manus 1.5。官方称这是其迄今为止最强大的代理系统，本次更新在速度与性能方面实现了全面提升，并进一步验证了其核心架构的通用性。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0d9d85b5d9.png"></p>
<hr>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmanus.im%2Fzh-cn%2Fblog%2Fmanus-1.5-release" target="_blank">官方发布公告如下</a>：</p>
<p>我们推出了Manus 1.5，这是我们迄今为止最强大的代理系统。Manus 1.5 在所有任务类型中都带来了显著的速度、可靠性和质量改进——从研究和数据分析到网页开发和演示文稿创建。</p>
<p>此版本推出了两个新代理：Manus-1.5提供我们最新架构的全部功能，而Manus-1.5-Lite则提供了一个为成本效益优化的精简体验。</p>
<h2>改进之处</h2>
<p>Manus 1.5 建立在重新架构的引擎之上，使一切变得更快更可靠。平均而言，任务完成速度现在快了近四倍——从4月份的15分钟减少到如今的不到4分钟。对于更复杂的任务，Manus现在可以分配额外的推理时间和计算能力，以提供更深入、更高质量的结果。</p>
<p><img alt="更快" src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-57447aa14a.jpg"></p>
<p>这一性能提升与智能方面的显著改进相匹配。曾经因复杂性而失败的任务现在能够成功完成，且交付成果的质量始终更高。在我们的内部基准测试中，Manus 1.5架构与早期版本相比，任务质量提高了15%，用户满意度提升了6%。</p>
<p>除了速度和智能外，Manus 1.5现在能够处理更大、更复杂的问题，这要归功于单个任务扩展的上下文窗口。这使得代理能够在更长的对话和更复杂的工作流程中保持连贯性，确保不会遗漏任何重要细节。</p>
<h2>构建完整的Web应用程序</h2>
<p>这个版本的主要增强功能之一是全栈Web应用程序开发。现在您可以通过与Manus的对话来构建和部署生产就绪的Web应用程序——无需离开平台去设置托管、配置后端或调试部署问题。这远不止于生成静态页面：Manus可以创建具有持久化后端、数据库、用户认证和嵌入式AI功能的复杂应用程序。</p>
<p>与众不同的是，Manus中的Web开发并不是一个孤立的功能。作为一个通用AI代理，Manus利用其全部能力范围来支持Web开发——从进行深入研究和生成图像，到自主安装增强开发过程的工具或软件包。与典型的"AI网站构建器"不同，Manus可以在单一上下文中执行整个价值链：研究并产出深度内容，构建网站，分析用户交互数据，并基于这些发现生成见解或演示幻灯片。</p>
<p>下表提供了Manus 1.5中可用于Web应用程序开发的核心功能概述：</p>
<div>
<div>
<div>
<table>
<tbody>
<tr>
<td>
<div>
<span><span><span>功能</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>描述</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>全栈脚手架</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>完整的后端服务器基础设施，而不仅仅是前端代码。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>用户认证</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>内置用户注册、登录和管理功能。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>集成数据库</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>为表单、用户数据和应用程序状态提供持久化数据存储。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>嵌入式AI功能</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>将多模态LLM和图像生成直接内置到您的应用程序中。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>事件驱动通知</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>针对用户操作和系统事件的自定义电子邮件或应用内提醒。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>可视化编辑</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>指向实时预览中的任何部分，并使用自然语言描述更改。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>自定义域名</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>连接您自己的域名或子域名来发布您的应用程序。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>内置分析</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>无需外部工具即可跟踪访问者、页面浏览量和流量来源。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>版本控制</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>随时回滚到应用程序的任何先前版本。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>权限控制</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>配置对应用程序的公共、私有或特定用户访问权限。</span></span></span>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div>
<h2>协作和资料库</h2>
</div>
<p>Manus 1.5还引入了协作功能，允许您邀请团队成员进入共享会话，与Manus一起工作。新的资料库为所有生成的文件和制品提供了一个集中的位置，使组织和访问您的工作变得更加容易。</p>
<h2>可用性</h2>
<p><img alt="概要" src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-3c9b5c987e.jpg"></p>
<p>Manus-1.5-Lite从今天开始向所有用户开放。Manus-1.5向订阅用户开放。订阅用户在Manus-1.5-Lite积分消耗上可获得50%的折扣。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>通用 AI Agent 工具 Manus 宣布推出全新版本 Manus 1.5。官方称这是其迄今为止最强大的代理系统，本次更新在速度与性能方面实现了全面提升，并进一步验证了其核心架构的通用性。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0d9d85b5d9.png"></p>
<hr>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmanus.im%2Fzh-cn%2Fblog%2Fmanus-1.5-release" target="_blank">官方发布公告如下</a>：</p>
<p>我们推出了Manus 1.5，这是我们迄今为止最强大的代理系统。Manus 1.5 在所有任务类型中都带来了显著的速度、可靠性和质量改进——从研究和数据分析到网页开发和演示文稿创建。</p>
<p>此版本推出了两个新代理：Manus-1.5提供我们最新架构的全部功能，而Manus-1.5-Lite则提供了一个为成本效益优化的精简体验。</p>
<h2>改进之处</h2>
<p>Manus 1.5 建立在重新架构的引擎之上，使一切变得更快更可靠。平均而言，任务完成速度现在快了近四倍——从4月份的15分钟减少到如今的不到4分钟。对于更复杂的任务，Manus现在可以分配额外的推理时间和计算能力，以提供更深入、更高质量的结果。</p>
<p><img alt="更快" src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-57447aa14a.jpg"></p>
<p>这一性能提升与智能方面的显著改进相匹配。曾经因复杂性而失败的任务现在能够成功完成，且交付成果的质量始终更高。在我们的内部基准测试中，Manus 1.5架构与早期版本相比，任务质量提高了15%，用户满意度提升了6%。</p>
<p>除了速度和智能外，Manus 1.5现在能够处理更大、更复杂的问题，这要归功于单个任务扩展的上下文窗口。这使得代理能够在更长的对话和更复杂的工作流程中保持连贯性，确保不会遗漏任何重要细节。</p>
<h2>构建完整的Web应用程序</h2>
<p>这个版本的主要增强功能之一是全栈Web应用程序开发。现在您可以通过与Manus的对话来构建和部署生产就绪的Web应用程序——无需离开平台去设置托管、配置后端或调试部署问题。这远不止于生成静态页面：Manus可以创建具有持久化后端、数据库、用户认证和嵌入式AI功能的复杂应用程序。</p>
<p>与众不同的是，Manus中的Web开发并不是一个孤立的功能。作为一个通用AI代理，Manus利用其全部能力范围来支持Web开发——从进行深入研究和生成图像，到自主安装增强开发过程的工具或软件包。与典型的"AI网站构建器"不同，Manus可以在单一上下文中执行整个价值链：研究并产出深度内容，构建网站，分析用户交互数据，并基于这些发现生成见解或演示幻灯片。</p>
<p>下表提供了Manus 1.5中可用于Web应用程序开发的核心功能概述：</p>
<div>
<div>
<div>
<table>
<tbody>
<tr>
<td>
<div>
<span><span><span>功能</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>描述</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>全栈脚手架</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>完整的后端服务器基础设施，而不仅仅是前端代码。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>用户认证</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>内置用户注册、登录和管理功能。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>集成数据库</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>为表单、用户数据和应用程序状态提供持久化数据存储。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>嵌入式AI功能</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>将多模态LLM和图像生成直接内置到您的应用程序中。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>事件驱动通知</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>针对用户操作和系统事件的自定义电子邮件或应用内提醒。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>可视化编辑</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>指向实时预览中的任何部分，并使用自然语言描述更改。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>自定义域名</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>连接您自己的域名或子域名来发布您的应用程序。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>内置分析</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>无需外部工具即可跟踪访问者、页面浏览量和流量来源。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>版本控制</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>随时回滚到应用程序的任何先前版本。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>权限控制</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>配置对应用程序的公共、私有或特定用户访问权限。</span></span></span>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div>
<h2>协作和资料库</h2>
</div>
<p>Manus 1.5还引入了协作功能，允许您邀请团队成员进入共享会话，与Manus一起工作。新的资料库为所有生成的文件和制品提供了一个集中的位置，使组织和访问您的工作变得更加容易。</p>
<h2>可用性</h2>
<p><img alt="概要" src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-3c9b5c987e.jpg"></p>
<p>Manus-1.5-Lite从今天开始向所有用户开放。Manus-1.5向订阅用户开放。订阅用户在Manus-1.5-Lite积分消耗上可获得50%的折扣。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>通用 AI Agent 工具 Manus 宣布推出全新版本 Manus 1.5。官方称这是其迄今为止最强大的代理系统，本次更新在速度与性能方面实现了全面提升，并进一步验证了其核心架构的通用性。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0d9d85b5d9.png"></p>
<hr>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmanus.im%2Fzh-cn%2Fblog%2Fmanus-1.5-release" target="_blank">官方发布公告如下</a>：</p>
<p>我们推出了Manus 1.5，这是我们迄今为止最强大的代理系统。Manus 1.5 在所有任务类型中都带来了显著的速度、可靠性和质量改进——从研究和数据分析到网页开发和演示文稿创建。</p>
<p>此版本推出了两个新代理：Manus-1.5提供我们最新架构的全部功能，而Manus-1.5-Lite则提供了一个为成本效益优化的精简体验。</p>
<h2>改进之处</h2>
<p>Manus 1.5 建立在重新架构的引擎之上，使一切变得更快更可靠。平均而言，任务完成速度现在快了近四倍——从4月份的15分钟减少到如今的不到4分钟。对于更复杂的任务，Manus现在可以分配额外的推理时间和计算能力，以提供更深入、更高质量的结果。</p>
<p><img alt="更快" src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-57447aa14a.jpg"></p>
<p>这一性能提升与智能方面的显著改进相匹配。曾经因复杂性而失败的任务现在能够成功完成，且交付成果的质量始终更高。在我们的内部基准测试中，Manus 1.5架构与早期版本相比，任务质量提高了15%，用户满意度提升了6%。</p>
<p>除了速度和智能外，Manus 1.5现在能够处理更大、更复杂的问题，这要归功于单个任务扩展的上下文窗口。这使得代理能够在更长的对话和更复杂的工作流程中保持连贯性，确保不会遗漏任何重要细节。</p>
<h2>构建完整的Web应用程序</h2>
<p>这个版本的主要增强功能之一是全栈Web应用程序开发。现在您可以通过与Manus的对话来构建和部署生产就绪的Web应用程序——无需离开平台去设置托管、配置后端或调试部署问题。这远不止于生成静态页面：Manus可以创建具有持久化后端、数据库、用户认证和嵌入式AI功能的复杂应用程序。</p>
<p>与众不同的是，Manus中的Web开发并不是一个孤立的功能。作为一个通用AI代理，Manus利用其全部能力范围来支持Web开发——从进行深入研究和生成图像，到自主安装增强开发过程的工具或软件包。与典型的"AI网站构建器"不同，Manus可以在单一上下文中执行整个价值链：研究并产出深度内容，构建网站，分析用户交互数据，并基于这些发现生成见解或演示幻灯片。</p>
<p>下表提供了Manus 1.5中可用于Web应用程序开发的核心功能概述：</p>
<div>
<div>
<div>
<table>
<tbody>
<tr>
<td>
<div>
<span><span><span>功能</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>描述</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>全栈脚手架</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>完整的后端服务器基础设施，而不仅仅是前端代码。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>用户认证</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>内置用户注册、登录和管理功能。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>集成数据库</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>为表单、用户数据和应用程序状态提供持久化数据存储。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>嵌入式AI功能</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>将多模态LLM和图像生成直接内置到您的应用程序中。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>事件驱动通知</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>针对用户操作和系统事件的自定义电子邮件或应用内提醒。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>可视化编辑</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>指向实时预览中的任何部分，并使用自然语言描述更改。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>自定义域名</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>连接您自己的域名或子域名来发布您的应用程序。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>内置分析</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>无需外部工具即可跟踪访问者、页面浏览量和流量来源。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>版本控制</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>随时回滚到应用程序的任何先前版本。</span></span></span>
</div> </td>
</tr>
<tr>
<td>
<div>
<span><span><span>权限控制</span></span></span>
</div> </td>
<td>
<div>
<span><span><span>配置对应用程序的公共、私有或特定用户访问权限。</span></span></span>
</div> </td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div>
<h2>协作和资料库</h2>
</div>
<p>Manus 1.5还引入了协作功能，允许您邀请团队成员进入共享会话，与Manus一起工作。新的资料库为所有生成的文件和制品提供了一个集中的位置，使组织和访问您的工作变得更加容易。</p>
<h2>可用性</h2>
<p><img alt="概要" src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-3c9b5c987e.jpg"></p>
<p>Manus-1.5-Lite从今天开始向所有用户开放。Manus-1.5向订阅用户开放。订阅用户在Manus-1.5-Lite积分消耗上可获得50%的折扣。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0d9d85b5d9.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0d9d85b5d9.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 10:21:28 +0800</pubDate>
  </item><item>
    <title><![CDATA[ChatGPT 上线自动记忆管理功能]]></title>
    <link>https://www.oschina.net/news/377911</link>
    <itunes:title><![CDATA[ChatGPT 上线自动记忆管理功能]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>OpenAI <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FOpenAI%2Fstatus%2F1978608684088643709" target="_blank">宣布</a> ChatGPT 现已支持自动管理用户保存的记忆功能，解决了此前“记忆已满”的限制问题。用户还可以按时间搜索和排序记忆，并在设置中重新调整优先级。这项功能将从今天起在全球范围内面向网页端的 Plus 和 Pro 用户陆续开放。</p>
<p>借助该功能，ChatGPT 会自动判断哪些记忆需要保留或删除，用户无需再为内存不足手动清理。用户可以通过“按时间搜索和整理记忆”快速找到过去的对话记录，还能通过调整优先级，让最重要的内容始终排在前面。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-1aec13ae89.png"></p>
<p>有用户此前反馈称，遇到“保存记忆已满”的提示时，无法继续使用最核心的上下文功能，甚至希望能通过付费方式扩展存储空间。此次更新被认为是对这一问题的直接回应。</p>
<p>不过，也有部分用户提出，希望未来能够支持手动编辑或新增记忆，而无需通过助手操作。例如仅修改几个字或删除部分内容时，现有流程仍显繁琐。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>OpenAI <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FOpenAI%2Fstatus%2F1978608684088643709" target="_blank">宣布</a> ChatGPT 现已支持自动管理用户保存的记忆功能，解决了此前“记忆已满”的限制问题。用户还可以按时间搜索和排序记忆，并在设置中重新调整优先级。这项功能将从今天起在全球范围内面向网页端的 Plus 和 Pro 用户陆续开放。</p>
<p>借助该功能，ChatGPT 会自动判断哪些记忆需要保留或删除，用户无需再为内存不足手动清理。用户可以通过“按时间搜索和整理记忆”快速找到过去的对话记录，还能通过调整优先级，让最重要的内容始终排在前面。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-1aec13ae89.png"></p>
<p>有用户此前反馈称，遇到“保存记忆已满”的提示时，无法继续使用最核心的上下文功能，甚至希望能通过付费方式扩展存储空间。此次更新被认为是对这一问题的直接回应。</p>
<p>不过，也有部分用户提出，希望未来能够支持手动编辑或新增记忆，而无需通过助手操作。例如仅修改几个字或删除部分内容时，现有流程仍显繁琐。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>OpenAI <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fx.com%2FOpenAI%2Fstatus%2F1978608684088643709" target="_blank">宣布</a> ChatGPT 现已支持自动管理用户保存的记忆功能，解决了此前“记忆已满”的限制问题。用户还可以按时间搜索和排序记忆，并在设置中重新调整优先级。这项功能将从今天起在全球范围内面向网页端的 Plus 和 Pro 用户陆续开放。</p>
<p>借助该功能，ChatGPT 会自动判断哪些记忆需要保留或删除，用户无需再为内存不足手动清理。用户可以通过“按时间搜索和整理记忆”快速找到过去的对话记录，还能通过调整优先级，让最重要的内容始终排在前面。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-1aec13ae89.png"></p>
<p>有用户此前反馈称，遇到“保存记忆已满”的提示时，无法继续使用最核心的上下文功能，甚至希望能通过付费方式扩展存储空间。此次更新被认为是对这一问题的直接回应。</p>
<p>不过，也有部分用户提出，希望未来能够支持手动编辑或新增记忆，而无需通过助手操作。例如仅修改几个字或删除部分内容时，现有流程仍显繁琐。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-1aec13ae89.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-1aec13ae89.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 10:12:17 +0800</pubDate>
  </item><item>
    <title><![CDATA[特朗普 AI 顾问指责 Anthropic 利用监管策略打击初创企业]]></title>
    <link>https://www.oschina.net/news/377909</link>
    <itunes:title><![CDATA[特朗普 AI 顾问指责 Anthropic 利用监管策略打击初创企业]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>特朗普新任 AI 顾问大卫・萨克斯（David Sacks）近日在社交媒体平台 X 上指责 AI 公司 Anthropic 实施一种 “基于恐吓的复杂监管捕获策略”，称该公司是导致各州监管浪潮的主要推手，损害了初创企业的生态环境。这一争议主要围绕 Anthropic 对美国 AI 立法的立场展开。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e6e6924fc8.png"></p>
<p>Anthropic 的联合创始人杰克・克拉克（Jack Clark）对此回应表示，萨克斯的指责让人感到 “困惑”，他指出该公司在许多问题上与政府保持一致，尽管在某些方面意见略有不同。他认为，Anthropic 的观点是以 “实质性、基于事实的方式” 提出的，反而感到其他公司的反应 “非常奇怪”。</p>
<p>争议的核心在于 Anthropic 支持加州的 SB53法案，这是一项旨在为 AI 开发者设立透明度要求和举报人保护的重大法律。该法案已于九月底由加州州长签署，并将在2026年生效。值得注意的是，Anthropic 是<span>唯一</span>公开支持该法案的主要 AI 公司，而 OpenAI 则在法案通过后表示能够 “接受” 这一法律。</p>
<p>克拉克解释称，Anthropic 之所以支持 SB53，是因为联邦立法者在国家层面上未能取得进展。他指出，统一的联邦标准更为理想，但联邦政府在大规模政策包方面的推进速度并不令人满意。为此，Anthropic 已提出自己的透明框架，作为可能的联邦立法模型。克拉克认为，简单的规则和保护初创企业的门槛将有利于整个生态系统。</p>
<p>克拉克还表示，前沿 AI 的发展需要更多的开放性，他将此比喻为对 AI 产品进行标签标识，正如食品、药品和飞机等其他行业都有相应的标签。他希望通过建立合理的创新环境，避免出现类似于核工业的 “反应性、限制性监管” 现象。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>特朗普新任 AI 顾问大卫・萨克斯（David Sacks）近日在社交媒体平台 X 上指责 AI 公司 Anthropic 实施一种 “基于恐吓的复杂监管捕获策略”，称该公司是导致各州监管浪潮的主要推手，损害了初创企业的生态环境。这一争议主要围绕 Anthropic 对美国 AI 立法的立场展开。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e6e6924fc8.png"></p>
<p>Anthropic 的联合创始人杰克・克拉克（Jack Clark）对此回应表示，萨克斯的指责让人感到 “困惑”，他指出该公司在许多问题上与政府保持一致，尽管在某些方面意见略有不同。他认为，Anthropic 的观点是以 “实质性、基于事实的方式” 提出的，反而感到其他公司的反应 “非常奇怪”。</p>
<p>争议的核心在于 Anthropic 支持加州的 SB53法案，这是一项旨在为 AI 开发者设立透明度要求和举报人保护的重大法律。该法案已于九月底由加州州长签署，并将在2026年生效。值得注意的是，Anthropic 是<span>唯一</span>公开支持该法案的主要 AI 公司，而 OpenAI 则在法案通过后表示能够 “接受” 这一法律。</p>
<p>克拉克解释称，Anthropic 之所以支持 SB53，是因为联邦立法者在国家层面上未能取得进展。他指出，统一的联邦标准更为理想，但联邦政府在大规模政策包方面的推进速度并不令人满意。为此，Anthropic 已提出自己的透明框架，作为可能的联邦立法模型。克拉克认为，简单的规则和保护初创企业的门槛将有利于整个生态系统。</p>
<p>克拉克还表示，前沿 AI 的发展需要更多的开放性，他将此比喻为对 AI 产品进行标签标识，正如食品、药品和飞机等其他行业都有相应的标签。他希望通过建立合理的创新环境，避免出现类似于核工业的 “反应性、限制性监管” 现象。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>特朗普新任 AI 顾问大卫・萨克斯（David Sacks）近日在社交媒体平台 X 上指责 AI 公司 Anthropic 实施一种 “基于恐吓的复杂监管捕获策略”，称该公司是导致各州监管浪潮的主要推手，损害了初创企业的生态环境。这一争议主要围绕 Anthropic 对美国 AI 立法的立场展开。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e6e6924fc8.png"></p>
<p>Anthropic 的联合创始人杰克・克拉克（Jack Clark）对此回应表示，萨克斯的指责让人感到 “困惑”，他指出该公司在许多问题上与政府保持一致，尽管在某些方面意见略有不同。他认为，Anthropic 的观点是以 “实质性、基于事实的方式” 提出的，反而感到其他公司的反应 “非常奇怪”。</p>
<p>争议的核心在于 Anthropic 支持加州的 SB53法案，这是一项旨在为 AI 开发者设立透明度要求和举报人保护的重大法律。该法案已于九月底由加州州长签署，并将在2026年生效。值得注意的是，Anthropic 是<span>唯一</span>公开支持该法案的主要 AI 公司，而 OpenAI 则在法案通过后表示能够 “接受” 这一法律。</p>
<p>克拉克解释称，Anthropic 之所以支持 SB53，是因为联邦立法者在国家层面上未能取得进展。他指出，统一的联邦标准更为理想，但联邦政府在大规模政策包方面的推进速度并不令人满意。为此，Anthropic 已提出自己的透明框架，作为可能的联邦立法模型。克拉克认为，简单的规则和保护初创企业的门槛将有利于整个生态系统。</p>
<p>克拉克还表示，前沿 AI 的发展需要更多的开放性，他将此比喻为对 AI 产品进行标签标识，正如食品、药品和飞机等其他行业都有相应的标签。他希望通过建立合理的创新环境，避免出现类似于核工业的 “反应性、限制性监管” 现象。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e6e6924fc8.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e6e6924fc8.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 10:10:37 +0800</pubDate>
  </item><item>
    <title><![CDATA[VMware Workstation &amp; Fusion 25H2 发布]]></title>
    <link>https://www.oschina.net/news/377907/vmware-workstation-fusion-25h2</link>
    <itunes:title><![CDATA[VMware Workstation &amp; Fusion 25H2 发布]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>VMware 发布了最新版本的桌面虚拟化产品 —— <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.vmware.com%2Fcloud-foundation%2F2025%2F10%2F14%2Fvmware-workstation-fusion-25h2-embracing-calendar-versioning-and-new-features%2F" target="_blank"><strong>Workstation 25H2</strong> 与 <strong>Fusion 25H2</strong></a>。这次更新首次采用“<strong>日历版本命名法</strong>”，用年份和半年标识版本（如 25H2 表示 2025 年下半年），让版本周期更清晰、统一。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-19aadae3ba.png"></p>
<p>新版带来了多项重要功能与改进：</p>
<ul>
<li> <p><strong>新增 dictTool 工具</strong>，允许用户通过命令行快速查看和编辑虚拟机配置文件，提升自动化与可定制能力。</p> </li>
<li> <p><strong>全面支持 USB 3.2</strong>，提升外设兼容性与数据传输速率。</p> </li>
<li> <p><strong>硬件版本更新至 22</strong>，为虚拟机解锁更多现代化硬件特性。</p> </li>
<li> <p><strong>Workstation 新增 Hyper-V/WHP 检测功能</strong>，能识别虚拟机是否运行在虚拟化层下，方便诊断性能问题。</p> </li>
</ul>
<p>系统兼容性也大幅扩展：</p>
<ul>
<li> <p>支持最新 CPU 平台，包括 Intel Lunar Lake、Arrow Lake、Meteor Lake 等。</p> </li>
<li> <p>新增对多种 Linux 发行版和 macOS Tahoe 的宿主及客户系统支持。</p> </li>
</ul>
<p>此外，25H2 版本修复了多项稳定性与安全问题，如 Linux 全屏崩溃、Intel GPU 3D 加速故障、UI 控件异常等；Fusion 还解决了键盘输入与 USB 设置无法保存的问题。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>VMware 发布了最新版本的桌面虚拟化产品 —— <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.vmware.com%2Fcloud-foundation%2F2025%2F10%2F14%2Fvmware-workstation-fusion-25h2-embracing-calendar-versioning-and-new-features%2F" target="_blank"><strong>Workstation 25H2</strong> 与 <strong>Fusion 25H2</strong></a>。这次更新首次采用“<strong>日历版本命名法</strong>”，用年份和半年标识版本（如 25H2 表示 2025 年下半年），让版本周期更清晰、统一。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-19aadae3ba.png"></p>
<p>新版带来了多项重要功能与改进：</p>
<ul>
<li> <p><strong>新增 dictTool 工具</strong>，允许用户通过命令行快速查看和编辑虚拟机配置文件，提升自动化与可定制能力。</p> </li>
<li> <p><strong>全面支持 USB 3.2</strong>，提升外设兼容性与数据传输速率。</p> </li>
<li> <p><strong>硬件版本更新至 22</strong>，为虚拟机解锁更多现代化硬件特性。</p> </li>
<li> <p><strong>Workstation 新增 Hyper-V/WHP 检测功能</strong>，能识别虚拟机是否运行在虚拟化层下，方便诊断性能问题。</p> </li>
</ul>
<p>系统兼容性也大幅扩展：</p>
<ul>
<li> <p>支持最新 CPU 平台，包括 Intel Lunar Lake、Arrow Lake、Meteor Lake 等。</p> </li>
<li> <p>新增对多种 Linux 发行版和 macOS Tahoe 的宿主及客户系统支持。</p> </li>
</ul>
<p>此外，25H2 版本修复了多项稳定性与安全问题，如 Linux 全屏崩溃、Intel GPU 3D 加速故障、UI 控件异常等；Fusion 还解决了键盘输入与 USB 设置无法保存的问题。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>VMware 发布了最新版本的桌面虚拟化产品 —— <a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fblogs.vmware.com%2Fcloud-foundation%2F2025%2F10%2F14%2Fvmware-workstation-fusion-25h2-embracing-calendar-versioning-and-new-features%2F" target="_blank"><strong>Workstation 25H2</strong> 与 <strong>Fusion 25H2</strong></a>。这次更新首次采用“<strong>日历版本命名法</strong>”，用年份和半年标识版本（如 25H2 表示 2025 年下半年），让版本周期更清晰、统一。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-19aadae3ba.png"></p>
<p>新版带来了多项重要功能与改进：</p>
<ul>
<li> <p><strong>新增 dictTool 工具</strong>，允许用户通过命令行快速查看和编辑虚拟机配置文件，提升自动化与可定制能力。</p> </li>
<li> <p><strong>全面支持 USB 3.2</strong>，提升外设兼容性与数据传输速率。</p> </li>
<li> <p><strong>硬件版本更新至 22</strong>，为虚拟机解锁更多现代化硬件特性。</p> </li>
<li> <p><strong>Workstation 新增 Hyper-V/WHP 检测功能</strong>，能识别虚拟机是否运行在虚拟化层下，方便诊断性能问题。</p> </li>
</ul>
<p>系统兼容性也大幅扩展：</p>
<ul>
<li> <p>支持最新 CPU 平台，包括 Intel Lunar Lake、Arrow Lake、Meteor Lake 等。</p> </li>
<li> <p>新增对多种 Linux 发行版和 macOS Tahoe 的宿主及客户系统支持。</p> </li>
</ul>
<p>此外，25H2 版本修复了多项稳定性与安全问题，如 Linux 全屏崩溃、Intel GPU 3D 加速故障、UI 控件异常等；Fusion 还解决了键盘输入与 USB 设置无法保存的问题。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-19aadae3ba.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-19aadae3ba.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 10:03:55 +0800</pubDate>
  </item><item>
    <title><![CDATA[苹果连续 12 年蝉联全球最具价值品牌]]></title>
    <link>https://www.oschina.net/news/377904</link>
    <itunes:title><![CDATA[苹果连续 12 年蝉联全球最具价值品牌]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>Interbrand 发布的《2025年全球<span>最佳</span>品牌》报告指出，苹果公司凭借其持久的信任和卓越的设计体验，连续第十二年荣登榜首。这证明了在“算法炒作”时代，品牌的核心价值和生态系统连贯性仍是决定性因素。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5ab1e01876.png"></p>
<p>报告显示，苹果的品牌价值为 4709亿美元，较2024年轻微下降4%，但这被 Interbrand 描述为一种“暂停，而非逆转”。紧随其后的四大品牌均为科技巨头:</p>
<ul>
<li> <p>微软（第二）：3885亿美元</p> </li>
<li> <p>亚马逊（第三）：3199亿美元</p> </li>
<li> <p>谷歌（第四）：3171亿美元</p> </li>
</ul>
<p>尽管价值略有下滑，苹果的品牌价值仍比第二名的微软高出800多亿美元。前100个品牌的总价值上涨4.4%，达到 3.6万亿美元，显示出市场在 AI 影响下的稳步增长。</p>
<p>Interbrand 将苹果誉为“云端之上的品牌”，指出其是少数几个在很大程度上能够自主决策、而非受算法左右的品牌之一。苹果的优势不仅在于其硬件产品（iPhone、Mac、Apple Watch），更在于其紧密相连的生态系统，塑造了人们生活、工作和保持联系的方式。</p>
<p>报告强调，在竞争对手追逐速度和炫酷时，苹果通过控制、隐私和一致性来建立信任。这种“创新与克制”之间的平衡，使得即使在下一个突破尚未显现时，用户仍会留在其生态系统内。</p>
<p>Interbrand 将2025年视为一个新时代的开端——“代理商务”。在这个新模式下，消费者将把选择权委托给 AI 代理，由其进行研究、比较和购买，而无需人工参与。传统的客户旅程（认知、研究和购买）将被压缩到几秒钟，算法而非广告将开始引导决策。</p>
<p>报告警告称，这种转变更加注重实用性而非身份认同，对建立在情感依恋基础上的品牌构成了“意义的考验”。“如果你的品牌不是不可或缺的，它很可能会变得可有可无。”</p>
<p>Interbrand 的核心指标——品牌作用指数（RBI）——量化了品牌本身对购买决策的推动作用。苹果的高 RBI 反映出消费者购买的不仅仅是产品，更是品牌所代表的意义。Interbrand 认为，未来的<span>领导者</span>将是那些既为“机器人”设计，又为“人类”设计的品牌。苹果凭借其无缝集成和以人为本的设计，占据了独特的地位。</p>
<p>在榜单中，发展势头正转向那些推动或扩展 AI 的公司。NVIDIA 的品牌价值飙升 116%，达到432亿美元，创下该报告历史上的<span>最大</span>增幅。YouTube、Instagram 和 Netflix 等通过算法驱动用户参与的文化平台也实现了两位数的增长。苹果的适度下滑被视为走向成熟，其领先优势源于持久力，而非<span>最新</span>的创新。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>Interbrand 发布的《2025年全球<span>最佳</span>品牌》报告指出，苹果公司凭借其持久的信任和卓越的设计体验，连续第十二年荣登榜首。这证明了在“算法炒作”时代，品牌的核心价值和生态系统连贯性仍是决定性因素。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5ab1e01876.png"></p>
<p>报告显示，苹果的品牌价值为 4709亿美元，较2024年轻微下降4%，但这被 Interbrand 描述为一种“暂停，而非逆转”。紧随其后的四大品牌均为科技巨头:</p>
<ul>
<li> <p>微软（第二）：3885亿美元</p> </li>
<li> <p>亚马逊（第三）：3199亿美元</p> </li>
<li> <p>谷歌（第四）：3171亿美元</p> </li>
</ul>
<p>尽管价值略有下滑，苹果的品牌价值仍比第二名的微软高出800多亿美元。前100个品牌的总价值上涨4.4%，达到 3.6万亿美元，显示出市场在 AI 影响下的稳步增长。</p>
<p>Interbrand 将苹果誉为“云端之上的品牌”，指出其是少数几个在很大程度上能够自主决策、而非受算法左右的品牌之一。苹果的优势不仅在于其硬件产品（iPhone、Mac、Apple Watch），更在于其紧密相连的生态系统，塑造了人们生活、工作和保持联系的方式。</p>
<p>报告强调，在竞争对手追逐速度和炫酷时，苹果通过控制、隐私和一致性来建立信任。这种“创新与克制”之间的平衡，使得即使在下一个突破尚未显现时，用户仍会留在其生态系统内。</p>
<p>Interbrand 将2025年视为一个新时代的开端——“代理商务”。在这个新模式下，消费者将把选择权委托给 AI 代理，由其进行研究、比较和购买，而无需人工参与。传统的客户旅程（认知、研究和购买）将被压缩到几秒钟，算法而非广告将开始引导决策。</p>
<p>报告警告称，这种转变更加注重实用性而非身份认同，对建立在情感依恋基础上的品牌构成了“意义的考验”。“如果你的品牌不是不可或缺的，它很可能会变得可有可无。”</p>
<p>Interbrand 的核心指标——品牌作用指数（RBI）——量化了品牌本身对购买决策的推动作用。苹果的高 RBI 反映出消费者购买的不仅仅是产品，更是品牌所代表的意义。Interbrand 认为，未来的<span>领导者</span>将是那些既为“机器人”设计，又为“人类”设计的品牌。苹果凭借其无缝集成和以人为本的设计，占据了独特的地位。</p>
<p>在榜单中，发展势头正转向那些推动或扩展 AI 的公司。NVIDIA 的品牌价值飙升 116%，达到432亿美元，创下该报告历史上的<span>最大</span>增幅。YouTube、Instagram 和 Netflix 等通过算法驱动用户参与的文化平台也实现了两位数的增长。苹果的适度下滑被视为走向成熟，其领先优势源于持久力，而非<span>最新</span>的创新。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>Interbrand 发布的《2025年全球<span>最佳</span>品牌》报告指出，苹果公司凭借其持久的信任和卓越的设计体验，连续第十二年荣登榜首。这证明了在“算法炒作”时代，品牌的核心价值和生态系统连贯性仍是决定性因素。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5ab1e01876.png"></p>
<p>报告显示，苹果的品牌价值为 4709亿美元，较2024年轻微下降4%，但这被 Interbrand 描述为一种“暂停，而非逆转”。紧随其后的四大品牌均为科技巨头:</p>
<ul>
<li> <p>微软（第二）：3885亿美元</p> </li>
<li> <p>亚马逊（第三）：3199亿美元</p> </li>
<li> <p>谷歌（第四）：3171亿美元</p> </li>
</ul>
<p>尽管价值略有下滑，苹果的品牌价值仍比第二名的微软高出800多亿美元。前100个品牌的总价值上涨4.4%，达到 3.6万亿美元，显示出市场在 AI 影响下的稳步增长。</p>
<p>Interbrand 将苹果誉为“云端之上的品牌”，指出其是少数几个在很大程度上能够自主决策、而非受算法左右的品牌之一。苹果的优势不仅在于其硬件产品（iPhone、Mac、Apple Watch），更在于其紧密相连的生态系统，塑造了人们生活、工作和保持联系的方式。</p>
<p>报告强调，在竞争对手追逐速度和炫酷时，苹果通过控制、隐私和一致性来建立信任。这种“创新与克制”之间的平衡，使得即使在下一个突破尚未显现时，用户仍会留在其生态系统内。</p>
<p>Interbrand 将2025年视为一个新时代的开端——“代理商务”。在这个新模式下，消费者将把选择权委托给 AI 代理，由其进行研究、比较和购买，而无需人工参与。传统的客户旅程（认知、研究和购买）将被压缩到几秒钟，算法而非广告将开始引导决策。</p>
<p>报告警告称，这种转变更加注重实用性而非身份认同，对建立在情感依恋基础上的品牌构成了“意义的考验”。“如果你的品牌不是不可或缺的，它很可能会变得可有可无。”</p>
<p>Interbrand 的核心指标——品牌作用指数（RBI）——量化了品牌本身对购买决策的推动作用。苹果的高 RBI 反映出消费者购买的不仅仅是产品，更是品牌所代表的意义。Interbrand 认为，未来的<span>领导者</span>将是那些既为“机器人”设计，又为“人类”设计的品牌。苹果凭借其无缝集成和以人为本的设计，占据了独特的地位。</p>
<p>在榜单中，发展势头正转向那些推动或扩展 AI 的公司。NVIDIA 的品牌价值飙升 116%，达到432亿美元，创下该报告历史上的<span>最大</span>增幅。YouTube、Instagram 和 Netflix 等通过算法驱动用户参与的文化平台也实现了两位数的增长。苹果的适度下滑被视为走向成熟，其领先优势源于持久力，而非<span>最新</span>的创新。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5ab1e01876.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5ab1e01876.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 10:02:05 +0800</pubDate>
  </item><item>
    <title><![CDATA[跨平台原生 UI 框架 AtomUI OSS 5.0.0 发布]]></title>
    <link>https://www.oschina.net/news/377881/atomui-5-0-0-released</link>
    <itunes:title><![CDATA[跨平台原生 UI 框架 AtomUI OSS 5.0.0 发布]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6a5be63919.png"></p>
<p>很高兴在这里宣布 AtomUI OSS 5.0.0 版本发布，本次更新给各位开发者朋友带来了新的 Steps 控件以及优化对 Application 类的控制权，同时修复了若干 BUG。</p>
<p><span><strong><span>新特性</span></strong></span></p>
<ol>
<li> <p><span>新增 Steps 控件</span></p> </li>
<li> <p><span>数据表格新增操作提示器</span></p> </li>
</ol>
<p><strong><span>优化</span></strong></p>
<ol>
<li> <p><span>优化 NavMenu 控件结构，重写底层结构，支持用数据源绑定的方式生成导航菜单</span></p> </li>
<li> <p><span>优化</span><span><span>对 Application 的接管，改用 IThemeManager 的方式，方便Prism 等框架进行整合</span></span></p> </li>
<li> <p><span><span>优化 combobox 控件的 Popup，支持开发者自己指定显示条目的数量</span></span></p> </li>
<li> <p><span><span>优化 CircleProgress，现在支持自己指定成功和失败的图标</span></span></p> </li>
<li> <p><span><span>优化 SelectableTextBlock 控件</span></span></p> </li>
<li> <p><span><span>优化 LoadingIndicator，重名为 Spin，并且彻底重写</span></span></p> </li>
</ol>
<p><strong><span>Bug 修复</span></strong></p>
<ol>
<li> <p><span>修复在苹果系统下编译方法不存在的问题</span></p> </li>
<li> <p><span>修复点击 DataGrid 的行标题报异常</span></p> </li>
<li> <p><span>修复系统字体干扰问题</span></p> </li>
<li> <p><span>修复 Button 设置字体为斜体的时候，部分字母显示不全</span></p> </li>
<li> <p><span>修复 ColorPicker 关闭色彩选择框后，再打开就失效了</span></p> </li>
<li> <p><span>修复 atom:Window 的 IsTitleBarVisible 属性无效</span></p> </li>
</ol>
<p><strong>关于 5.0.0 版本的说明</strong></p>
<p><span>开发者朋友可能比较疑惑，为什么 AtomUI OSS 的版本一下飙升到 5.0，这里我给大家进行说明一下。因为 AtomUI OSS 本质上是 Ant Design 5.0 设计语言的 Avalonia/.NET 实现，为了降低对开发者的解释成本，AtomUI OSS 从这个版本开始锚定 Ant Design 的主版本。</span></p>
<p><span>例如：</span></p>
<p>AtomUI OSS 5.0 -&gt; Ant Design 5.0<br> AtomUI OSS 6.0 -&gt; Ant Design 6.0<br> AtomUI OSS 7.0 -&gt; Ant Design 7.0</p>
<p><span>并且以此类推</span></p>
<hr>
<p>AtomUI OSS 发展离不开开发者朋友的支持和帮助，如果您在使用过程中，发现任何问题欢迎在我们的开发者群和 Gitee 或者 Github 上给我们留下宝贵的意见，谢谢！</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e621d8308f.png"></p>
<hr>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-edfcfff0ff.png"></p>
<p><span>北京秦派软件科技有限公司 (Qinware Technologie</span><span>s&nbsp;</span><span><span>Co., Ltd.</span></span><span>)</span><span>&nbsp;是一家致力于开发生产力工具软件的技术公司，成立之初立志要在工具软件领域深耕，践行精益求精的研发精神，努力推出优质的生产力工具软件服务国内外的开发者，提升开发者的工作效率，同时创造出商业价值和社会价值。</span></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6a5be63919.png"></p>
<p>很高兴在这里宣布 AtomUI OSS 5.0.0 版本发布，本次更新给各位开发者朋友带来了新的 Steps 控件以及优化对 Application 类的控制权，同时修复了若干 BUG。</p>
<p><span><strong><span>新特性</span></strong></span></p>
<ol>
<li> <p><span>新增 Steps 控件</span></p> </li>
<li> <p><span>数据表格新增操作提示器</span></p> </li>
</ol>
<p><strong><span>优化</span></strong></p>
<ol>
<li> <p><span>优化 NavMenu 控件结构，重写底层结构，支持用数据源绑定的方式生成导航菜单</span></p> </li>
<li> <p><span>优化</span><span><span>对 Application 的接管，改用 IThemeManager 的方式，方便Prism 等框架进行整合</span></span></p> </li>
<li> <p><span><span>优化 combobox 控件的 Popup，支持开发者自己指定显示条目的数量</span></span></p> </li>
<li> <p><span><span>优化 CircleProgress，现在支持自己指定成功和失败的图标</span></span></p> </li>
<li> <p><span><span>优化 SelectableTextBlock 控件</span></span></p> </li>
<li> <p><span><span>优化 LoadingIndicator，重名为 Spin，并且彻底重写</span></span></p> </li>
</ol>
<p><strong><span>Bug 修复</span></strong></p>
<ol>
<li> <p><span>修复在苹果系统下编译方法不存在的问题</span></p> </li>
<li> <p><span>修复点击 DataGrid 的行标题报异常</span></p> </li>
<li> <p><span>修复系统字体干扰问题</span></p> </li>
<li> <p><span>修复 Button 设置字体为斜体的时候，部分字母显示不全</span></p> </li>
<li> <p><span>修复 ColorPicker 关闭色彩选择框后，再打开就失效了</span></p> </li>
<li> <p><span>修复 atom:Window 的 IsTitleBarVisible 属性无效</span></p> </li>
</ol>
<p><strong>关于 5.0.0 版本的说明</strong></p>
<p><span>开发者朋友可能比较疑惑，为什么 AtomUI OSS 的版本一下飙升到 5.0，这里我给大家进行说明一下。因为 AtomUI OSS 本质上是 Ant Design 5.0 设计语言的 Avalonia/.NET 实现，为了降低对开发者的解释成本，AtomUI OSS 从这个版本开始锚定 Ant Design 的主版本。</span></p>
<p><span>例如：</span></p>
<p>AtomUI OSS 5.0 -&gt; Ant Design 5.0<br> AtomUI OSS 6.0 -&gt; Ant Design 6.0<br> AtomUI OSS 7.0 -&gt; Ant Design 7.0</p>
<p><span>并且以此类推</span></p>
<hr>
<p>AtomUI OSS 发展离不开开发者朋友的支持和帮助，如果您在使用过程中，发现任何问题欢迎在我们的开发者群和 Gitee 或者 Github 上给我们留下宝贵的意见，谢谢！</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e621d8308f.png"></p>
<hr>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-edfcfff0ff.png"></p>
<p><span>北京秦派软件科技有限公司 (Qinware Technologie</span><span>s&nbsp;</span><span><span>Co., Ltd.</span></span><span>)</span><span>&nbsp;是一家致力于开发生产力工具软件的技术公司，成立之初立志要在工具软件领域深耕，践行精益求精的研发精神，努力推出优质的生产力工具软件服务国内外的开发者，提升开发者的工作效率，同时创造出商业价值和社会价值。</span></p>]]>
    </description>
    <content:encoded><![CDATA[<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6a5be63919.png"></p>
<p>很高兴在这里宣布 AtomUI OSS 5.0.0 版本发布，本次更新给各位开发者朋友带来了新的 Steps 控件以及优化对 Application 类的控制权，同时修复了若干 BUG。</p>
<p><span><strong><span>新特性</span></strong></span></p>
<ol>
<li> <p><span>新增 Steps 控件</span></p> </li>
<li> <p><span>数据表格新增操作提示器</span></p> </li>
</ol>
<p><strong><span>优化</span></strong></p>
<ol>
<li> <p><span>优化 NavMenu 控件结构，重写底层结构，支持用数据源绑定的方式生成导航菜单</span></p> </li>
<li> <p><span>优化</span><span><span>对 Application 的接管，改用 IThemeManager 的方式，方便Prism 等框架进行整合</span></span></p> </li>
<li> <p><span><span>优化 combobox 控件的 Popup，支持开发者自己指定显示条目的数量</span></span></p> </li>
<li> <p><span><span>优化 CircleProgress，现在支持自己指定成功和失败的图标</span></span></p> </li>
<li> <p><span><span>优化 SelectableTextBlock 控件</span></span></p> </li>
<li> <p><span><span>优化 LoadingIndicator，重名为 Spin，并且彻底重写</span></span></p> </li>
</ol>
<p><strong><span>Bug 修复</span></strong></p>
<ol>
<li> <p><span>修复在苹果系统下编译方法不存在的问题</span></p> </li>
<li> <p><span>修复点击 DataGrid 的行标题报异常</span></p> </li>
<li> <p><span>修复系统字体干扰问题</span></p> </li>
<li> <p><span>修复 Button 设置字体为斜体的时候，部分字母显示不全</span></p> </li>
<li> <p><span>修复 ColorPicker 关闭色彩选择框后，再打开就失效了</span></p> </li>
<li> <p><span>修复 atom:Window 的 IsTitleBarVisible 属性无效</span></p> </li>
</ol>
<p><strong>关于 5.0.0 版本的说明</strong></p>
<p><span>开发者朋友可能比较疑惑，为什么 AtomUI OSS 的版本一下飙升到 5.0，这里我给大家进行说明一下。因为 AtomUI OSS 本质上是 Ant Design 5.0 设计语言的 Avalonia/.NET 实现，为了降低对开发者的解释成本，AtomUI OSS 从这个版本开始锚定 Ant Design 的主版本。</span></p>
<p><span>例如：</span></p>
<p>AtomUI OSS 5.0 -&gt; Ant Design 5.0<br> AtomUI OSS 6.0 -&gt; Ant Design 6.0<br> AtomUI OSS 7.0 -&gt; Ant Design 7.0</p>
<p><span>并且以此类推</span></p>
<hr>
<p>AtomUI OSS 发展离不开开发者朋友的支持和帮助，如果您在使用过程中，发现任何问题欢迎在我们的开发者群和 Gitee 或者 Github 上给我们留下宝贵的意见，谢谢！</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e621d8308f.png"></p>
<hr>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-edfcfff0ff.png"></p>
<p><span>北京秦派软件科技有限公司 (Qinware Technologie</span><span>s&nbsp;</span><span><span>Co., Ltd.</span></span><span>)</span><span>&nbsp;是一家致力于开发生产力工具软件的技术公司，成立之初立志要在工具软件领域深耕，践行精益求精的研发精神，努力推出优质的生产力工具软件服务国内外的开发者，提升开发者的工作效率，同时创造出商业价值和社会价值。</span></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6a5be63919.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6a5be63919.png" medium="image"/>
    <pubDate>Fri, 17 Oct 2025 09:20:08 +0800</pubDate>
  </item><item>
    <title><![CDATA[豆包大模型 1.6 升级，原生支持 4 种思考长度]]></title>
    <link>https://www.oschina.net/news/377820</link>
    <itunes:title><![CDATA[豆包大模型 1.6 升级，原生支持 4 种思考长度]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>豆包大模型1.6发布全新升级：提供 Minimal、Low、Medium、High 四种思考长度，据称是<strong>国内首个原生支持“分档调节思考长度”的模型</strong>。</p>
<p>以低思考长度为例，相比模型升级之前的单一思考模式，升级后的豆包1.6模型总输出 Tokens下降77.5%、思考时间下降84.6%，模型效果保持不变。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-82291d1bf4.png"></p>
<p>此外，为进一步满足企业的多样化需求，火山引擎正式推出豆包大模型1.6 lite（Doubao-Seed-1.6-lite），相比旗舰模型豆包1.6更轻量、推理速度更快、更具性价比。</p>
<p>效果上，该模型超越豆包大模型1.5 pro（Doubao-Seed-1.5-pro），在企业级场景测评中较豆包1.5 pro提升14%；价格上，在使用量最大的0-32k 输入区间里，综合使用成本较豆包1.5 pro 降低53.3%。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>豆包大模型1.6发布全新升级：提供 Minimal、Low、Medium、High 四种思考长度，据称是<strong>国内首个原生支持“分档调节思考长度”的模型</strong>。</p>
<p>以低思考长度为例，相比模型升级之前的单一思考模式，升级后的豆包1.6模型总输出 Tokens下降77.5%、思考时间下降84.6%，模型效果保持不变。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-82291d1bf4.png"></p>
<p>此外，为进一步满足企业的多样化需求，火山引擎正式推出豆包大模型1.6 lite（Doubao-Seed-1.6-lite），相比旗舰模型豆包1.6更轻量、推理速度更快、更具性价比。</p>
<p>效果上，该模型超越豆包大模型1.5 pro（Doubao-Seed-1.5-pro），在企业级场景测评中较豆包1.5 pro提升14%；价格上，在使用量最大的0-32k 输入区间里，综合使用成本较豆包1.5 pro 降低53.3%。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>豆包大模型1.6发布全新升级：提供 Minimal、Low、Medium、High 四种思考长度，据称是<strong>国内首个原生支持“分档调节思考长度”的模型</strong>。</p>
<p>以低思考长度为例，相比模型升级之前的单一思考模式，升级后的豆包1.6模型总输出 Tokens下降77.5%、思考时间下降84.6%，模型效果保持不变。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-82291d1bf4.png"></p>
<p>此外，为进一步满足企业的多样化需求，火山引擎正式推出豆包大模型1.6 lite（Doubao-Seed-1.6-lite），相比旗舰模型豆包1.6更轻量、推理速度更快、更具性价比。</p>
<p>效果上，该模型超越豆包大模型1.5 pro（Doubao-Seed-1.5-pro），在企业级场景测评中较豆包1.5 pro提升14%；价格上，在使用量最大的0-32k 输入区间里，综合使用成本较豆包1.5 pro 降低53.3%。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-82291d1bf4.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-82291d1bf4.png" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 19:33:52 +0800</pubDate>
  </item><item>
    <title><![CDATA[火山引擎发布豆包语音模型2.0，实现语义与情感双突破]]></title>
    <link>https://www.oschina.net/news/377819</link>
    <itunes:title><![CDATA[火山引擎发布豆包语音模型2.0，实现语义与情感双突破]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>火山引擎正式推出豆包语音合成模型2.0（Doubao-Seed-TTS 2.0）与声音复刻模型2.0（Doubao-Seed-ICL 2.0），依托豆包大语言模型全新架构，实现语音从“文本朗读”到“理解式情感表达”的跨越。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-62e9c69f28.png"></p>
<p>此次升级核心在于深度语义与上下文理解能力的突破。语音合成模型可覆盖多轮对话语境，精准呈现语气、停顿与情绪变化，支持语速、声线等指令的精细化控制；声音复刻模型在秒级还原声线基础上，新增情感演绎能力，可适配小说配音、对话交互等多场景。</p>
<p>针对教育场景专项优化后，模型对小初高全学科复杂公式符号的朗读准确率达90%，远超行业平均水平。目前两款模型已上线火山引擎语音控台，服务OPPO、洋葱学园等客户，覆盖对话助手、教育辅助等多元场景。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>火山引擎正式推出豆包语音合成模型2.0（Doubao-Seed-TTS 2.0）与声音复刻模型2.0（Doubao-Seed-ICL 2.0），依托豆包大语言模型全新架构，实现语音从“文本朗读”到“理解式情感表达”的跨越。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-62e9c69f28.png"></p>
<p>此次升级核心在于深度语义与上下文理解能力的突破。语音合成模型可覆盖多轮对话语境，精准呈现语气、停顿与情绪变化，支持语速、声线等指令的精细化控制；声音复刻模型在秒级还原声线基础上，新增情感演绎能力，可适配小说配音、对话交互等多场景。</p>
<p>针对教育场景专项优化后，模型对小初高全学科复杂公式符号的朗读准确率达90%，远超行业平均水平。目前两款模型已上线火山引擎语音控台，服务OPPO、洋葱学园等客户，覆盖对话助手、教育辅助等多元场景。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>火山引擎正式推出豆包语音合成模型2.0（Doubao-Seed-TTS 2.0）与声音复刻模型2.0（Doubao-Seed-ICL 2.0），依托豆包大语言模型全新架构，实现语音从“文本朗读”到“理解式情感表达”的跨越。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-62e9c69f28.png"></p>
<p>此次升级核心在于深度语义与上下文理解能力的突破。语音合成模型可覆盖多轮对话语境，精准呈现语气、停顿与情绪变化，支持语速、声线等指令的精细化控制；声音复刻模型在秒级还原声线基础上，新增情感演绎能力，可适配小说配音、对话交互等多场景。</p>
<p>针对教育场景专项优化后，模型对小初高全学科复杂公式符号的朗读准确率达90%，远超行业平均水平。目前两款模型已上线火山引擎语音控台，服务OPPO、洋葱学园等客户，覆盖对话助手、教育辅助等多元场景。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-62e9c69f28.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-62e9c69f28.png" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 19:30:58 +0800</pubDate>
  </item><item>
    <title><![CDATA[商汤科技与寒武纪达成战略合作，重点推进软硬件的联合优化]]></title>
    <link>https://www.oschina.net/news/377818</link>
    <itunes:title><![CDATA[商汤科技与寒武纪达成战略合作，重点推进软硬件的联合优化]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>商汤科技与中科寒武纪科技股份有限公司（以下简称“寒武纪”）签署面向新发展阶段的战略合作协议，重点推进软硬件的联合优化，并共同构建开放共赢的产业生态。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-f3147d86ac.jpg"></p>
<p>双方将发挥各自领域的技术和产业资源优势，围绕国产化人工智能基础设施构建、垂直业务开拓与科技出海等方向，开展多层次、长期性的深度合作，共同构建更具前瞻性和包容性的AI发展生态。</p>
<p>此次合作积极响应国家“人工智能+”战略部署，结合商汤科技在大模型研发、人工智能基础设施平台构建与产业应用方面的领先能力，以及寒武纪在智能计算芯片与算力基础设施方面的深厚积累，旨在推动形成软硬协同的新一代人工智能国产化发展范式，助力提升人工智能关键环节的自主创新能力和生态影响力。</p>
<p>双方将以智能算力与AI大模型技术为基础，共同探索软硬协同的阶梯式产品创新体系，推动产业智能化转型，并通过生态赋能共同培育高成长性创新企业。双方将以此次战略签约为新起点，力争形成规模化、可复制的商业合作成果。</p>
<p>在芯片适配方面，双方将积极推进最新型号的软硬件产品适配，联合打造面向算力市场的服务方案。</p>
<p>在一体机解决方案上，双方将聚焦企业服务等垂直行业场景，紧密结合各自软硬件能力，打造面向垂直领域的一体机解决方案。</p>
<p>双方还将共同探索在优势区域市场的深度协同，汇聚地方产业资源和行业服务优势，构建更具活力和影响力的区域人工智能繁荣生态。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>商汤科技与中科寒武纪科技股份有限公司（以下简称“寒武纪”）签署面向新发展阶段的战略合作协议，重点推进软硬件的联合优化，并共同构建开放共赢的产业生态。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-f3147d86ac.jpg"></p>
<p>双方将发挥各自领域的技术和产业资源优势，围绕国产化人工智能基础设施构建、垂直业务开拓与科技出海等方向，开展多层次、长期性的深度合作，共同构建更具前瞻性和包容性的AI发展生态。</p>
<p>此次合作积极响应国家“人工智能+”战略部署，结合商汤科技在大模型研发、人工智能基础设施平台构建与产业应用方面的领先能力，以及寒武纪在智能计算芯片与算力基础设施方面的深厚积累，旨在推动形成软硬协同的新一代人工智能国产化发展范式，助力提升人工智能关键环节的自主创新能力和生态影响力。</p>
<p>双方将以智能算力与AI大模型技术为基础，共同探索软硬协同的阶梯式产品创新体系，推动产业智能化转型，并通过生态赋能共同培育高成长性创新企业。双方将以此次战略签约为新起点，力争形成规模化、可复制的商业合作成果。</p>
<p>在芯片适配方面，双方将积极推进最新型号的软硬件产品适配，联合打造面向算力市场的服务方案。</p>
<p>在一体机解决方案上，双方将聚焦企业服务等垂直行业场景，紧密结合各自软硬件能力，打造面向垂直领域的一体机解决方案。</p>
<p>双方还将共同探索在优势区域市场的深度协同，汇聚地方产业资源和行业服务优势，构建更具活力和影响力的区域人工智能繁荣生态。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>商汤科技与中科寒武纪科技股份有限公司（以下简称“寒武纪”）签署面向新发展阶段的战略合作协议，重点推进软硬件的联合优化，并共同构建开放共赢的产业生态。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-f3147d86ac.jpg"></p>
<p>双方将发挥各自领域的技术和产业资源优势，围绕国产化人工智能基础设施构建、垂直业务开拓与科技出海等方向，开展多层次、长期性的深度合作，共同构建更具前瞻性和包容性的AI发展生态。</p>
<p>此次合作积极响应国家“人工智能+”战略部署，结合商汤科技在大模型研发、人工智能基础设施平台构建与产业应用方面的领先能力，以及寒武纪在智能计算芯片与算力基础设施方面的深厚积累，旨在推动形成软硬协同的新一代人工智能国产化发展范式，助力提升人工智能关键环节的自主创新能力和生态影响力。</p>
<p>双方将以智能算力与AI大模型技术为基础，共同探索软硬协同的阶梯式产品创新体系，推动产业智能化转型，并通过生态赋能共同培育高成长性创新企业。双方将以此次战略签约为新起点，力争形成规模化、可复制的商业合作成果。</p>
<p>在芯片适配方面，双方将积极推进最新型号的软硬件产品适配，联合打造面向算力市场的服务方案。</p>
<p>在一体机解决方案上，双方将聚焦企业服务等垂直行业场景，紧密结合各自软硬件能力，打造面向垂直领域的一体机解决方案。</p>
<p>双方还将共同探索在优势区域市场的深度协同，汇聚地方产业资源和行业服务优势，构建更具活力和影响力的区域人工智能繁荣生态。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-f3147d86ac.jpg"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-f3147d86ac.jpg" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 19:27:18 +0800</pubDate>
  </item><item>
    <title><![CDATA[德国州政府全面弃用微软办公套件，改用开源方案]]></title>
    <link>https://www.oschina.net/news/377817</link>
    <itunes:title><![CDATA[德国州政府全面弃用微软办公套件，改用开源方案]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>德国石勒苏益格-荷尔斯泰因州<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.neowin.net%2Fnews%2Fgerman-state-finally-ditches-outlook-now-dumping-office%2F" target="_blank">宣布</a>，已正式完成从微软 Outlook 和 Exchange 迁移至开源邮件系统的工作，并计划全面淘汰 Microsoft Office，改用 LibreOffice。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-88327fe173.png"></p>
<p>此次迁移历时约 6 个月，覆盖州政府、各部委、司法机构和警察部门等约 3 万名员工，邮件和日历数据超过 1 亿条。新系统采用 Open-Xchange 作为服务器端方案，客户端使用 Mozilla Thunderbird。</p>
<p>该州数字化部长 Dirk Schrödter 表示，迁移过程中虽遇到部分技术挑战（例如邮件流量延滞等问题），但整体顺利完成。这一举措是该州“数字主权”战略的重要一步，旨在减少对专有软件的依赖、提升数据安全与自主控制能力。</p>
<p>石勒苏益格-荷尔斯泰因州此前已开始用 LibreOffice 替代 Microsoft Office，成为欧洲政府系统向开源生态转型的重要典范之一。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>德国石勒苏益格-荷尔斯泰因州<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.neowin.net%2Fnews%2Fgerman-state-finally-ditches-outlook-now-dumping-office%2F" target="_blank">宣布</a>，已正式完成从微软 Outlook 和 Exchange 迁移至开源邮件系统的工作，并计划全面淘汰 Microsoft Office，改用 LibreOffice。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-88327fe173.png"></p>
<p>此次迁移历时约 6 个月，覆盖州政府、各部委、司法机构和警察部门等约 3 万名员工，邮件和日历数据超过 1 亿条。新系统采用 Open-Xchange 作为服务器端方案，客户端使用 Mozilla Thunderbird。</p>
<p>该州数字化部长 Dirk Schrödter 表示，迁移过程中虽遇到部分技术挑战（例如邮件流量延滞等问题），但整体顺利完成。这一举措是该州“数字主权”战略的重要一步，旨在减少对专有软件的依赖、提升数据安全与自主控制能力。</p>
<p>石勒苏益格-荷尔斯泰因州此前已开始用 LibreOffice 替代 Microsoft Office，成为欧洲政府系统向开源生态转型的重要典范之一。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>德国石勒苏益格-荷尔斯泰因州<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.neowin.net%2Fnews%2Fgerman-state-finally-ditches-outlook-now-dumping-office%2F" target="_blank">宣布</a>，已正式完成从微软 Outlook 和 Exchange 迁移至开源邮件系统的工作，并计划全面淘汰 Microsoft Office，改用 LibreOffice。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-88327fe173.png"></p>
<p>此次迁移历时约 6 个月，覆盖州政府、各部委、司法机构和警察部门等约 3 万名员工，邮件和日历数据超过 1 亿条。新系统采用 Open-Xchange 作为服务器端方案，客户端使用 Mozilla Thunderbird。</p>
<p>该州数字化部长 Dirk Schrödter 表示，迁移过程中虽遇到部分技术挑战（例如邮件流量延滞等问题），但整体顺利完成。这一举措是该州“数字主权”战略的重要一步，旨在减少对专有软件的依赖、提升数据安全与自主控制能力。</p>
<p>石勒苏益格-荷尔斯泰因州此前已开始用 LibreOffice 替代 Microsoft Office，成为欧洲政府系统向开源生态转型的重要典范之一。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-88327fe173.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-88327fe173.png" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 19:24:04 +0800</pubDate>
  </item><item>
    <title><![CDATA[豆包大模型日均 Tokens 调用量已突破 30 万亿]]></title>
    <link>https://www.oschina.net/news/377815</link>
    <itunes:title><![CDATA[豆包大模型日均 Tokens 调用量已突破 30 万亿]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>10月16日，字节跳动旗下火山引擎披露最新大模型token（大模型文本单位）调用数据。火山引擎总裁谭待现场表示，<span><strong>豆包大模型使用量从2024年5月1200亿tokens增长253倍至今年9月的超30万亿tokens</strong></span>。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-0258565dba.png"></p>
<p>另据调研机构IDC9月报告，2025年上半年，中国公有云大模型调用量达536.7万亿tokens。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-f1ac311b1d.png"></p>
<p>其中，火山引擎以49.2%的市场份额位居中国市场第一，阿里云、百度智能云分别占比27%、17%，位列第二、第三位。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>10月16日，字节跳动旗下火山引擎披露最新大模型token（大模型文本单位）调用数据。火山引擎总裁谭待现场表示，<span><strong>豆包大模型使用量从2024年5月1200亿tokens增长253倍至今年9月的超30万亿tokens</strong></span>。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-0258565dba.png"></p>
<p>另据调研机构IDC9月报告，2025年上半年，中国公有云大模型调用量达536.7万亿tokens。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-f1ac311b1d.png"></p>
<p>其中，火山引擎以49.2%的市场份额位居中国市场第一，阿里云、百度智能云分别占比27%、17%，位列第二、第三位。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>10月16日，字节跳动旗下火山引擎披露最新大模型token（大模型文本单位）调用数据。火山引擎总裁谭待现场表示，<span><strong>豆包大模型使用量从2024年5月1200亿tokens增长253倍至今年9月的超30万亿tokens</strong></span>。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-0258565dba.png"></p>
<p>另据调研机构IDC9月报告，2025年上半年，中国公有云大模型调用量达536.7万亿tokens。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-f1ac311b1d.png"></p>
<p>其中，火山引擎以49.2%的市场份额位居中国市场第一，阿里云、百度智能云分别占比27%、17%，位列第二、第三位。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-0258565dba.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-0258565dba.png" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 19:13:49 +0800</pubDate>
  </item><item>
    <title><![CDATA[Zed 编辑器正式发布 Windows 版本，原生体验超越微软]]></title>
    <link>https://www.oschina.net/news/377813/zed-for-windows-ga</link>
    <itunes:title><![CDATA[Zed 编辑器正式发布 Windows 版本，原生体验超越微软]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>备受开发者喜爱的高性能文本编辑器 Zed 宣布正式支持 Windows 系统，这是继 macOS 与 Linux 之后的又一重要里程碑。团队<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fblog%2Fzed-for-windows-is-here" target="_blank">表示</a>，Windows 版本将与其他平台同步更新，未来会保持每周迭代节奏。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-e56f08c582.png"></p>
<p><em>https://zed.dev/windows</em></p>
<p>Zed for Windows 在性能与系统集成上进行了深度优化，<strong>团队称其在 Windows 上的原生体验甚至超越了微软自家的编辑器</strong>。</p>
<ul>
<li> <p>使用 DirectX 11 和 DirectWrite 进行本地渲染，不依赖 Electron，确保更流畅的界面与文本表现；</p> </li>
<li> <p>支持 WSL 与 SSH 远程开发，可在本地 Zed 界面中无缝操作 Linux 环境或远程服务器；</p> </li>
<li> <p>全面兼容 WASI 扩展系统，插件可跨平台运行，无需额外适配；</p> </li>
<li> <p>内置的 AI 编程功能（包括 Claude Code 与智能编辑代理）在 Windows 平台也已全面启用。</p> </li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-92936e1b0d.png"></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-887ece2b5b.png"></p>
<p>Zed 团队呼吁用户积极反馈在输入法、多显示器、高刷新率显示器等场景下的使用体验，并表示将持续改进 Windows 版本的稳定性与细节打磨。</p>
<p>目前，Zed 已支持 macOS、Linux 和 Windows 三大平台，用户可前往 zed.dev 下载体验。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>备受开发者喜爱的高性能文本编辑器 Zed 宣布正式支持 Windows 系统，这是继 macOS 与 Linux 之后的又一重要里程碑。团队<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fblog%2Fzed-for-windows-is-here" target="_blank">表示</a>，Windows 版本将与其他平台同步更新，未来会保持每周迭代节奏。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-e56f08c582.png"></p>
<p><em>https://zed.dev/windows</em></p>
<p>Zed for Windows 在性能与系统集成上进行了深度优化，<strong>团队称其在 Windows 上的原生体验甚至超越了微软自家的编辑器</strong>。</p>
<ul>
<li> <p>使用 DirectX 11 和 DirectWrite 进行本地渲染，不依赖 Electron，确保更流畅的界面与文本表现；</p> </li>
<li> <p>支持 WSL 与 SSH 远程开发，可在本地 Zed 界面中无缝操作 Linux 环境或远程服务器；</p> </li>
<li> <p>全面兼容 WASI 扩展系统，插件可跨平台运行，无需额外适配；</p> </li>
<li> <p>内置的 AI 编程功能（包括 Claude Code 与智能编辑代理）在 Windows 平台也已全面启用。</p> </li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-92936e1b0d.png"></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-887ece2b5b.png"></p>
<p>Zed 团队呼吁用户积极反馈在输入法、多显示器、高刷新率显示器等场景下的使用体验，并表示将持续改进 Windows 版本的稳定性与细节打磨。</p>
<p>目前，Zed 已支持 macOS、Linux 和 Windows 三大平台，用户可前往 zed.dev 下载体验。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>备受开发者喜爱的高性能文本编辑器 Zed 宣布正式支持 Windows 系统，这是继 macOS 与 Linux 之后的又一重要里程碑。团队<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fzed.dev%2Fblog%2Fzed-for-windows-is-here" target="_blank">表示</a>，Windows 版本将与其他平台同步更新，未来会保持每周迭代节奏。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-e56f08c582.png"></p>
<p><em>https://zed.dev/windows</em></p>
<p>Zed for Windows 在性能与系统集成上进行了深度优化，<strong>团队称其在 Windows 上的原生体验甚至超越了微软自家的编辑器</strong>。</p>
<ul>
<li> <p>使用 DirectX 11 和 DirectWrite 进行本地渲染，不依赖 Electron，确保更流畅的界面与文本表现；</p> </li>
<li> <p>支持 WSL 与 SSH 远程开发，可在本地 Zed 界面中无缝操作 Linux 环境或远程服务器；</p> </li>
<li> <p>全面兼容 WASI 扩展系统，插件可跨平台运行，无需额外适配；</p> </li>
<li> <p>内置的 AI 编程功能（包括 Claude Code 与智能编辑代理）在 Windows 平台也已全面启用。</p> </li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-92936e1b0d.png"></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-887ece2b5b.png"></p>
<p>Zed 团队呼吁用户积极反馈在输入法、多显示器、高刷新率显示器等场景下的使用体验，并表示将持续改进 Windows 版本的稳定性与细节打磨。</p>
<p>目前，Zed 已支持 macOS、Linux 和 Windows 三大平台，用户可前往 zed.dev 下载体验。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-e56f08c582.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-e56f08c582.png" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 19:02:53 +0800</pubDate>
  </item><item>
    <title><![CDATA[阿里发布全新 AI 编程工具 Qoder CLI（命令行界面）]]></title>
    <link>https://www.oschina.net/news/377812</link>
    <itunes:title><![CDATA[阿里发布全新 AI 编程工具 Qoder CLI（命令行界面）]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>10月16日凌晨，阿里全新AI编程工具 Qoder CLI（命令行界面）正式上线，这是一款专为命令行环境打造的 AI Coding Agent。</p>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FOKqBW9IWSOLur-TxDykrTw" target="_blank">官方公告称</a>，Qoder CLI集成了业界最顶尖的编程模型，并设计了轻量级Agent框架。不仅具备强大的代码生成与理解能力，还有效降低内存消耗和命令响应时间，进一步提升开发效率。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-5c6ad0ac3a.png"></p>
<p>据介绍，Qoder CLI内置轻量级的Agent框架，该架构可高效运行在普通笔记本电脑和云端沙箱实例，满足不同场景的开发需求。测试显示，Qoder CLI在空闲状态下消耗的内存比同类工具低70%，常见命令的响应时间不到200ms。</p>
<p>Qoder CLI还内置了Quest模式（自主编程）与CodeReview能力，无需开发者深度介入，就可以轻松实现Spec驱动的任务委派，让 AI 自主完成任务开发。同时在命令行终端即可进行代码审查，帮助用户快速扫描项目中的关键改动点，并给出审查意见，代码审查耗时减少 50%，代码质量提升一倍。此外，Qoder CLI 内置多种工具，支持文件编辑、命令运行与提交创建，并能通过 MCP 灵活扩展或自定义开发工具。</p>
<p>目前，Qoder已拥有IDE和CLI两种产品形态。Qoder CLI技术负责人谢吉宝表示：“我们坚信，未来的开发界面不是IDE 或 CLI，而是IDE + CLI。IDE 提供深度上下文与复杂任务处理，CLI 提供速度、灵活性与自动化能力，这种双引擎模式能覆盖更多场景。就像键盘与鼠标并存，桌面与移动端共存一样，IDE 与 CLI 的组合将成为未来软件开发的标配。”</p>
<p>即日起，全球开发者可通过任意命令行终端体验Qoder CLI。下载体验链接：<em>https://qoder.com/cli</em></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>10月16日凌晨，阿里全新AI编程工具 Qoder CLI（命令行界面）正式上线，这是一款专为命令行环境打造的 AI Coding Agent。</p>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FOKqBW9IWSOLur-TxDykrTw" target="_blank">官方公告称</a>，Qoder CLI集成了业界最顶尖的编程模型，并设计了轻量级Agent框架。不仅具备强大的代码生成与理解能力，还有效降低内存消耗和命令响应时间，进一步提升开发效率。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-5c6ad0ac3a.png"></p>
<p>据介绍，Qoder CLI内置轻量级的Agent框架，该架构可高效运行在普通笔记本电脑和云端沙箱实例，满足不同场景的开发需求。测试显示，Qoder CLI在空闲状态下消耗的内存比同类工具低70%，常见命令的响应时间不到200ms。</p>
<p>Qoder CLI还内置了Quest模式（自主编程）与CodeReview能力，无需开发者深度介入，就可以轻松实现Spec驱动的任务委派，让 AI 自主完成任务开发。同时在命令行终端即可进行代码审查，帮助用户快速扫描项目中的关键改动点，并给出审查意见，代码审查耗时减少 50%，代码质量提升一倍。此外，Qoder CLI 内置多种工具，支持文件编辑、命令运行与提交创建，并能通过 MCP 灵活扩展或自定义开发工具。</p>
<p>目前，Qoder已拥有IDE和CLI两种产品形态。Qoder CLI技术负责人谢吉宝表示：“我们坚信，未来的开发界面不是IDE 或 CLI，而是IDE + CLI。IDE 提供深度上下文与复杂任务处理，CLI 提供速度、灵活性与自动化能力，这种双引擎模式能覆盖更多场景。就像键盘与鼠标并存，桌面与移动端共存一样，IDE 与 CLI 的组合将成为未来软件开发的标配。”</p>
<p>即日起，全球开发者可通过任意命令行终端体验Qoder CLI。下载体验链接：<em>https://qoder.com/cli</em></p>]]>
    </description>
    <content:encoded><![CDATA[<p>10月16日凌晨，阿里全新AI编程工具 Qoder CLI（命令行界面）正式上线，这是一款专为命令行环境打造的 AI Coding Agent。</p>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FOKqBW9IWSOLur-TxDykrTw" target="_blank">官方公告称</a>，Qoder CLI集成了业界最顶尖的编程模型，并设计了轻量级Agent框架。不仅具备强大的代码生成与理解能力，还有效降低内存消耗和命令响应时间，进一步提升开发效率。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-5c6ad0ac3a.png"></p>
<p>据介绍，Qoder CLI内置轻量级的Agent框架，该架构可高效运行在普通笔记本电脑和云端沙箱实例，满足不同场景的开发需求。测试显示，Qoder CLI在空闲状态下消耗的内存比同类工具低70%，常见命令的响应时间不到200ms。</p>
<p>Qoder CLI还内置了Quest模式（自主编程）与CodeReview能力，无需开发者深度介入，就可以轻松实现Spec驱动的任务委派，让 AI 自主完成任务开发。同时在命令行终端即可进行代码审查，帮助用户快速扫描项目中的关键改动点，并给出审查意见，代码审查耗时减少 50%，代码质量提升一倍。此外，Qoder CLI 内置多种工具，支持文件编辑、命令运行与提交创建，并能通过 MCP 灵活扩展或自定义开发工具。</p>
<p>目前，Qoder已拥有IDE和CLI两种产品形态。Qoder CLI技术负责人谢吉宝表示：“我们坚信，未来的开发界面不是IDE 或 CLI，而是IDE + CLI。IDE 提供深度上下文与复杂任务处理，CLI 提供速度、灵活性与自动化能力，这种双引擎模式能覆盖更多场景。就像键盘与鼠标并存，桌面与移动端共存一样，IDE 与 CLI 的组合将成为未来软件开发的标配。”</p>
<p>即日起，全球开发者可通过任意命令行终端体验Qoder CLI。下载体验链接：<em>https://qoder.com/cli</em></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-5c6ad0ac3a.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/static.oschina.net-5c6ad0ac3a.png" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 18:46:07 +0800</pubDate>
  </item><item>
    <title><![CDATA[百度搜索 AI 短剧生成平台开启公测]]></title>
    <link>https://www.oschina.net/news/377811</link>
    <itunes:title><![CDATA[百度搜索 AI 短剧生成平台开启公测]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><span>百度搜索正式宣布其 AI 短剧生成平台的公测上线。这一平台旨在通过亿元创作基金和百亿流量的支持，全面提升创作者的内容创作能力，助力他们实现长久的 IP 变现。</span></p>
<p><span><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-62cb2d12a9.png"></span></p>
<p><span>该平台具备自动生成和人机协作等多种创作模式，可以有效辅助创作者完成超过80% 的内容创作任务。创作者只需在 AI 生成的基础上进行微调与优化，便能快速产出高质量的短剧作品。此外，平台还能保持创作风格的一致性，实现批量生产，极大提升创作效率，并降低制作成本。</span></p>
<p><span>为了解决创作者在内容创作中面临的版权问题，百度搜索将联合多家知名版权方，为创作者提供丰富的 IP 资源。创作者可以将更多精力集中在内容创作上，无需担心版权问题。同时，对于优质和热门内容，百度也将提供深度的 IP 孵化和经营模式，帮助创作者实现多元化的变现路径。</span></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><span>百度搜索正式宣布其 AI 短剧生成平台的公测上线。这一平台旨在通过亿元创作基金和百亿流量的支持，全面提升创作者的内容创作能力，助力他们实现长久的 IP 变现。</span></p>
<p><span><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-62cb2d12a9.png"></span></p>
<p><span>该平台具备自动生成和人机协作等多种创作模式，可以有效辅助创作者完成超过80% 的内容创作任务。创作者只需在 AI 生成的基础上进行微调与优化，便能快速产出高质量的短剧作品。此外，平台还能保持创作风格的一致性，实现批量生产，极大提升创作效率，并降低制作成本。</span></p>
<p><span>为了解决创作者在内容创作中面临的版权问题，百度搜索将联合多家知名版权方，为创作者提供丰富的 IP 资源。创作者可以将更多精力集中在内容创作上，无需担心版权问题。同时，对于优质和热门内容，百度也将提供深度的 IP 孵化和经营模式，帮助创作者实现多元化的变现路径。</span></p>]]>
    </description>
    <content:encoded><![CDATA[<p><span>百度搜索正式宣布其 AI 短剧生成平台的公测上线。这一平台旨在通过亿元创作基金和百亿流量的支持，全面提升创作者的内容创作能力，助力他们实现长久的 IP 变现。</span></p>
<p><span><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-62cb2d12a9.png"></span></p>
<p><span>该平台具备自动生成和人机协作等多种创作模式，可以有效辅助创作者完成超过80% 的内容创作任务。创作者只需在 AI 生成的基础上进行微调与优化，便能快速产出高质量的短剧作品。此外，平台还能保持创作风格的一致性，实现批量生产，极大提升创作效率，并降低制作成本。</span></p>
<p><span>为了解决创作者在内容创作中面临的版权问题，百度搜索将联合多家知名版权方，为创作者提供丰富的 IP 资源。创作者可以将更多精力集中在内容创作上，无需担心版权问题。同时，对于优质和热门内容，百度也将提供深度的 IP 孵化和经营模式，帮助创作者实现多元化的变现路径。</span></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-62cb2d12a9.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-62cb2d12a9.png" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 18:42:41 +0800</pubDate>
  </item><item>
    <title><![CDATA[甲骨文联席 CEO 为巨额 AI 数据中心投资辩护]]></title>
    <link>https://www.oschina.net/news/377810</link>
    <itunes:title><![CDATA[甲骨文联席 CEO 为巨额 AI 数据中心投资辩护]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>据媒体报道，甲骨文（Oracle）两位新任联席首席执行官本周为公司大规模数据中心扩张计划辩护。新任联席CEO迈克·西西里亚表示，公司正致力于交付“应用型AI”，涵盖基础设施、分析与企业应用等多个层面。</p>
<p>另一位高管克莱·马古伊尔克补充称，甲骨文的AI数据平台可帮助客户在自身数据旁完成模型推理，预计客户AI使用量将增长多达千倍。</p>
<p>面对投资者对利润率与债务水平的质疑，马古伊尔克回应称，当前低利润属于AI基础设施建设初期特征，“随着客户消费启动，毛利率将显著改善”。TD Cowen分析师认为，前期投入高但规模化后盈利能力将释放。</p>
<p>为支撑扩张，甲骨文9月底发行180亿美元债券，用于AI数据中心融资，包括与OpenAI合作的“星门”项目。马古伊尔克强调，公司客户结构多元，“几乎所有大型模型公司都在不同程度上使用我们的云服务，这种多元化远超市场想象”。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>据媒体报道，甲骨文（Oracle）两位新任联席首席执行官本周为公司大规模数据中心扩张计划辩护。新任联席CEO迈克·西西里亚表示，公司正致力于交付“应用型AI”，涵盖基础设施、分析与企业应用等多个层面。</p>
<p>另一位高管克莱·马古伊尔克补充称，甲骨文的AI数据平台可帮助客户在自身数据旁完成模型推理，预计客户AI使用量将增长多达千倍。</p>
<p>面对投资者对利润率与债务水平的质疑，马古伊尔克回应称，当前低利润属于AI基础设施建设初期特征，“随着客户消费启动，毛利率将显著改善”。TD Cowen分析师认为，前期投入高但规模化后盈利能力将释放。</p>
<p>为支撑扩张，甲骨文9月底发行180亿美元债券，用于AI数据中心融资，包括与OpenAI合作的“星门”项目。马古伊尔克强调，公司客户结构多元，“几乎所有大型模型公司都在不同程度上使用我们的云服务，这种多元化远超市场想象”。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>据媒体报道，甲骨文（Oracle）两位新任联席首席执行官本周为公司大规模数据中心扩张计划辩护。新任联席CEO迈克·西西里亚表示，公司正致力于交付“应用型AI”，涵盖基础设施、分析与企业应用等多个层面。</p>
<p>另一位高管克莱·马古伊尔克补充称，甲骨文的AI数据平台可帮助客户在自身数据旁完成模型推理，预计客户AI使用量将增长多达千倍。</p>
<p>面对投资者对利润率与债务水平的质疑，马古伊尔克回应称，当前低利润属于AI基础设施建设初期特征，“随着客户消费启动，毛利率将显著改善”。TD Cowen分析师认为，前期投入高但规模化后盈利能力将释放。</p>
<p>为支撑扩张，甲骨文9月底发行180亿美元债券，用于AI数据中心融资，包括与OpenAI合作的“星门”项目。马古伊尔克强调，公司客户结构多元，“几乎所有大型模型公司都在不同程度上使用我们的云服务，这种多元化远超市场想象”。</p>]]></content:encoded>
    
    <pubDate>Thu, 16 Oct 2025 18:34:14 +0800</pubDate>
  </item><item>
    <title><![CDATA[Reddit 联合创始人 Alexis Ohanian 称互联网“大部分已死”]]></title>
    <link>https://www.oschina.net/news/377807</link>
    <itunes:title><![CDATA[Reddit 联合创始人 Alexis Ohanian 称互联网“大部分已死”]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>Reddit联合创始人Alexis Ohanian近日在TBPN播客节目中表达了他对当前互联网状况的担忧和不满。他指出，互联网已经变得“更少人性化，更多是‘类AI’”，“你们证明了互联网的大部分现在已死”。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2e5f4269c1.png"></p>
<p>Ohanian称如今网络充斥着自动机器人与算法生成内容，尤其是所谓的“LinkedIn灌水信息”，并援引了“死去的互联网理论”，即网上的机器人活动已超过人类真实互动。</p>
<p>OpenAI首席执行官Sam Altman也曾在社交平台X上提及，他“曾不太相信死去的互联网理论”，但如今发现“Twitter上大量账户都是由大模型驱动的”。Ohanian强调互联网应该是“有生命力的”，需要“真正的观众和真实的内容”，吸引注意力的关键是“生命的证明”。</p>
<p>Ohanian预计，下一代社交媒体将强调可验证的人类身份。他认为，“人们如今的深度互动都聚集在群组聊天里”，无论是文本还是应用如Signal、Discord，越来越多人倾向于这些平台进行人际交流，一些用户甚至表示已将个人表达从Twitter转向群聊。不过，他也指出，即使是群聊也在被AI介入，某些聊天者已经开始使用AI生成和编辑消息，进一步将机器人引入了这个交流场所。</p>
<p>Ohanian称，群组聊天是当前互联网人际交流的“黄金标准”，但这仍然不是“新技术”。他表示，“必须有新的迭代，因为我们获得最优信息的路径正在发生变化”。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>Reddit联合创始人Alexis Ohanian近日在TBPN播客节目中表达了他对当前互联网状况的担忧和不满。他指出，互联网已经变得“更少人性化，更多是‘类AI’”，“你们证明了互联网的大部分现在已死”。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2e5f4269c1.png"></p>
<p>Ohanian称如今网络充斥着自动机器人与算法生成内容，尤其是所谓的“LinkedIn灌水信息”，并援引了“死去的互联网理论”，即网上的机器人活动已超过人类真实互动。</p>
<p>OpenAI首席执行官Sam Altman也曾在社交平台X上提及，他“曾不太相信死去的互联网理论”，但如今发现“Twitter上大量账户都是由大模型驱动的”。Ohanian强调互联网应该是“有生命力的”，需要“真正的观众和真实的内容”，吸引注意力的关键是“生命的证明”。</p>
<p>Ohanian预计，下一代社交媒体将强调可验证的人类身份。他认为，“人们如今的深度互动都聚集在群组聊天里”，无论是文本还是应用如Signal、Discord，越来越多人倾向于这些平台进行人际交流，一些用户甚至表示已将个人表达从Twitter转向群聊。不过，他也指出，即使是群聊也在被AI介入，某些聊天者已经开始使用AI生成和编辑消息，进一步将机器人引入了这个交流场所。</p>
<p>Ohanian称，群组聊天是当前互联网人际交流的“黄金标准”，但这仍然不是“新技术”。他表示，“必须有新的迭代，因为我们获得最优信息的路径正在发生变化”。</p>]]>
    </description>
    <content:encoded><![CDATA[<p>Reddit联合创始人Alexis Ohanian近日在TBPN播客节目中表达了他对当前互联网状况的担忧和不满。他指出，互联网已经变得“更少人性化，更多是‘类AI’”，“你们证明了互联网的大部分现在已死”。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2e5f4269c1.png"></p>
<p>Ohanian称如今网络充斥着自动机器人与算法生成内容，尤其是所谓的“LinkedIn灌水信息”，并援引了“死去的互联网理论”，即网上的机器人活动已超过人类真实互动。</p>
<p>OpenAI首席执行官Sam Altman也曾在社交平台X上提及，他“曾不太相信死去的互联网理论”，但如今发现“Twitter上大量账户都是由大模型驱动的”。Ohanian强调互联网应该是“有生命力的”，需要“真正的观众和真实的内容”，吸引注意力的关键是“生命的证明”。</p>
<p>Ohanian预计，下一代社交媒体将强调可验证的人类身份。他认为，“人们如今的深度互动都聚集在群组聊天里”，无论是文本还是应用如Signal、Discord，越来越多人倾向于这些平台进行人际交流，一些用户甚至表示已将个人表达从Twitter转向群聊。不过，他也指出，即使是群聊也在被AI介入，某些聊天者已经开始使用AI生成和编辑消息，进一步将机器人引入了这个交流场所。</p>
<p>Ohanian称，群组聊天是当前互联网人际交流的“黄金标准”，但这仍然不是“新技术”。他表示，“必须有新的迭代，因为我们获得最优信息的路径正在发生变化”。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2e5f4269c1.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2e5f4269c1.png" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 18:26:38 +0800</pubDate>
  </item><item>
    <title><![CDATA[Jetski - MCP 分析和认证平台]]></title>
    <link>https://www.oschina.net/p/jetski</link>
    <itunes:title><![CDATA[Jetski - MCP 分析和认证平台]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>Jetski 是一个<strong>开源 MCP 分析和身份验证平台</strong>，隶属于 HyprMCP。它解决了团队在开发 MCP 服务器时面临的三大问题，且<strong>无需修改任何代码</strong>：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<ol>
<li><strong>安装和设置</strong>：大多数用户从未完成过设置。他们找不到客户端说明，或者无法在浏览器中打开您的 MCP 网址，因此立即流失。</li>
<li><strong>身份验证</strong>：识别用户并为他们提供正确的工具和响应仍然很难实现。</li>
<li><strong>日志、分析和可见性</strong>：无法了解你的 MCP 如何使用、哪些提示触发哪些工具或为什么会发生错误。</li>
</ol>
<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>平台管理和部署<strong>位于你的 MCP 服务器前端</strong>的<a href="https://github.com/hyprmcp/mcp-gateway"><code>mcp-gateway</code></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>实例，并处理复杂的事务。它还收集并汇总网关捕获的所有分析和指标数据。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div>
<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>Jetski 仍在积极开发中，尚处于起步阶段。API 和命令行界面可能会以向后不兼容的方式发生变化。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</div>
<h2><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>特点</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2>
<ul>
<li><strong>全面的提示分析</strong>&nbsp;查看哪些提示触发了哪些工具、来自哪些客户端以及发生了什么。全面了解你的 MCP 服务器使用模式，并实时了解用户如何与你的工具交互。</li>
<li><strong>自动生成的设置说明，</strong>帮助用户轻松连接到客户端。为每个支持的 MCP 客户端自动生成清晰的分步说明，消除用户在入门过程中流失的首要原因。</li>
<li>
<p><strong>零代码身份验证，</strong>无需编写任何代码即可安全地识别和管理用户。代理可处理所有身份验证逻辑，让你能够根据用户身份提供个性化的工具和响应。</p>
</li>
<li>
<p><strong>实时调试日志&nbsp;</strong>即时调试问题并实时了解服务器行为。查看每个请求、响应和错误的详细日志，轻松快速地识别和修复问题。</p>
</li>
</ul>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>Jetski 是一个<strong>开源 MCP 分析和身份验证平台</strong>，隶属于 HyprMCP。它解决了团队在开发 MCP 服务器时面临的三大问题，且<strong>无需修改任何代码</strong>：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<ol>
<li><strong>安装和设置</strong>：大多数用户从未完成过设置。他们找不到客户端说明，或者无法在浏览器中打开您的 MCP 网址，因此立即流失。</li>
<li><strong>身份验证</strong>：识别用户并为他们提供正确的工具和响应仍然很难实现。</li>
<li><strong>日志、分析和可见性</strong>：无法了解你的 MCP 如何使用、哪些提示触发哪些工具或为什么会发生错误。</li>
</ol>
<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>平台管理和部署<strong>位于你的 MCP 服务器前端</strong>的<a href="https://github.com/hyprmcp/mcp-gateway"><code>mcp-gateway</code></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>实例，并处理复杂的事务。它还收集并汇总网关捕获的所有分析和指标数据。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div>
<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>Jetski 仍在积极开发中，尚处于起步阶段。API 和命令行界面可能会以向后不兼容的方式发生变化。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</div>
<h2><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>特点</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2>
<ul>
<li><strong>全面的提示分析</strong>&nbsp;查看哪些提示触发了哪些工具、来自哪些客户端以及发生了什么。全面了解你的 MCP 服务器使用模式，并实时了解用户如何与你的工具交互。</li>
<li><strong>自动生成的设置说明，</strong>帮助用户轻松连接到客户端。为每个支持的 MCP 客户端自动生成清晰的分步说明，消除用户在入门过程中流失的首要原因。</li>
<li>
<p><strong>零代码身份验证，</strong>无需编写任何代码即可安全地识别和管理用户。代理可处理所有身份验证逻辑，让你能够根据用户身份提供个性化的工具和响应。</p>
</li>
<li>
<p><strong>实时调试日志&nbsp;</strong>即时调试问题并实时了解服务器行为。查看每个请求、响应和错误的详细日志，轻松快速地识别和修复问题。</p>
</li>
</ul>]]>
    </description>
    <content:encoded><![CDATA[<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>Jetski 是一个<strong>开源 MCP 分析和身份验证平台</strong>，隶属于 HyprMCP。它解决了团队在开发 MCP 服务器时面临的三大问题，且<strong>无需修改任何代码</strong>：</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<ol>
<li><strong>安装和设置</strong>：大多数用户从未完成过设置。他们找不到客户端说明，或者无法在浏览器中打开您的 MCP 网址，因此立即流失。</li>
<li><strong>身份验证</strong>：识别用户并为他们提供正确的工具和响应仍然很难实现。</li>
<li><strong>日志、分析和可见性</strong>：无法了解你的 MCP 如何使用、哪些提示触发哪些工具或为什么会发生错误。</li>
</ol>
<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>平台管理和部署<strong>位于你的 MCP 服务器前端</strong>的<a href="https://github.com/hyprmcp/mcp-gateway"><code>mcp-gateway</code></a></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>实例，并处理复杂的事务。它还收集并汇总网关捕获的所有分析和指标数据。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
<div>
<p><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>Jetski 仍在积极开发中，尚处于起步阶段。API 和命令行界面可能会以向后不兼容的方式发生变化。</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></p>
</div>
<h2><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span><span>特点</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></h2>
<ul>
<li><strong>全面的提示分析</strong>&nbsp;查看哪些提示触发了哪些工具、来自哪些客户端以及发生了什么。全面了解你的 MCP 服务器使用模式，并实时了解用户如何与你的工具交互。</li>
<li><strong>自动生成的设置说明，</strong>帮助用户轻松连接到客户端。为每个支持的 MCP 客户端自动生成清晰的分步说明，消除用户在入门过程中流失的首要原因。</li>
<li>
<p><strong>零代码身份验证，</strong>无需编写任何代码即可安全地识别和管理用户。代理可处理所有身份验证逻辑，让你能够根据用户身份提供个性化的工具和响应。</p>
</li>
<li>
<p><strong>实时调试日志&nbsp;</strong>即时调试问题并实时了解服务器行为。查看每个请求、响应和错误的详细日志，轻松快速地识别和修复问题。</p>
</li>
</ul>]]></content:encoded>
    
    <pubDate>Thu, 16 Oct 2025 18:12:37 +0800</pubDate>
  </item><item>
    <title><![CDATA[市场监管总局公布十起互联网违法广告典型案例，两起涉及 AI]]></title>
    <link>https://www.oschina.net/news/377800</link>
    <itunes:title><![CDATA[市场监管总局公布十起互联网违法广告典型案例，两起涉及 AI]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><span>市场监管总局<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.samr.gov.cn%2Fxw%2Fzj%2Fart%2F2025%2Fart_e6588f2b63064945869a86187b361c55.html" target="_blank">公布</a>十起互联网违法广告典型案例。</span></p>
<p><span>今年以来，市场监管部门围绕医疗、药品、医疗器械、保健食品、金融等重点领域，紧盯直播电商广告、AI生成广告等新兴业态，持续加大互联网广告监管执法力度，切实维护互联网广告市场秩序，有力防范互联网违法广告加剧市场非理性竞争。前三季度，全国市场监管部门共查处互联网违法广告案件22185件，罚没款1.11亿元。现选取一批已办结的互联网违法广告典型案例予以公布。</span></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-3bbd502434.png"></p>
<p><span>其中涉及 AI 技术的案例包括：</span></p>
<p><span><strong>福建省厦门市集美区市场监管局查处苗古金贴（厦门）大药房有限公司违法广告案</strong></span></p>
<p><span>经查，苗古金贴（厦门）大药房有限公司在互联网发布未经审查的“苗古金贴远红外治疗贴”等医疗器械广告，并在广告中利用AI技术生成“传承千年苗方苗古金贴传承人”“第56代苗古金贴传承人”等虚假人物形象，同时在广告中使用“中老年专用”等虚假信息，欺骗、误导消费者。</span></p>
<p><span>今年7月，福建省厦门市集美区市场监管局依据《中华人民共和国广告法》有关规定，对苗古金贴（厦门）大药房有限公司等相关主体作出罚款120万元的行政处罚。</span></p>
<p><span><strong>北京市海淀区市场监管局查处北京心情好科技有限公司违法广告案</strong></span></p>
<p><span>经查，北京心情好科技有限公司以直播和短视频形式发布“深海多烯鱼油凝胶糖果”普通食品广告，在广告中利用AI技术仿冒某著名主持人形象为产品作推销，并宣称产品具有“解决头晕头痛、手麻脚麻”等治疗功效。</span></p>
<p><span>今年6月，北京市海淀区市场监管局依据《中华人民共和国广告法》有关规定，对当事人作出罚款20万元的行政处罚。</span></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><span>市场监管总局<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.samr.gov.cn%2Fxw%2Fzj%2Fart%2F2025%2Fart_e6588f2b63064945869a86187b361c55.html" target="_blank">公布</a>十起互联网违法广告典型案例。</span></p>
<p><span>今年以来，市场监管部门围绕医疗、药品、医疗器械、保健食品、金融等重点领域，紧盯直播电商广告、AI生成广告等新兴业态，持续加大互联网广告监管执法力度，切实维护互联网广告市场秩序，有力防范互联网违法广告加剧市场非理性竞争。前三季度，全国市场监管部门共查处互联网违法广告案件22185件，罚没款1.11亿元。现选取一批已办结的互联网违法广告典型案例予以公布。</span></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-3bbd502434.png"></p>
<p><span>其中涉及 AI 技术的案例包括：</span></p>
<p><span><strong>福建省厦门市集美区市场监管局查处苗古金贴（厦门）大药房有限公司违法广告案</strong></span></p>
<p><span>经查，苗古金贴（厦门）大药房有限公司在互联网发布未经审查的“苗古金贴远红外治疗贴”等医疗器械广告，并在广告中利用AI技术生成“传承千年苗方苗古金贴传承人”“第56代苗古金贴传承人”等虚假人物形象，同时在广告中使用“中老年专用”等虚假信息，欺骗、误导消费者。</span></p>
<p><span>今年7月，福建省厦门市集美区市场监管局依据《中华人民共和国广告法》有关规定，对苗古金贴（厦门）大药房有限公司等相关主体作出罚款120万元的行政处罚。</span></p>
<p><span><strong>北京市海淀区市场监管局查处北京心情好科技有限公司违法广告案</strong></span></p>
<p><span>经查，北京心情好科技有限公司以直播和短视频形式发布“深海多烯鱼油凝胶糖果”普通食品广告，在广告中利用AI技术仿冒某著名主持人形象为产品作推销，并宣称产品具有“解决头晕头痛、手麻脚麻”等治疗功效。</span></p>
<p><span>今年6月，北京市海淀区市场监管局依据《中华人民共和国广告法》有关规定，对当事人作出罚款20万元的行政处罚。</span></p>]]>
    </description>
    <content:encoded><![CDATA[<p><span>市场监管总局<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.samr.gov.cn%2Fxw%2Fzj%2Fart%2F2025%2Fart_e6588f2b63064945869a86187b361c55.html" target="_blank">公布</a>十起互联网违法广告典型案例。</span></p>
<p><span>今年以来，市场监管部门围绕医疗、药品、医疗器械、保健食品、金融等重点领域，紧盯直播电商广告、AI生成广告等新兴业态，持续加大互联网广告监管执法力度，切实维护互联网广告市场秩序，有力防范互联网违法广告加剧市场非理性竞争。前三季度，全国市场监管部门共查处互联网违法广告案件22185件，罚没款1.11亿元。现选取一批已办结的互联网违法广告典型案例予以公布。</span></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-3bbd502434.png"></p>
<p><span>其中涉及 AI 技术的案例包括：</span></p>
<p><span><strong>福建省厦门市集美区市场监管局查处苗古金贴（厦门）大药房有限公司违法广告案</strong></span></p>
<p><span>经查，苗古金贴（厦门）大药房有限公司在互联网发布未经审查的“苗古金贴远红外治疗贴”等医疗器械广告，并在广告中利用AI技术生成“传承千年苗方苗古金贴传承人”“第56代苗古金贴传承人”等虚假人物形象，同时在广告中使用“中老年专用”等虚假信息，欺骗、误导消费者。</span></p>
<p><span>今年7月，福建省厦门市集美区市场监管局依据《中华人民共和国广告法》有关规定，对苗古金贴（厦门）大药房有限公司等相关主体作出罚款120万元的行政处罚。</span></p>
<p><span><strong>北京市海淀区市场监管局查处北京心情好科技有限公司违法广告案</strong></span></p>
<p><span>经查，北京心情好科技有限公司以直播和短视频形式发布“深海多烯鱼油凝胶糖果”普通食品广告，在广告中利用AI技术仿冒某著名主持人形象为产品作推销，并宣称产品具有“解决头晕头痛、手麻脚麻”等治疗功效。</span></p>
<p><span>今年6月，北京市海淀区市场监管局依据《中华人民共和国广告法》有关规定，对当事人作出罚款20万元的行政处罚。</span></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-3bbd502434.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-3bbd502434.png" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 17:53:34 +0800</pubDate>
  </item><item>
    <title><![CDATA[2027 年 AI 软硬件整体市场规模将达到 7800 亿至 9900 亿美元]]></title>
    <link>https://www.oschina.net/news/377797</link>
    <itunes:title><![CDATA[2027 年 AI 软硬件整体市场规模将达到 7800 亿至 9900 亿美元]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><span>贝恩公司与亚马逊云科技联合发布《中国软件企业出海热点观察》，这是双方首次针对中国软件企业出海进行的分析和建议。</span></p>
<p><span>本观察分析了中国软件出海的技术及市场势能，建议了软件企业重点关注的4个成功要素，并借鉴软件出海先行者的经验，分享了如何制定完善的市场和服务策略、强化综合能力建设的行动建议。</span></p>
<p><span>贝恩公司全球合伙人、大中华区高科技业务主席成鑫表示："当前，中国科技领域展现出明显的出海趋势，特别是在SaaS、人工智能应用、电商、社交媒体和金融科技等领域，中国软件企业正稳步拓展海外市场。我们注意到，这些企业不仅具备强大的技术创新能力，更为重要的是，它们开始深入理解全球市场的差异化需求，并积极借鉴成熟国际科技企业的资源和经验，这为其成功出海奠定了坚实的基础。"</span></p>
<p><span>技术角度，到2027年AI软硬件整体市场规模将达到7,800亿至9,900亿美元，平均增速为40%～55%，其中应用程序和交易平台平均增速为60%～85%，这些为中国企业提供了巨大的全球化机遇。市场角度，作为最大的存量市场，北美依旧是SaaS、电商、社交媒体等领域要重点关注的地区，同时，东南亚、中东、非洲、拉丁美洲等海外新兴市场显示出了强劲的增长潜力。</span></p>
<p><span>针对中国软件企业出海过程中面临的挑战，观察指出四大关键成功要素：完善战略战术、深度理解当地市场、依托全球化先行科技企业的成熟体制、把握AI良机。</span></p>
<p><span>成鑫进一步分析："中国企业在出海过程中面临的三大核心挑战同样适用于软件企业。在把握机遇的同时，企业更需要认清竞争和风险，明确出海的初衷，并善于利用在国内市场积累的优势。贝恩公司的4D模型所总结的领先企业全球化经验(Design for Local Market：为当地用户设计；Decide Locally：本地团队决策，增强信任；Deliver at Local Speed：适应当地速度，与合作伙伴协调；Digitalize Operations：根据目标市场重构数字化方案)，包括外资在华的成功案例，同样可以适用中国软件企业的国际化进程。"</span></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><span>贝恩公司与亚马逊云科技联合发布《中国软件企业出海热点观察》，这是双方首次针对中国软件企业出海进行的分析和建议。</span></p>
<p><span>本观察分析了中国软件出海的技术及市场势能，建议了软件企业重点关注的4个成功要素，并借鉴软件出海先行者的经验，分享了如何制定完善的市场和服务策略、强化综合能力建设的行动建议。</span></p>
<p><span>贝恩公司全球合伙人、大中华区高科技业务主席成鑫表示："当前，中国科技领域展现出明显的出海趋势，特别是在SaaS、人工智能应用、电商、社交媒体和金融科技等领域，中国软件企业正稳步拓展海外市场。我们注意到，这些企业不仅具备强大的技术创新能力，更为重要的是，它们开始深入理解全球市场的差异化需求，并积极借鉴成熟国际科技企业的资源和经验，这为其成功出海奠定了坚实的基础。"</span></p>
<p><span>技术角度，到2027年AI软硬件整体市场规模将达到7,800亿至9,900亿美元，平均增速为40%～55%，其中应用程序和交易平台平均增速为60%～85%，这些为中国企业提供了巨大的全球化机遇。市场角度，作为最大的存量市场，北美依旧是SaaS、电商、社交媒体等领域要重点关注的地区，同时，东南亚、中东、非洲、拉丁美洲等海外新兴市场显示出了强劲的增长潜力。</span></p>
<p><span>针对中国软件企业出海过程中面临的挑战，观察指出四大关键成功要素：完善战略战术、深度理解当地市场、依托全球化先行科技企业的成熟体制、把握AI良机。</span></p>
<p><span>成鑫进一步分析："中国企业在出海过程中面临的三大核心挑战同样适用于软件企业。在把握机遇的同时，企业更需要认清竞争和风险，明确出海的初衷，并善于利用在国内市场积累的优势。贝恩公司的4D模型所总结的领先企业全球化经验(Design for Local Market：为当地用户设计；Decide Locally：本地团队决策，增强信任；Deliver at Local Speed：适应当地速度，与合作伙伴协调；Digitalize Operations：根据目标市场重构数字化方案)，包括外资在华的成功案例，同样可以适用中国软件企业的国际化进程。"</span></p>]]>
    </description>
    <content:encoded><![CDATA[<p><span>贝恩公司与亚马逊云科技联合发布《中国软件企业出海热点观察》，这是双方首次针对中国软件企业出海进行的分析和建议。</span></p>
<p><span>本观察分析了中国软件出海的技术及市场势能，建议了软件企业重点关注的4个成功要素，并借鉴软件出海先行者的经验，分享了如何制定完善的市场和服务策略、强化综合能力建设的行动建议。</span></p>
<p><span>贝恩公司全球合伙人、大中华区高科技业务主席成鑫表示："当前，中国科技领域展现出明显的出海趋势，特别是在SaaS、人工智能应用、电商、社交媒体和金融科技等领域，中国软件企业正稳步拓展海外市场。我们注意到，这些企业不仅具备强大的技术创新能力，更为重要的是，它们开始深入理解全球市场的差异化需求，并积极借鉴成熟国际科技企业的资源和经验，这为其成功出海奠定了坚实的基础。"</span></p>
<p><span>技术角度，到2027年AI软硬件整体市场规模将达到7,800亿至9,900亿美元，平均增速为40%～55%，其中应用程序和交易平台平均增速为60%～85%，这些为中国企业提供了巨大的全球化机遇。市场角度，作为最大的存量市场，北美依旧是SaaS、电商、社交媒体等领域要重点关注的地区，同时，东南亚、中东、非洲、拉丁美洲等海外新兴市场显示出了强劲的增长潜力。</span></p>
<p><span>针对中国软件企业出海过程中面临的挑战，观察指出四大关键成功要素：完善战略战术、深度理解当地市场、依托全球化先行科技企业的成熟体制、把握AI良机。</span></p>
<p><span>成鑫进一步分析："中国企业在出海过程中面临的三大核心挑战同样适用于软件企业。在把握机遇的同时，企业更需要认清竞争和风险，明确出海的初衷，并善于利用在国内市场积累的优势。贝恩公司的4D模型所总结的领先企业全球化经验(Design for Local Market：为当地用户设计；Decide Locally：本地团队决策，增强信任；Deliver at Local Speed：适应当地速度，与合作伙伴协调；Digitalize Operations：根据目标市场重构数字化方案)，包括外资在华的成功案例，同样可以适用中国软件企业的国际化进程。"</span></p>]]></content:encoded>
    
    <pubDate>Thu, 16 Oct 2025 17:34:52 +0800</pubDate>
  </item><item>
    <title><![CDATA[2025 年 9 月国产数据库大事记]]></title>
    <link>https://my.oschina.net/u/4559794/blog/18695790</link>
    <itunes:title><![CDATA[2025 年 9 月国产数据库大事记]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p>本文为<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2F%3F1016" target="_blank">墨天轮社区</a>整理的2025年9月国产数据库大事件和重要产品发布消息。</p>
<blockquote>
<p>2025年9月诞生了6个500万以上数据库大单。比如云南农信采购GoldenDB、GaussDB和达梦数据库，安徽农信采购GoldenDB和达梦数据库，电科金仓中标甘肃移动数据库一体机项目，广东移动采购GoldenDB、OceanBase和华为云数据库。</p>
</blockquote>
<blockquote>
<p>数据库顶会&nbsp;VLDB&nbsp;2025举行，华为、腾讯、OceanBase、创邻科技等厂商论文入选。多家厂商举办了产品发布会：矩阵起源产品发布会（发布MatrixOne与MatrixOne&nbsp;Intelligence）、云和恩墨2025秋季产品发布会（发布zData&nbsp;X、zCloud、zAIoT和MogDB等产品的最新版本）、DolphinDB&nbsp;2025年度峰会发布（发布Orca、Swordfish和Shark三款新品提升实时计算能力）、数智引航向量数据库VexDB新品发布会。此外腾讯云TDSQL家族新增TDSQL-B，OpenTenBase&nbsp;+TXSQL新版本发布，Apache&nbsp;Cloudberry&nbsp;(Incubating)&nbsp;2.0.0发布，酷克数据推出企业级数据仓库HashData&nbsp;Lightning&nbsp;2.0。</p>
</blockquote>
<h3>目录</h3>
<ul>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49_TOP10font_8" target="_blank">9月国产数据库大事记 TOP10</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49font_15" target="_blank">9月国产数据库大单</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49font_30" target="_blank">9月大事记时间线</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49font_134" target="_blank">9月产品/版本发布</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49font_253" target="_blank">9月代表厂商大事记</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size4font_263" target="_blank">相关资料</a></li>
</ul>
<h2>9月国产数据库大事记 TOP10</h2>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2ce61ce7c1.png"></p>
<h2>9月国产数据库大单</h2>
<p>2025年9月诞生了6个500万以上数据库大单。<strong>云南省农村信用社科技结算中心</strong>采购数据库产品用于云南农信同业合作系统建设，其中<strong>GoldenDB</strong>数据库采购由北京先进数通中标，中标价<strong>2687.79万元</strong>，<strong>高斯数据库</strong>采购由东华软件中标，中标价<strong>502.0032万元</strong>，<strong>达梦数据库</strong>采购由北京宇信科技中标，中标价47.2万元。<strong>安徽省农村信用社联合社</strong>&nbsp;<strong>858.496万元</strong>采购<strong>GoldenDB</strong>数据库许可和维保服务，<strong>514.35万元</strong>采购<strong>达梦数据库</strong>许可和维保服务。<strong>电科金仓</strong>&nbsp;<strong>828.0753万元</strong>中标甘肃移动数据库一体机项目。</p>
<p>此外，<strong>广东移动</strong>2025年省建中心云自主可控数据库（分布式OLTP）框采项目预估采购391套OLTP数据库，预算2463.3万元（不含税），<strong>GoldenDB</strong>&nbsp;中标 40%份额，不含税单价报价43000元/套（预估不含税670.8万元），<strong>OceanBase</strong>&nbsp;中标35%份额，不含税单价报价50000元/套（预估不含税685万元），<strong>华为云数据库</strong>中标25%份额，不含税单价报价49000元/套（预估不含税480.2万元），三种数据库预计不含税共1836万元（税点13%）。</p>
<p><strong>2025年9月数据库大单</strong><br> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-21430e8937.png"></p>
<blockquote>
<p>移动运营商和农村信用社频繁的数据库大单，显示出通信和政企行业对国产数据库的强劲需求。 点击查看<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1976139909123551232%3F1016" target="_blank">9月数据库中标情况盘点</a>。 &nbsp;</p>
</blockquote>
<h2>9月大事记时间线</h2>
<p><strong>数据库顶会 VLDB 2025 伦敦召开</strong></p>
<p>9月1日至5日，第 51 届国际大型数据库会议（<strong>VLDB 2025</strong>）在英国伦敦成功举办。本届会议汇聚了来自北美、欧洲、亚洲等地的研究学者与工程师，议题涵盖数据库系统、大规模数据管理、图数据库、机器学习与数据科学等多个前沿方向，集中展现了数据库技术在学术研究与产业实践中的最新进展与未来趋势。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-84176d0379.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-84ac36aa52.png"></p>
<ul>
<li> <p><strong>华为</strong>18篇论文入选VLDB 2025。其中<strong>GaussDB</strong>两篇亮点论文《GaussDB-Vector: A Large-Scale Persistent Real-Time Vector Database for LLM Applications》、《GRewriter: Practical Query Rewriting with Automatic Rule Set Expansion in GaussDB》分别解析了向量数据库和查询重写技术的创新。GaussDB的向量数据库针对大语言模型应用进行了优化，而GRewriter查询重写器则提高了数据库查询的效率。</p> </li>
<li> <p><strong>腾讯</strong>共有9篇论文入选，这些论文的研究方向包括分布式事务调度、混合并发控制、OLTP负载压缩、时序图计算、NL2SQL等前沿领域。研究成果已在微信、腾讯广告等亿级业务中得到应用。这些成就得益于腾讯与多所高校的深度产学研合作，部分核心成果已集成至腾讯云数据库TDSQL及大数据产品矩阵，并广泛应用于金融、政务、电商等多个行业。</p> </li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2bc332711d.png"></p>
<ul>
<li> <p><strong>OceanBase</strong>&nbsp;与浙江大学、北京邮电大学、南洋理工大学等高校的联合研究成果有 4 篇论文入选VLDB 2025，涉及分布式可靠性、安全与隐私、查询优化和智能诊断等数据库核心技术。具体包括：《Towards Practical Oblivious Map》、《RankPQO: Learning-to-Rank for Parametric Query Optimization》、《CoLA: Model Collaboration for Log-based Anomaly Detection》、《DBPecker : A Graph-Based Compound Anomaly Diagnosis System for Distributed RDBMSs》。</p> </li>
<li> <p>由<strong>创邻科技</strong>深度参与并联合主导的&nbsp;LDBC FinBench 金融图数据库测试基准，荣获大会实验、分析与基准测试“最佳论文奖”；同时，公司全自主研发的AI驱动框架——&nbsp;GalaxyWeaver：大语言模型驱动的智能图建模与优化框架，成功入选 VLDB 2025并作大会报告！</p> </li>
</ul>
<blockquote>
<p>GalaxyWeaver已全面集成于创邻科技的旗舰产品国产高性能图数据库Galaxybase，将国产图数据库产品的AI集成推向了产业应用落地的新阶段。</p>
</blockquote>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4c587d7435.png"></p>
<ul>
<li> <p><strong>蚂蚁集团</strong>发起共建并主导设计的图数据库基准研究论文《The LDBC Financial Benchmark: Transaction Workload》荣获大会实验、分析与基准测试“最佳论文亚军奖”。</p> </li>
<li> <p><strong>星环科技</strong>与华东师范大学合作的研究成果《Rebirth-Retire: A Concurrency Control Protocol Adaptable to Different Levels of Contention》被国际顶级数据库会议VLDB 2025收录。该研究提出了一种新的并发控制协议Rebirth-Retire，有效解决了数据库在高并发环境下的性能瓶颈问题。</p> </li>
<li> <p><strong>数翊科技</strong>与武汉理工大学计算机与人工智能学院在向量化计算、行列混合存储等领域展开合作。双方在数据库领域的联合论文《Select Edges Wisely: Monotonic Path Aware Graph Layout Optimization for Disk-Based ANN Search》被VLDB 2025收录。数翊科技携核心数据库产品HexaDB的最新能力正式亮相VLDB，是唯一一家主打数字化与AI基础设施型的轻量化数据库引擎的科技公司。HexaDB仅用一套计算引擎和一套数据即可同时满足交易、分析、以及大模型推理的需求。</p> </li>
</ul>
<p><strong>浪潮KaiwuDB荣获2025年度“山东电子学会科学技术奖二等奖”</strong></p>
<p>9月1日，山东电子学会公布2025年度“山东电子学会科学技术奖”评审结果。浪潮数据库（KaiwuDB）、浪潮科学院、浪潮软件集团联合项目“面向工业物联网的高性能分布式多模数据库关键技术与应用”荣获科技进步二等奖。该项目成果以分布式多模数据库系统KaiwuDB 为依托，已在山东、上海等多省市落地，成功应用于新能源、智能制造等领域，为企业数字化转型提供核心数据支撑。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e28d1248d2.png"></p>
<blockquote>
<p>该项目面向工业物联网海量异构数据管理难题开展技术攻关，创新研发基于 FPGA 的异构加速计算架构与多模态数据一体化引擎，有效解决传统数据库多模态数据处理效率低、边缘算力利用率不足、跨域数据协同困难等问题，支撑设备数据毫秒级响应及多类型数据一站式管理。</p>
</blockquote>
<p><strong>浪潮KaiwuDB荣获2025年度“山东省信息产业协会科技创新奖”</strong></p>
<p>9月1日，山东省信息产业协会公布 2025 年度“山东省信息产业协会科技创新奖”获奖名单，浪潮KaiwuDB 研发团队荣获“创新团队奖”。2025年，KaiwuDB 研发团队在多模、时序数据处理、AI 预测分析、云边端数据协同及异构计算加速等 5 大核心技术上实现突破，新申请相关专利 90 余篇。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4bdfe6640e.png"></p>
<blockquote>
<p>该奖项旨在表彰在信息技术领域做出突出贡献的企业和团队，是山东省信息产业的重要奖项之一。</p>
</blockquote>
<p><strong>《OceanBase AI Data Infra解决方案白皮书》发布</strong></p>
<p>9月2日，《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdoc%2F146946%3F1016" target="_blank">OceanBase AI Data Infra解决方案白皮书</a>》正式发布，旨在帮助企业解决数据孤岛与模型失焦问题，打破数据与模型的割裂，助力企业智能化转型。白皮书提出了DB-LLM-OPS新范式，通过多模态数据融合治理、动态向量化与混合检索、实时/批处理一体化等技术优势，打通“数据-智能-运维”闭环，实现数据价值与模型能力的协同释放，并提供了高级搜索、智能推荐、RAG应用等四大典型AI场景的解决方案。</p>
<p><strong>达梦数据护航九三阅兵，彰显硬核实力</strong></p>
<p>9月3日上午，纪念中国人民抗日战争暨世界反法西斯战争胜利80周年大会在北京天安门广场隆重举行。达梦数据为大会全程护航，全方位、7*24小时全力守护大会信息系统的安全、高效、稳定运行，圆满完成本次服务保障任务，以优异的成绩再次交出了一份让党和人民满意的答卷。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-63de488905.png"></p>
<p><strong>以Data+AI赋能产业，Kyligence荣膺2025中国数智化转型升级创新服务企业</strong></p>
<p>9月8日，由数智猿×数据猿联合主办的“2025第五届数智化转型升级发展论坛——暨 AI 大模型 &amp; AI Agent 趋势论坛”在京举行。Kyligence（跬智信息）凭借领先的 Data+AI 技术与产品，以及在金融、零售、制造等领域的标杆性 Data Agent 应用案例，从众多候选企业中脱颖而出，荣获“2025 中国数智化转型升级创新服务企业奖”。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-23ad38c3e4.png"></p>
<blockquote>
<p>Kyligence 率先将数据分析与大语言模型深度融合，推出 AI 数据智能体（Data Agent）。该产品在问数、对话分析、归因分析和报告生成等方面表现优异，以领先的准确性、可靠性和安全性赢得了众多企业级客户的信赖。今年 4 月，Kyligence 又发布业内首款具备自主推理与洞察能力的产品——DeepInsight，将专利多维分析技术与 DeepSeek 推理框架结合，帮助企业高效检索、精准分析，提供专业决策支持。</p>
</blockquote>
<p><strong>电科金仓与海光信息签署战略合作</strong></p>
<p>9月11日，电科金仓与海光信息正式签署战略合作协议，双方将整合核心优势聚焦“产品联合研发适配优化、市场联合拓展和联合品牌建设”三大方向合作。双方还将以此次签约为契机，推动集团层面“计算+云+数据库”核心领域生态协同，涵盖政务云平台共建、定制化终端解决方案研发及市场资源共享，聚力打造技术领先、服务高效的行业智能解决方案。</p>
<p><strong>OceanBase联合中国银行保险报发布《面向AI时代的中小银行数据库研究与展望》报告</strong></p>
<p>9月11日，在金融科技年度盛会外滩大会举办期间，OceanBase 领衔发起“金融 CIO 数智跃迁闭门会”，并联合《中国银行保险报》发布业内首本聚焦 AI 时代中小银行数据库的研究报告——《面向AI时代的中小银行数据库研究与展望》。报告深入剖析了银行业强化数据库建设的时代背景，梳理了银行业务系统数据库的演进趋势与转型升级现状，以及 AI 驱动中小银行业务转型的机遇与挑战。针对 AI 时代中小银行数据库升级面临的难点与痛点，报告还提出了解决方案以及转型升级参考指南、方法论和未来发展趋势与展望。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-7c58f6bac9.png"></p>
<blockquote>
<p>根据课题组调研，当前中国银行业数据库国产升级进程在金融业处于领先地位。超 50% 的银行核心系统已采用分布式数据库，预计未来三年渗透率将突破 90%，其中 OceanBase 以 39.1% 的市场份额位居首位。</p>
</blockquote>
<p><strong>《HTAP数据库技术要求》等五项数据库技术标准正式发布</strong></p>
<p>9月17日，中国通信标准化协会公告显示，由中国信息通信研究院牵头的 T/CCSA 722-2025《基于无服务器架构的事务型数据库能力分级要求》、T/CCSA 723-2025《基于无服务器架构的分析型数据库能力分级要求》、T/CCSA 725-2025《数据库一体机技术要求》、T/CCSA 726-2025《数据库迁移工具能力要求》、T/CCSA 727-2025《事务分析混合型（HTAP）数据库技术要求》等多项数据库技术团体标准已于2025年9月17日正式发布，并将于2025年12月18日正式实施。</p>
<p><strong>浪潮KaiwuDB荣获2025年度“山东计算机学会科技进步二等奖”</strong></p>
<p>9月18日，山东计算机学会通报 2025 年度“山东计算机学会科学技术奖”获奖项目名单，浪潮数据库（KaiwuDB）、浪潮软件集团联合提报项目“开务数据库(KaiwuDB) 高性能 HTAP 引擎关键技术研究与应用”荣获科技进步奖二等奖。该项目在KaiwuDB SQL 语法兼容性、算子支持、优化器自治运行、索引智能推荐、混合多模存储及 HTAP（混合事务/分析处理）架构等技术方向上创新突破，从内核优化维度大幅提升 KaiwuDB 查询分析性能。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0a6f802497.png"></p>
<p><strong>云和恩墨与达梦数据签订战略合作协议，深化数据库生态协同发展</strong></p>
<p>9月19日，云和恩墨与达梦数据正式达成全面战略合作。此次战略合作协议的签订，标志着双方将在接下来的时间里，围绕产品推广、解决方案融合、人才培养、市场拓展和项目支持五大维度开展深度协作，共同推动国产数据库技术生态的完善与落地应用，助力千行百业实现数字化转型升级。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5026e1fa8f.png"></p>
<p><strong>OceanBase 亮相中国通信展！五大实践获 ICT 中国一等奖</strong></p>
<p>9月24日至26日，2025 年中国国际信息通信展览会在北京举行。现场，ICT 中国（2025）案例一等案例公布，OceanBase 五大案例入选并获表彰。案例包含：联通软研院基于 OceanBase 构建 AI 增强型智能数据平台；广东移动核心系统打造 XC 新一代数据库底座；江苏移动核心系统 XC 数据库替代项目；跨中心双活+智能调度：中移金科基于 OceanBase 打造金融级高可用数据库底座；运营商经营分析系统基于 OceanBase AP 能力的创新实践。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-58b69f4144.png"></p>
<p><strong>《OceanBase 实时分析能力白皮书》发布</strong></p>
<p>9月25日消息，《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdoc%2F147171%3F1016" target="_blank">OceanBase 实时分析能力白皮书</a>》发布，旨在帮助企业应对 GenAI 时代下数据分析面临的架构复杂、数据延迟、成本高昂、多模融合等挑战。OceanBase 通过自研列存引擎、向量化执行引擎、多模一体化等技术，实现了一站式数据管理和实时分析，已在金融、零售、运营商等行业核心场景中验证，显著提升数据查询时效和系统性能，为企业提供高效、极简、智能的数据底座。</p>
<h2>9月产品/版本发布</h2>
<p><strong>Apache Cloudberry (Incubating) 2.0.0 发布！</strong></p>
<p>9月4日消息，Apache Cloudberry (Incubating) 2.0.0正式发布，这是该项目自2024年10月加入Apache软件基金会孵化器以来的首个正式版本。Cloudberry是一款开源大规模并行处理（MPP）数据库，支持本地和云上部署，为数据仓库和高级分析提供可扩展的基础。2.0.0版本基于PostgreSQL 14.x构建，主要亮点包括：分布式查询规划和执行的显著改进、增强的资源管理、改进的并行处理、动态表功能以及PAX存储格式的引入。此外，该版本还更新了许可证标头和依赖项属性，以满足ASF合规性要求。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-fa97c58a23.png"></p>
<p><strong>GreptimeDB v0.17 发布！Flow 现已支持 TQL（PromQL）</strong></p>
<p>9月5日，GreptimeDB v0.17版本正式发布。新版本增强了60项功能，如PromQL优化和TQL CTE支持，修复了32项错误，进行了2项性能优化，提升了稀疏编码器性能235%，改进了60项文档，并进行了1项测试优化和27项杂项任务。此外，Flow支持TQL（PromQL），Reconciliation Procedures功能可处理元数据备份恢复后与集群新数据不兼容的问题。</p>
<p><strong>IvorySQL 4.6 发布，全面支持 PostgreSQL 17.6</strong></p>
<p>9月5日，IvorySQL 4.6版本正式发布，全面支持PostgreSQL 17.6并带来多项新功能和已知问题的修复。增强功能包括加强规划器估计函数中的安全检查、防止pg_dump脚本被用于攻击等。新增特性有升级至PG 17.6内核、兼容MongoDB的解决方案、全平台LoongArch打包、IvorySQL在线试用、容器化部署支持（Docker Swarm和Kubernetes）以及IvorySQL Cloud v4.0发布。</p>
<p><strong>矩阵起源产品发布会发布MatrixOne与MatrixOne Intelligence</strong></p>
<p>9月12日，矩阵起源在上海举办“以数生智、以智驭数”产品发布会，正式推出两款战略级核心产品：超融合异构云原生数据库 MatrixOne (MO) 与 AI原生多模态数据智能平台 MatrixOne Intelligence (MOI)。<strong>超融合异构云原生数据库MatrixOne</strong>&nbsp;的核心是超融合架构，将 HTAP（混合事务/分析处理）、流处理、向量检索、全文搜索原生整合到同一引擎中，从根本上消除了长期困扰企业的数据孤岛问题。而平台的另一大创新是引入&nbsp;“数据的Git”新范式：通过将版本管理、分支、回滚、审计等软件工程理念引入数据管理，显著缩短了 AI 项目的开发周期，并加速跨团队协作，极大提升企业在复杂数据场景下的敏捷性。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-98d57c6e32.png"></p>
<ul>
<li><strong>AI原生多模态数据智能平台MatrixOne IntelligenceMOI</strong>&nbsp;产品的定位是下一代 Data Infrastructure，技术对标 Databricks + Snowflake，聚焦企业AI落地难题。MOI具备五大核心创新能力：融合架构实现数据统一管理，消除数据栈割裂；Agentic数据治理自动优化数据处理，降低人力依赖；智能数据解析高效处理非结构化数据，减少80%人工处理量；高性能运行底座支撑多并发业务；全链路安全保障确保数据安全与合规。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oss-emcsprod-public.modb.pro-155c8e8b9b.png"></p>
<ul>
<li>发布会还宣布了与多家企业及机构的战略合作：与赛意信息共创“AI+数字化工厂”，与辰奕智能合作加速AI在制造业落地。与上海云基地合作深化产业链联动，打造“方案孵化器”。此外，还与安畅网络、启数智能、迪际特科技等企业合作，推动AI在金融、制造、零售、公共安全、智慧城市等领域的应用落地。</li>
</ul>
<p><strong>云和恩墨2025秋季产品发布会线上举行</strong></p>
<p>9月12日，云和恩墨在2025年秋季产品发布会上推出了zData X、zCloud、zAIoT和MogDB等产品的最新版本，这些产品体现了公司在数据库一体机、智能化运维、数据智能和异构数据库迁移服务方面的最新进展。zData X 3.5版本展示了更高的性能、更优的成本和更易的运维；zCloud 6.7.2版本增强了对主流开源和国产数据库的兼容性和智能化运维能力；zAIoT 3.0版本在军工和工业制造领域的数据升值方面取得了显著成效；MogDB则通过“订阅使用”模式提供了商业发行版的企业级关系型数据库，用户只需支付服务费即可获得官方支持。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9f4a5b2c67.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-98c0a7d749.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4584d54e0a.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-b8033b27ad.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-68f9682f90.png"></p>
<p><strong>「Infra + AI 至简致远」DolphinDB 2025 年度峰会圆满举办</strong></p>
<p>9月12日，DolphinDB 2025年度峰会在杭州成功举办，吸引了近300位来自金融行业的嘉宾。DolphinDB 研发副总监程训焘博士通过《2025 DolphinDB 新产品发布》演讲，深入探讨了 DolphinDB 在实时计算领域的重大进展。程博士着重介绍了企业级实时计算平台 Orca&nbsp;的推出及其主要功能和优势。此外，程博士还介绍了 Swordfish 低延时嵌入式引擎和 Shark CPU/GPU 异构计算平台，展望了 DolphinDB 在 AI 时代的发展。此外，DolphinDB还发布了AI Agent，通过自我验证和迭代纠错机制，使AI更自然地融入金融研究与投资实践。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-46be047b3c.png"></p>
<ul>
<li><strong>Orca</strong>是DolphinDB推出的企业级实时计算平台，通过简化流计算任务的开发流程，支持多模态数据的统一处理，并提供针对金融等行业的专用数据模型，实现了企业级高可用性和跨地域协同计算。这一平台使得开发者能够以声明式方式描述流计算需求，自动生成计算图并智能规划资源，从而显著降低开发和运维的复杂性。Orca为企业在量化投研、物联网监控等场景提供了强大的实时计算支持。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-c040ece78b.png"></p>
<ul>
<li><strong>Swordfish</strong>是一款高性能计算函数库，专为<code>C++</code>程序设计，内含DolphinDB自研的计算内核，拥有超过2000个函数和流计算引擎。它通过在本地硬件上直接执行计算，避免了网络访问服务器的延迟，实现了十微秒甚至单微秒级的计算延迟，显著提升了高频计算任务的性能。Swordfish目前已支持C++和Java，未来还将推出Python版本。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e4d8c9fff0.png"></p>
<ul>
<li><strong>Shark</strong>是DolphinDB与海光信息合作开发的CPU/GPU异构计算平台，其核心组件Shark Graph并行计算引擎显著提升了性能，使因子挖掘速度提高了10倍以上，并且能够通过简单的“@GPU”标签实现DolphinDB脚本在GPU上的一键加速，性能提升可达10至20倍，同时减少CPU和内存占用。目前，Shark平台已支持海光DCU处理器，并计划继续优化国产处理器的性能和易用性，以提供更强大的计算能力。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-ee7ea33f10.png"></p>
<p><strong>腾讯云TDSQL自研产品家族扩容，数据库AI服务正式发布</strong></p>
<p>9月17日，在2025腾讯全球数字生态大会上，腾讯云正式公布自研数据库TDSQL全新产品家族，包含TDSQL（超大规模分布式关系型数据库）、TDSQL-C（云原生关系型数据库）、新亮相的TDSQL-B（超高性能分布式集群）三款产品，满足企业在智能化和全球化时代的不同场景需求；同时推出数据库AI服务（（TencentDB AI Service，简称TDAI））和业内首个AI自学习优化器，以AI技术驱动数据库进化。此外，腾讯云数据库启动第三届开放原子大赛——OpenTenBase多模态分析挑战赛和OpenTenBase-TXSQL SQL改写优化挑战赛，共60万奖金以激发开发者创新，举办生态伙伴颁奖仪式表彰优秀合作者，并发布学术生态建设成果。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-a2fff61047.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-fe51a4676d.png"></p>
<ul>
<li><strong>TDSQL-B</strong>：本次大会重磅发布的专为敏态业务打造的超高性能分布式集群，特别适用于金融场景和高增长业务。TDSQL-B 聚焦三大核心能力。首先是金融级高可靠，通过多副本容灾和快速故障恢复，实现数据零丢失、服务零中断。其次是性能突破，具备百万级 QPS 处理能力与海量存储，同时拥有无限的 TP 扩展性与轻量 AP 能力，能够轻松应对电商大促订单峰值、直播弹幕互动等高并发事务场景。TDSQL-B 在语法兼容性方面 100% 兼容 MySQL，支持分钟级弹性扩缩容，既“好用如单机”，又能抗流量洪峰。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-f99e4a2951.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6622f7dae9.png"></p>
<ul>
<li>腾讯云正式推出<strong>数据库AI服务</strong>（TencentDB AI Service，简称<strong>TDAI</strong>）旨在用AI帮助企业治理好数据库、用好数据。TDAI依托自研数据库大模型、全域上下文、工具集这三大智能体基础设施，构建了数据库DevOps与数据洞察两大核心场景的智能体服务，将智能体能力引入数据库治理。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9e332391a5.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-03decc0157.png"></p>
<ul>
<li>腾讯云还推出了行业首个<strong>AI自学习优化器</strong>，突破传统优化器在复杂场景中的局限性。AI自学习优化器通过全局探索最优执行计划、可量化的数据反馈、动态适配代价模型，和反思演进这四大能力，让复杂查询时延降低80%以上。凭借这一创新，客户无需人力投入，即可实现数据库的自动调优。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2a7780ce94.png"></p>
<ul>
<li>开放原子开源基金会秘书长助理李博、腾讯云数据库总经理王义成与多位高校代表共同启动了&nbsp;<strong>OpenTenBase 5.0</strong>&nbsp;与&nbsp;<strong>TXSQL 8.0.30</strong>&nbsp;新版本发布仪式。本次重磅发布的OpenTenBase 5.0 版本在 Oracle 兼容性、分布式性能、HTAP 能力三个方向实现跨越式升级，全新支持 AI 多模态能力，支持灵活集成大模型，向 Data + AI 共生进化迈出坚实的一步。OpenTenBase 强势推出 opentenbase_ai 插件，为 OpenTenBase 数据库提供了集成人工智能大语言模型能力的接口，让你能够直接在 SQL 中使用 AI 能力。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e918a72307.png"></p>
<blockquote>
<p>OpenAtom OpenTenBase 是一款企业级分布式 HTAP 开源数据库，是 TDSQL 的社区发行版，2023 年 12 月贡献给开放原子开源基金会，其已成功应用于金融、医疗、航天等行业的核心业务系统。TXSQL 是腾讯云数据库团队基于 MySQL 深度定制的企业级数据库内核，去年 9 月，腾讯云数据库向 OpenTenBase 社区捐赠了&nbsp;TXSQL&nbsp;内核。TXSQL 对 InnoDB 存储引擎、查询优化、复制性能等方面进行了大量优化，具有高安全、低成本、易维护等特性，具有透明列加密、透明列压缩、Undo 闪回查询等企业级特性。</p>
</blockquote>
<p><strong>时序数据库 TimechoDB V2.0.6 发布 | 新增查询写回、黑白名单等功能</strong></p>
<p>9月23日，TimechoDBV2.0.6 版本正式发布！TimechoDB 是由&nbsp;IoTDB原厂团队开发的企业级时序数据库产品。V2.0.6 版本新增表模型查询写回功能，新增访问控制黑白名单功能，新增位操作函数（内置标量函数）以及可下推的时间函数，同时对数据库监控、性能、稳定性进行了全方位提升。</p>
<p><strong>云栖重磅｜瑶池数据库：从云原生数据底座向“AI就绪”的多模态数据底座演进</strong></p>
<p>9月24日，云栖大会上，<strong>阿里云瑶池数据库</strong>宣布从云原生数据底座向“AI就绪”的多模态数据底座演进。瑶池数据库推出全球首款基于CXL 2.0 Switch技术的<strong>PolarDB</strong>数据库专用服务器，树立了内存池化新标杆。同时，瑶池数据库发布「基于湖仓库一体化」的多模数据智能管理平台，支持多模态数据管理，融合OLTP和OLAP能力，支持AI算子能力（AI in SQL），让AI应用开发更高效。此外，瑶池数据库还推出ApsaraDB Agent智能顾问，提供一站式、7×24小时不间断的云数据库智能顾问服务，帮助企业轻松“驾驭”数据。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0a2994ecb1.png"></p>
<p><strong>酷克数据推出企业级数据仓库HashData Lightning 2.0</strong></p>
<p>9月24日，酷克数据HashData推出了企业级数据仓库HashData Lightning 2.0，该版本基于Apache Cloudberry 2.0内核，增强了复杂查询优化、存储管控等功能，提供了更低延迟、更高稳定性和并发支撑能力。Lightning 2.0引入了新监控工具CBCC、灾备恢复工具CBDR，并集成了一站式数据科学与AI开发工具箱HashML，实现了数据准备到模型部署的闭环能力。</p>
<p><strong>为AI而生！源于清华的向量数据库VexDB产品发布</strong></p>
<p>9月25日，源于清华的数智引航公司发布了名为VexDB的向量数据库。李国良教授介绍：“VexDB的名字由‘Vector+X+Database’的缩写组成，代表着能释放无限可能的多模态向量数据库。”该产品是一款融合关系型数据库能力和多路语义检索能力的向量数据库，可支持百亿向量数据毫秒级结果查询，召回准确度稳定在99%以上，具备“高性能、大容量、高精度、强一致、高可用、高安全、易用性”的七大产品特性，适用于推荐系统、语义搜索、图像识别等核心应用，全方位满足AI时代复杂场景下的数据检索需求。数智引航目前开发了适用于企业级AI应用场景的VexDB商业版，以及适用于开发商、个人开发者和开源项目的VexDB开发版，开发版提供一年的免费试用。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-3e7fdf0e83.png"></p>
<h2>9月代表厂商大事记</h2>
<p>【<strong>KaiwuDB</strong>】<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972224902111440896%3F1016" target="_blank"><strong>《KaiwuDB 2025年9月大事记》</strong></a></p>
<p>&nbsp; &nbsp;&nbsp;<strong>看点速览</strong></p>
<ul>
<li>KaiwuDB 荣获 2025 年度“山东电子学会科学技术奖二等奖”</li>
<li>KWDB社区携手“开放原子校源行”走进河北工业大学</li>
<li>浪潮数据库(KaiwuDB)、华师大联合论文获国际顶会NeurIPS 2025收录</li>
</ul>
<h2>相关资料</h2>
<ul>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2FdbRank%3F1016" target="_blank">墨天轮中国数据库流行度排行榜-2025年10月已更新</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F189802%3F1016" target="_blank">墨天轮中国数据库流行度排行榜规则解读</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Ftopic%2F61684%3F1016" target="_blank">月度国产数据库大事记合辑</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Ftopic%2F4704%3F1016" target="_blank">中国数据库排行榜 - 月度解读</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fbid%3F%3F1016" target="_blank">国产数据库招投标信息汇总</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdoc%2F146946%3F1016" target="_blank">《OceanBase AI Data Infra解决方案白皮书》_2025.pdf</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdoc%2F147171%3F1016" target="_blank">《OceanBase 实时分析能力白皮书》.pdf</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ccsa.org.cn%2Fdetail%2F%3Fid%3D55463%26title" target="_blank">《HTAP数据库技术要求》等五项数据库技术标准-中国通信标准化协会公告</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Ftopic%2F659774%3F1016" target="_blank">【合辑】数据库顶会 VLDB 2025 论文下载</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fbid%2F2378966%3F1016" target="_blank">广东移动2025年省建中心云自主可控数据库（分布式OLTP）采购项目_中标候选人公示</a></li>
</ul>
<p>点击阅读原文：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%3F1016" target="_blank">https://www.modb.pro/db/1972592310860918784</a></p>
<hr>
<p>欲了解更多可浏览<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2F%3F1016" target="_blank">墨天轮社区</a>，围绕数据人的学习成长提供一站式的全面服务，打造集新闻资讯、在线问答、活动直播、在线课程、文档阅览、资源下载、知识分享及在线运维为一体的统一平台，持续促进数据领域的知识传播和技术创新。</p>
<p>关注官方公众号： 墨天轮、 墨天轮平台、墨天轮成长营、数据库国产化 、数据库资讯</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p>本文为<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2F%3F1016" target="_blank">墨天轮社区</a>整理的2025年9月国产数据库大事件和重要产品发布消息。</p>
<blockquote>
<p>2025年9月诞生了6个500万以上数据库大单。比如云南农信采购GoldenDB、GaussDB和达梦数据库，安徽农信采购GoldenDB和达梦数据库，电科金仓中标甘肃移动数据库一体机项目，广东移动采购GoldenDB、OceanBase和华为云数据库。</p>
</blockquote>
<blockquote>
<p>数据库顶会&nbsp;VLDB&nbsp;2025举行，华为、腾讯、OceanBase、创邻科技等厂商论文入选。多家厂商举办了产品发布会：矩阵起源产品发布会（发布MatrixOne与MatrixOne&nbsp;Intelligence）、云和恩墨2025秋季产品发布会（发布zData&nbsp;X、zCloud、zAIoT和MogDB等产品的最新版本）、DolphinDB&nbsp;2025年度峰会发布（发布Orca、Swordfish和Shark三款新品提升实时计算能力）、数智引航向量数据库VexDB新品发布会。此外腾讯云TDSQL家族新增TDSQL-B，OpenTenBase&nbsp;+TXSQL新版本发布，Apache&nbsp;Cloudberry&nbsp;(Incubating)&nbsp;2.0.0发布，酷克数据推出企业级数据仓库HashData&nbsp;Lightning&nbsp;2.0。</p>
</blockquote>
<h3>目录</h3>
<ul>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49_TOP10font_8" target="_blank">9月国产数据库大事记 TOP10</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49font_15" target="_blank">9月国产数据库大单</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49font_30" target="_blank">9月大事记时间线</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49font_134" target="_blank">9月产品/版本发布</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49font_253" target="_blank">9月代表厂商大事记</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size4font_263" target="_blank">相关资料</a></li>
</ul>
<h2>9月国产数据库大事记 TOP10</h2>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2ce61ce7c1.png"></p>
<h2>9月国产数据库大单</h2>
<p>2025年9月诞生了6个500万以上数据库大单。<strong>云南省农村信用社科技结算中心</strong>采购数据库产品用于云南农信同业合作系统建设，其中<strong>GoldenDB</strong>数据库采购由北京先进数通中标，中标价<strong>2687.79万元</strong>，<strong>高斯数据库</strong>采购由东华软件中标，中标价<strong>502.0032万元</strong>，<strong>达梦数据库</strong>采购由北京宇信科技中标，中标价47.2万元。<strong>安徽省农村信用社联合社</strong>&nbsp;<strong>858.496万元</strong>采购<strong>GoldenDB</strong>数据库许可和维保服务，<strong>514.35万元</strong>采购<strong>达梦数据库</strong>许可和维保服务。<strong>电科金仓</strong>&nbsp;<strong>828.0753万元</strong>中标甘肃移动数据库一体机项目。</p>
<p>此外，<strong>广东移动</strong>2025年省建中心云自主可控数据库（分布式OLTP）框采项目预估采购391套OLTP数据库，预算2463.3万元（不含税），<strong>GoldenDB</strong>&nbsp;中标 40%份额，不含税单价报价43000元/套（预估不含税670.8万元），<strong>OceanBase</strong>&nbsp;中标35%份额，不含税单价报价50000元/套（预估不含税685万元），<strong>华为云数据库</strong>中标25%份额，不含税单价报价49000元/套（预估不含税480.2万元），三种数据库预计不含税共1836万元（税点13%）。</p>
<p><strong>2025年9月数据库大单</strong><br> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-21430e8937.png"></p>
<blockquote>
<p>移动运营商和农村信用社频繁的数据库大单，显示出通信和政企行业对国产数据库的强劲需求。 点击查看<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1976139909123551232%3F1016" target="_blank">9月数据库中标情况盘点</a>。 &nbsp;</p>
</blockquote>
<h2>9月大事记时间线</h2>
<p><strong>数据库顶会 VLDB 2025 伦敦召开</strong></p>
<p>9月1日至5日，第 51 届国际大型数据库会议（<strong>VLDB 2025</strong>）在英国伦敦成功举办。本届会议汇聚了来自北美、欧洲、亚洲等地的研究学者与工程师，议题涵盖数据库系统、大规模数据管理、图数据库、机器学习与数据科学等多个前沿方向，集中展现了数据库技术在学术研究与产业实践中的最新进展与未来趋势。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-84176d0379.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-84ac36aa52.png"></p>
<ul>
<li> <p><strong>华为</strong>18篇论文入选VLDB 2025。其中<strong>GaussDB</strong>两篇亮点论文《GaussDB-Vector: A Large-Scale Persistent Real-Time Vector Database for LLM Applications》、《GRewriter: Practical Query Rewriting with Automatic Rule Set Expansion in GaussDB》分别解析了向量数据库和查询重写技术的创新。GaussDB的向量数据库针对大语言模型应用进行了优化，而GRewriter查询重写器则提高了数据库查询的效率。</p> </li>
<li> <p><strong>腾讯</strong>共有9篇论文入选，这些论文的研究方向包括分布式事务调度、混合并发控制、OLTP负载压缩、时序图计算、NL2SQL等前沿领域。研究成果已在微信、腾讯广告等亿级业务中得到应用。这些成就得益于腾讯与多所高校的深度产学研合作，部分核心成果已集成至腾讯云数据库TDSQL及大数据产品矩阵，并广泛应用于金融、政务、电商等多个行业。</p> </li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2bc332711d.png"></p>
<ul>
<li> <p><strong>OceanBase</strong>&nbsp;与浙江大学、北京邮电大学、南洋理工大学等高校的联合研究成果有 4 篇论文入选VLDB 2025，涉及分布式可靠性、安全与隐私、查询优化和智能诊断等数据库核心技术。具体包括：《Towards Practical Oblivious Map》、《RankPQO: Learning-to-Rank for Parametric Query Optimization》、《CoLA: Model Collaboration for Log-based Anomaly Detection》、《DBPecker : A Graph-Based Compound Anomaly Diagnosis System for Distributed RDBMSs》。</p> </li>
<li> <p>由<strong>创邻科技</strong>深度参与并联合主导的&nbsp;LDBC FinBench 金融图数据库测试基准，荣获大会实验、分析与基准测试“最佳论文奖”；同时，公司全自主研发的AI驱动框架——&nbsp;GalaxyWeaver：大语言模型驱动的智能图建模与优化框架，成功入选 VLDB 2025并作大会报告！</p> </li>
</ul>
<blockquote>
<p>GalaxyWeaver已全面集成于创邻科技的旗舰产品国产高性能图数据库Galaxybase，将国产图数据库产品的AI集成推向了产业应用落地的新阶段。</p>
</blockquote>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4c587d7435.png"></p>
<ul>
<li> <p><strong>蚂蚁集团</strong>发起共建并主导设计的图数据库基准研究论文《The LDBC Financial Benchmark: Transaction Workload》荣获大会实验、分析与基准测试“最佳论文亚军奖”。</p> </li>
<li> <p><strong>星环科技</strong>与华东师范大学合作的研究成果《Rebirth-Retire: A Concurrency Control Protocol Adaptable to Different Levels of Contention》被国际顶级数据库会议VLDB 2025收录。该研究提出了一种新的并发控制协议Rebirth-Retire，有效解决了数据库在高并发环境下的性能瓶颈问题。</p> </li>
<li> <p><strong>数翊科技</strong>与武汉理工大学计算机与人工智能学院在向量化计算、行列混合存储等领域展开合作。双方在数据库领域的联合论文《Select Edges Wisely: Monotonic Path Aware Graph Layout Optimization for Disk-Based ANN Search》被VLDB 2025收录。数翊科技携核心数据库产品HexaDB的最新能力正式亮相VLDB，是唯一一家主打数字化与AI基础设施型的轻量化数据库引擎的科技公司。HexaDB仅用一套计算引擎和一套数据即可同时满足交易、分析、以及大模型推理的需求。</p> </li>
</ul>
<p><strong>浪潮KaiwuDB荣获2025年度“山东电子学会科学技术奖二等奖”</strong></p>
<p>9月1日，山东电子学会公布2025年度“山东电子学会科学技术奖”评审结果。浪潮数据库（KaiwuDB）、浪潮科学院、浪潮软件集团联合项目“面向工业物联网的高性能分布式多模数据库关键技术与应用”荣获科技进步二等奖。该项目成果以分布式多模数据库系统KaiwuDB 为依托，已在山东、上海等多省市落地，成功应用于新能源、智能制造等领域，为企业数字化转型提供核心数据支撑。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e28d1248d2.png"></p>
<blockquote>
<p>该项目面向工业物联网海量异构数据管理难题开展技术攻关，创新研发基于 FPGA 的异构加速计算架构与多模态数据一体化引擎，有效解决传统数据库多模态数据处理效率低、边缘算力利用率不足、跨域数据协同困难等问题，支撑设备数据毫秒级响应及多类型数据一站式管理。</p>
</blockquote>
<p><strong>浪潮KaiwuDB荣获2025年度“山东省信息产业协会科技创新奖”</strong></p>
<p>9月1日，山东省信息产业协会公布 2025 年度“山东省信息产业协会科技创新奖”获奖名单，浪潮KaiwuDB 研发团队荣获“创新团队奖”。2025年，KaiwuDB 研发团队在多模、时序数据处理、AI 预测分析、云边端数据协同及异构计算加速等 5 大核心技术上实现突破，新申请相关专利 90 余篇。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4bdfe6640e.png"></p>
<blockquote>
<p>该奖项旨在表彰在信息技术领域做出突出贡献的企业和团队，是山东省信息产业的重要奖项之一。</p>
</blockquote>
<p><strong>《OceanBase AI Data Infra解决方案白皮书》发布</strong></p>
<p>9月2日，《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdoc%2F146946%3F1016" target="_blank">OceanBase AI Data Infra解决方案白皮书</a>》正式发布，旨在帮助企业解决数据孤岛与模型失焦问题，打破数据与模型的割裂，助力企业智能化转型。白皮书提出了DB-LLM-OPS新范式，通过多模态数据融合治理、动态向量化与混合检索、实时/批处理一体化等技术优势，打通“数据-智能-运维”闭环，实现数据价值与模型能力的协同释放，并提供了高级搜索、智能推荐、RAG应用等四大典型AI场景的解决方案。</p>
<p><strong>达梦数据护航九三阅兵，彰显硬核实力</strong></p>
<p>9月3日上午，纪念中国人民抗日战争暨世界反法西斯战争胜利80周年大会在北京天安门广场隆重举行。达梦数据为大会全程护航，全方位、7*24小时全力守护大会信息系统的安全、高效、稳定运行，圆满完成本次服务保障任务，以优异的成绩再次交出了一份让党和人民满意的答卷。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-63de488905.png"></p>
<p><strong>以Data+AI赋能产业，Kyligence荣膺2025中国数智化转型升级创新服务企业</strong></p>
<p>9月8日，由数智猿×数据猿联合主办的“2025第五届数智化转型升级发展论坛——暨 AI 大模型 &amp; AI Agent 趋势论坛”在京举行。Kyligence（跬智信息）凭借领先的 Data+AI 技术与产品，以及在金融、零售、制造等领域的标杆性 Data Agent 应用案例，从众多候选企业中脱颖而出，荣获“2025 中国数智化转型升级创新服务企业奖”。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-23ad38c3e4.png"></p>
<blockquote>
<p>Kyligence 率先将数据分析与大语言模型深度融合，推出 AI 数据智能体（Data Agent）。该产品在问数、对话分析、归因分析和报告生成等方面表现优异，以领先的准确性、可靠性和安全性赢得了众多企业级客户的信赖。今年 4 月，Kyligence 又发布业内首款具备自主推理与洞察能力的产品——DeepInsight，将专利多维分析技术与 DeepSeek 推理框架结合，帮助企业高效检索、精准分析，提供专业决策支持。</p>
</blockquote>
<p><strong>电科金仓与海光信息签署战略合作</strong></p>
<p>9月11日，电科金仓与海光信息正式签署战略合作协议，双方将整合核心优势聚焦“产品联合研发适配优化、市场联合拓展和联合品牌建设”三大方向合作。双方还将以此次签约为契机，推动集团层面“计算+云+数据库”核心领域生态协同，涵盖政务云平台共建、定制化终端解决方案研发及市场资源共享，聚力打造技术领先、服务高效的行业智能解决方案。</p>
<p><strong>OceanBase联合中国银行保险报发布《面向AI时代的中小银行数据库研究与展望》报告</strong></p>
<p>9月11日，在金融科技年度盛会外滩大会举办期间，OceanBase 领衔发起“金融 CIO 数智跃迁闭门会”，并联合《中国银行保险报》发布业内首本聚焦 AI 时代中小银行数据库的研究报告——《面向AI时代的中小银行数据库研究与展望》。报告深入剖析了银行业强化数据库建设的时代背景，梳理了银行业务系统数据库的演进趋势与转型升级现状，以及 AI 驱动中小银行业务转型的机遇与挑战。针对 AI 时代中小银行数据库升级面临的难点与痛点，报告还提出了解决方案以及转型升级参考指南、方法论和未来发展趋势与展望。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-7c58f6bac9.png"></p>
<blockquote>
<p>根据课题组调研，当前中国银行业数据库国产升级进程在金融业处于领先地位。超 50% 的银行核心系统已采用分布式数据库，预计未来三年渗透率将突破 90%，其中 OceanBase 以 39.1% 的市场份额位居首位。</p>
</blockquote>
<p><strong>《HTAP数据库技术要求》等五项数据库技术标准正式发布</strong></p>
<p>9月17日，中国通信标准化协会公告显示，由中国信息通信研究院牵头的 T/CCSA 722-2025《基于无服务器架构的事务型数据库能力分级要求》、T/CCSA 723-2025《基于无服务器架构的分析型数据库能力分级要求》、T/CCSA 725-2025《数据库一体机技术要求》、T/CCSA 726-2025《数据库迁移工具能力要求》、T/CCSA 727-2025《事务分析混合型（HTAP）数据库技术要求》等多项数据库技术团体标准已于2025年9月17日正式发布，并将于2025年12月18日正式实施。</p>
<p><strong>浪潮KaiwuDB荣获2025年度“山东计算机学会科技进步二等奖”</strong></p>
<p>9月18日，山东计算机学会通报 2025 年度“山东计算机学会科学技术奖”获奖项目名单，浪潮数据库（KaiwuDB）、浪潮软件集团联合提报项目“开务数据库(KaiwuDB) 高性能 HTAP 引擎关键技术研究与应用”荣获科技进步奖二等奖。该项目在KaiwuDB SQL 语法兼容性、算子支持、优化器自治运行、索引智能推荐、混合多模存储及 HTAP（混合事务/分析处理）架构等技术方向上创新突破，从内核优化维度大幅提升 KaiwuDB 查询分析性能。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0a6f802497.png"></p>
<p><strong>云和恩墨与达梦数据签订战略合作协议，深化数据库生态协同发展</strong></p>
<p>9月19日，云和恩墨与达梦数据正式达成全面战略合作。此次战略合作协议的签订，标志着双方将在接下来的时间里，围绕产品推广、解决方案融合、人才培养、市场拓展和项目支持五大维度开展深度协作，共同推动国产数据库技术生态的完善与落地应用，助力千行百业实现数字化转型升级。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5026e1fa8f.png"></p>
<p><strong>OceanBase 亮相中国通信展！五大实践获 ICT 中国一等奖</strong></p>
<p>9月24日至26日，2025 年中国国际信息通信展览会在北京举行。现场，ICT 中国（2025）案例一等案例公布，OceanBase 五大案例入选并获表彰。案例包含：联通软研院基于 OceanBase 构建 AI 增强型智能数据平台；广东移动核心系统打造 XC 新一代数据库底座；江苏移动核心系统 XC 数据库替代项目；跨中心双活+智能调度：中移金科基于 OceanBase 打造金融级高可用数据库底座；运营商经营分析系统基于 OceanBase AP 能力的创新实践。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-58b69f4144.png"></p>
<p><strong>《OceanBase 实时分析能力白皮书》发布</strong></p>
<p>9月25日消息，《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdoc%2F147171%3F1016" target="_blank">OceanBase 实时分析能力白皮书</a>》发布，旨在帮助企业应对 GenAI 时代下数据分析面临的架构复杂、数据延迟、成本高昂、多模融合等挑战。OceanBase 通过自研列存引擎、向量化执行引擎、多模一体化等技术，实现了一站式数据管理和实时分析，已在金融、零售、运营商等行业核心场景中验证，显著提升数据查询时效和系统性能，为企业提供高效、极简、智能的数据底座。</p>
<h2>9月产品/版本发布</h2>
<p><strong>Apache Cloudberry (Incubating) 2.0.0 发布！</strong></p>
<p>9月4日消息，Apache Cloudberry (Incubating) 2.0.0正式发布，这是该项目自2024年10月加入Apache软件基金会孵化器以来的首个正式版本。Cloudberry是一款开源大规模并行处理（MPP）数据库，支持本地和云上部署，为数据仓库和高级分析提供可扩展的基础。2.0.0版本基于PostgreSQL 14.x构建，主要亮点包括：分布式查询规划和执行的显著改进、增强的资源管理、改进的并行处理、动态表功能以及PAX存储格式的引入。此外，该版本还更新了许可证标头和依赖项属性，以满足ASF合规性要求。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-fa97c58a23.png"></p>
<p><strong>GreptimeDB v0.17 发布！Flow 现已支持 TQL（PromQL）</strong></p>
<p>9月5日，GreptimeDB v0.17版本正式发布。新版本增强了60项功能，如PromQL优化和TQL CTE支持，修复了32项错误，进行了2项性能优化，提升了稀疏编码器性能235%，改进了60项文档，并进行了1项测试优化和27项杂项任务。此外，Flow支持TQL（PromQL），Reconciliation Procedures功能可处理元数据备份恢复后与集群新数据不兼容的问题。</p>
<p><strong>IvorySQL 4.6 发布，全面支持 PostgreSQL 17.6</strong></p>
<p>9月5日，IvorySQL 4.6版本正式发布，全面支持PostgreSQL 17.6并带来多项新功能和已知问题的修复。增强功能包括加强规划器估计函数中的安全检查、防止pg_dump脚本被用于攻击等。新增特性有升级至PG 17.6内核、兼容MongoDB的解决方案、全平台LoongArch打包、IvorySQL在线试用、容器化部署支持（Docker Swarm和Kubernetes）以及IvorySQL Cloud v4.0发布。</p>
<p><strong>矩阵起源产品发布会发布MatrixOne与MatrixOne Intelligence</strong></p>
<p>9月12日，矩阵起源在上海举办“以数生智、以智驭数”产品发布会，正式推出两款战略级核心产品：超融合异构云原生数据库 MatrixOne (MO) 与 AI原生多模态数据智能平台 MatrixOne Intelligence (MOI)。<strong>超融合异构云原生数据库MatrixOne</strong>&nbsp;的核心是超融合架构，将 HTAP（混合事务/分析处理）、流处理、向量检索、全文搜索原生整合到同一引擎中，从根本上消除了长期困扰企业的数据孤岛问题。而平台的另一大创新是引入&nbsp;“数据的Git”新范式：通过将版本管理、分支、回滚、审计等软件工程理念引入数据管理，显著缩短了 AI 项目的开发周期，并加速跨团队协作，极大提升企业在复杂数据场景下的敏捷性。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-98d57c6e32.png"></p>
<ul>
<li><strong>AI原生多模态数据智能平台MatrixOne IntelligenceMOI</strong>&nbsp;产品的定位是下一代 Data Infrastructure，技术对标 Databricks + Snowflake，聚焦企业AI落地难题。MOI具备五大核心创新能力：融合架构实现数据统一管理，消除数据栈割裂；Agentic数据治理自动优化数据处理，降低人力依赖；智能数据解析高效处理非结构化数据，减少80%人工处理量；高性能运行底座支撑多并发业务；全链路安全保障确保数据安全与合规。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oss-emcsprod-public.modb.pro-155c8e8b9b.png"></p>
<ul>
<li>发布会还宣布了与多家企业及机构的战略合作：与赛意信息共创“AI+数字化工厂”，与辰奕智能合作加速AI在制造业落地。与上海云基地合作深化产业链联动，打造“方案孵化器”。此外，还与安畅网络、启数智能、迪际特科技等企业合作，推动AI在金融、制造、零售、公共安全、智慧城市等领域的应用落地。</li>
</ul>
<p><strong>云和恩墨2025秋季产品发布会线上举行</strong></p>
<p>9月12日，云和恩墨在2025年秋季产品发布会上推出了zData X、zCloud、zAIoT和MogDB等产品的最新版本，这些产品体现了公司在数据库一体机、智能化运维、数据智能和异构数据库迁移服务方面的最新进展。zData X 3.5版本展示了更高的性能、更优的成本和更易的运维；zCloud 6.7.2版本增强了对主流开源和国产数据库的兼容性和智能化运维能力；zAIoT 3.0版本在军工和工业制造领域的数据升值方面取得了显著成效；MogDB则通过“订阅使用”模式提供了商业发行版的企业级关系型数据库，用户只需支付服务费即可获得官方支持。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9f4a5b2c67.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-98c0a7d749.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4584d54e0a.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-b8033b27ad.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-68f9682f90.png"></p>
<p><strong>「Infra + AI 至简致远」DolphinDB 2025 年度峰会圆满举办</strong></p>
<p>9月12日，DolphinDB 2025年度峰会在杭州成功举办，吸引了近300位来自金融行业的嘉宾。DolphinDB 研发副总监程训焘博士通过《2025 DolphinDB 新产品发布》演讲，深入探讨了 DolphinDB 在实时计算领域的重大进展。程博士着重介绍了企业级实时计算平台 Orca&nbsp;的推出及其主要功能和优势。此外，程博士还介绍了 Swordfish 低延时嵌入式引擎和 Shark CPU/GPU 异构计算平台，展望了 DolphinDB 在 AI 时代的发展。此外，DolphinDB还发布了AI Agent，通过自我验证和迭代纠错机制，使AI更自然地融入金融研究与投资实践。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-46be047b3c.png"></p>
<ul>
<li><strong>Orca</strong>是DolphinDB推出的企业级实时计算平台，通过简化流计算任务的开发流程，支持多模态数据的统一处理，并提供针对金融等行业的专用数据模型，实现了企业级高可用性和跨地域协同计算。这一平台使得开发者能够以声明式方式描述流计算需求，自动生成计算图并智能规划资源，从而显著降低开发和运维的复杂性。Orca为企业在量化投研、物联网监控等场景提供了强大的实时计算支持。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-c040ece78b.png"></p>
<ul>
<li><strong>Swordfish</strong>是一款高性能计算函数库，专为<code>C++</code>程序设计，内含DolphinDB自研的计算内核，拥有超过2000个函数和流计算引擎。它通过在本地硬件上直接执行计算，避免了网络访问服务器的延迟，实现了十微秒甚至单微秒级的计算延迟，显著提升了高频计算任务的性能。Swordfish目前已支持C++和Java，未来还将推出Python版本。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e4d8c9fff0.png"></p>
<ul>
<li><strong>Shark</strong>是DolphinDB与海光信息合作开发的CPU/GPU异构计算平台，其核心组件Shark Graph并行计算引擎显著提升了性能，使因子挖掘速度提高了10倍以上，并且能够通过简单的“@GPU”标签实现DolphinDB脚本在GPU上的一键加速，性能提升可达10至20倍，同时减少CPU和内存占用。目前，Shark平台已支持海光DCU处理器，并计划继续优化国产处理器的性能和易用性，以提供更强大的计算能力。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-ee7ea33f10.png"></p>
<p><strong>腾讯云TDSQL自研产品家族扩容，数据库AI服务正式发布</strong></p>
<p>9月17日，在2025腾讯全球数字生态大会上，腾讯云正式公布自研数据库TDSQL全新产品家族，包含TDSQL（超大规模分布式关系型数据库）、TDSQL-C（云原生关系型数据库）、新亮相的TDSQL-B（超高性能分布式集群）三款产品，满足企业在智能化和全球化时代的不同场景需求；同时推出数据库AI服务（（TencentDB AI Service，简称TDAI））和业内首个AI自学习优化器，以AI技术驱动数据库进化。此外，腾讯云数据库启动第三届开放原子大赛——OpenTenBase多模态分析挑战赛和OpenTenBase-TXSQL SQL改写优化挑战赛，共60万奖金以激发开发者创新，举办生态伙伴颁奖仪式表彰优秀合作者，并发布学术生态建设成果。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-a2fff61047.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-fe51a4676d.png"></p>
<ul>
<li><strong>TDSQL-B</strong>：本次大会重磅发布的专为敏态业务打造的超高性能分布式集群，特别适用于金融场景和高增长业务。TDSQL-B 聚焦三大核心能力。首先是金融级高可靠，通过多副本容灾和快速故障恢复，实现数据零丢失、服务零中断。其次是性能突破，具备百万级 QPS 处理能力与海量存储，同时拥有无限的 TP 扩展性与轻量 AP 能力，能够轻松应对电商大促订单峰值、直播弹幕互动等高并发事务场景。TDSQL-B 在语法兼容性方面 100% 兼容 MySQL，支持分钟级弹性扩缩容，既“好用如单机”，又能抗流量洪峰。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-f99e4a2951.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6622f7dae9.png"></p>
<ul>
<li>腾讯云正式推出<strong>数据库AI服务</strong>（TencentDB AI Service，简称<strong>TDAI</strong>）旨在用AI帮助企业治理好数据库、用好数据。TDAI依托自研数据库大模型、全域上下文、工具集这三大智能体基础设施，构建了数据库DevOps与数据洞察两大核心场景的智能体服务，将智能体能力引入数据库治理。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9e332391a5.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-03decc0157.png"></p>
<ul>
<li>腾讯云还推出了行业首个<strong>AI自学习优化器</strong>，突破传统优化器在复杂场景中的局限性。AI自学习优化器通过全局探索最优执行计划、可量化的数据反馈、动态适配代价模型，和反思演进这四大能力，让复杂查询时延降低80%以上。凭借这一创新，客户无需人力投入，即可实现数据库的自动调优。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2a7780ce94.png"></p>
<ul>
<li>开放原子开源基金会秘书长助理李博、腾讯云数据库总经理王义成与多位高校代表共同启动了&nbsp;<strong>OpenTenBase 5.0</strong>&nbsp;与&nbsp;<strong>TXSQL 8.0.30</strong>&nbsp;新版本发布仪式。本次重磅发布的OpenTenBase 5.0 版本在 Oracle 兼容性、分布式性能、HTAP 能力三个方向实现跨越式升级，全新支持 AI 多模态能力，支持灵活集成大模型，向 Data + AI 共生进化迈出坚实的一步。OpenTenBase 强势推出 opentenbase_ai 插件，为 OpenTenBase 数据库提供了集成人工智能大语言模型能力的接口，让你能够直接在 SQL 中使用 AI 能力。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e918a72307.png"></p>
<blockquote>
<p>OpenAtom OpenTenBase 是一款企业级分布式 HTAP 开源数据库，是 TDSQL 的社区发行版，2023 年 12 月贡献给开放原子开源基金会，其已成功应用于金融、医疗、航天等行业的核心业务系统。TXSQL 是腾讯云数据库团队基于 MySQL 深度定制的企业级数据库内核，去年 9 月，腾讯云数据库向 OpenTenBase 社区捐赠了&nbsp;TXSQL&nbsp;内核。TXSQL 对 InnoDB 存储引擎、查询优化、复制性能等方面进行了大量优化，具有高安全、低成本、易维护等特性，具有透明列加密、透明列压缩、Undo 闪回查询等企业级特性。</p>
</blockquote>
<p><strong>时序数据库 TimechoDB V2.0.6 发布 | 新增查询写回、黑白名单等功能</strong></p>
<p>9月23日，TimechoDBV2.0.6 版本正式发布！TimechoDB 是由&nbsp;IoTDB原厂团队开发的企业级时序数据库产品。V2.0.6 版本新增表模型查询写回功能，新增访问控制黑白名单功能，新增位操作函数（内置标量函数）以及可下推的时间函数，同时对数据库监控、性能、稳定性进行了全方位提升。</p>
<p><strong>云栖重磅｜瑶池数据库：从云原生数据底座向“AI就绪”的多模态数据底座演进</strong></p>
<p>9月24日，云栖大会上，<strong>阿里云瑶池数据库</strong>宣布从云原生数据底座向“AI就绪”的多模态数据底座演进。瑶池数据库推出全球首款基于CXL 2.0 Switch技术的<strong>PolarDB</strong>数据库专用服务器，树立了内存池化新标杆。同时，瑶池数据库发布「基于湖仓库一体化」的多模数据智能管理平台，支持多模态数据管理，融合OLTP和OLAP能力，支持AI算子能力（AI in SQL），让AI应用开发更高效。此外，瑶池数据库还推出ApsaraDB Agent智能顾问，提供一站式、7×24小时不间断的云数据库智能顾问服务，帮助企业轻松“驾驭”数据。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0a2994ecb1.png"></p>
<p><strong>酷克数据推出企业级数据仓库HashData Lightning 2.0</strong></p>
<p>9月24日，酷克数据HashData推出了企业级数据仓库HashData Lightning 2.0，该版本基于Apache Cloudberry 2.0内核，增强了复杂查询优化、存储管控等功能，提供了更低延迟、更高稳定性和并发支撑能力。Lightning 2.0引入了新监控工具CBCC、灾备恢复工具CBDR，并集成了一站式数据科学与AI开发工具箱HashML，实现了数据准备到模型部署的闭环能力。</p>
<p><strong>为AI而生！源于清华的向量数据库VexDB产品发布</strong></p>
<p>9月25日，源于清华的数智引航公司发布了名为VexDB的向量数据库。李国良教授介绍：“VexDB的名字由‘Vector+X+Database’的缩写组成，代表着能释放无限可能的多模态向量数据库。”该产品是一款融合关系型数据库能力和多路语义检索能力的向量数据库，可支持百亿向量数据毫秒级结果查询，召回准确度稳定在99%以上，具备“高性能、大容量、高精度、强一致、高可用、高安全、易用性”的七大产品特性，适用于推荐系统、语义搜索、图像识别等核心应用，全方位满足AI时代复杂场景下的数据检索需求。数智引航目前开发了适用于企业级AI应用场景的VexDB商业版，以及适用于开发商、个人开发者和开源项目的VexDB开发版，开发版提供一年的免费试用。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-3e7fdf0e83.png"></p>
<h2>9月代表厂商大事记</h2>
<p>【<strong>KaiwuDB</strong>】<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972224902111440896%3F1016" target="_blank"><strong>《KaiwuDB 2025年9月大事记》</strong></a></p>
<p>&nbsp; &nbsp;&nbsp;<strong>看点速览</strong></p>
<ul>
<li>KaiwuDB 荣获 2025 年度“山东电子学会科学技术奖二等奖”</li>
<li>KWDB社区携手“开放原子校源行”走进河北工业大学</li>
<li>浪潮数据库(KaiwuDB)、华师大联合论文获国际顶会NeurIPS 2025收录</li>
</ul>
<h2>相关资料</h2>
<ul>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2FdbRank%3F1016" target="_blank">墨天轮中国数据库流行度排行榜-2025年10月已更新</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F189802%3F1016" target="_blank">墨天轮中国数据库流行度排行榜规则解读</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Ftopic%2F61684%3F1016" target="_blank">月度国产数据库大事记合辑</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Ftopic%2F4704%3F1016" target="_blank">中国数据库排行榜 - 月度解读</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fbid%3F%3F1016" target="_blank">国产数据库招投标信息汇总</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdoc%2F146946%3F1016" target="_blank">《OceanBase AI Data Infra解决方案白皮书》_2025.pdf</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdoc%2F147171%3F1016" target="_blank">《OceanBase 实时分析能力白皮书》.pdf</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ccsa.org.cn%2Fdetail%2F%3Fid%3D55463%26title" target="_blank">《HTAP数据库技术要求》等五项数据库技术标准-中国通信标准化协会公告</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Ftopic%2F659774%3F1016" target="_blank">【合辑】数据库顶会 VLDB 2025 论文下载</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fbid%2F2378966%3F1016" target="_blank">广东移动2025年省建中心云自主可控数据库（分布式OLTP）采购项目_中标候选人公示</a></li>
</ul>
<p>点击阅读原文：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%3F1016" target="_blank">https://www.modb.pro/db/1972592310860918784</a></p>
<hr>
<p>欲了解更多可浏览<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2F%3F1016" target="_blank">墨天轮社区</a>，围绕数据人的学习成长提供一站式的全面服务，打造集新闻资讯、在线问答、活动直播、在线课程、文档阅览、资源下载、知识分享及在线运维为一体的统一平台，持续促进数据领域的知识传播和技术创新。</p>
<p>关注官方公众号： 墨天轮、 墨天轮平台、墨天轮成长营、数据库国产化 、数据库资讯</p>]]>
    </description>
    <content:encoded><![CDATA[<p>本文为<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2F%3F1016" target="_blank">墨天轮社区</a>整理的2025年9月国产数据库大事件和重要产品发布消息。</p>
<blockquote>
<p>2025年9月诞生了6个500万以上数据库大单。比如云南农信采购GoldenDB、GaussDB和达梦数据库，安徽农信采购GoldenDB和达梦数据库，电科金仓中标甘肃移动数据库一体机项目，广东移动采购GoldenDB、OceanBase和华为云数据库。</p>
</blockquote>
<blockquote>
<p>数据库顶会&nbsp;VLDB&nbsp;2025举行，华为、腾讯、OceanBase、创邻科技等厂商论文入选。多家厂商举办了产品发布会：矩阵起源产品发布会（发布MatrixOne与MatrixOne&nbsp;Intelligence）、云和恩墨2025秋季产品发布会（发布zData&nbsp;X、zCloud、zAIoT和MogDB等产品的最新版本）、DolphinDB&nbsp;2025年度峰会发布（发布Orca、Swordfish和Shark三款新品提升实时计算能力）、数智引航向量数据库VexDB新品发布会。此外腾讯云TDSQL家族新增TDSQL-B，OpenTenBase&nbsp;+TXSQL新版本发布，Apache&nbsp;Cloudberry&nbsp;(Incubating)&nbsp;2.0.0发布，酷克数据推出企业级数据仓库HashData&nbsp;Lightning&nbsp;2.0。</p>
</blockquote>
<h3>目录</h3>
<ul>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49_TOP10font_8" target="_blank">9月国产数据库大事记 TOP10</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49font_15" target="_blank">9月国产数据库大单</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49font_30" target="_blank">9月大事记时间线</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49font_134" target="_blank">9月产品/版本发布</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size49font_253" target="_blank">9月代表厂商大事记</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%23font_color4169E1_size4font_263" target="_blank">相关资料</a></li>
</ul>
<h2>9月国产数据库大事记 TOP10</h2>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2ce61ce7c1.png"></p>
<h2>9月国产数据库大单</h2>
<p>2025年9月诞生了6个500万以上数据库大单。<strong>云南省农村信用社科技结算中心</strong>采购数据库产品用于云南农信同业合作系统建设，其中<strong>GoldenDB</strong>数据库采购由北京先进数通中标，中标价<strong>2687.79万元</strong>，<strong>高斯数据库</strong>采购由东华软件中标，中标价<strong>502.0032万元</strong>，<strong>达梦数据库</strong>采购由北京宇信科技中标，中标价47.2万元。<strong>安徽省农村信用社联合社</strong>&nbsp;<strong>858.496万元</strong>采购<strong>GoldenDB</strong>数据库许可和维保服务，<strong>514.35万元</strong>采购<strong>达梦数据库</strong>许可和维保服务。<strong>电科金仓</strong>&nbsp;<strong>828.0753万元</strong>中标甘肃移动数据库一体机项目。</p>
<p>此外，<strong>广东移动</strong>2025年省建中心云自主可控数据库（分布式OLTP）框采项目预估采购391套OLTP数据库，预算2463.3万元（不含税），<strong>GoldenDB</strong>&nbsp;中标 40%份额，不含税单价报价43000元/套（预估不含税670.8万元），<strong>OceanBase</strong>&nbsp;中标35%份额，不含税单价报价50000元/套（预估不含税685万元），<strong>华为云数据库</strong>中标25%份额，不含税单价报价49000元/套（预估不含税480.2万元），三种数据库预计不含税共1836万元（税点13%）。</p>
<p><strong>2025年9月数据库大单</strong><br> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-21430e8937.png"></p>
<blockquote>
<p>移动运营商和农村信用社频繁的数据库大单，显示出通信和政企行业对国产数据库的强劲需求。 点击查看<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1976139909123551232%3F1016" target="_blank">9月数据库中标情况盘点</a>。 &nbsp;</p>
</blockquote>
<h2>9月大事记时间线</h2>
<p><strong>数据库顶会 VLDB 2025 伦敦召开</strong></p>
<p>9月1日至5日，第 51 届国际大型数据库会议（<strong>VLDB 2025</strong>）在英国伦敦成功举办。本届会议汇聚了来自北美、欧洲、亚洲等地的研究学者与工程师，议题涵盖数据库系统、大规模数据管理、图数据库、机器学习与数据科学等多个前沿方向，集中展现了数据库技术在学术研究与产业实践中的最新进展与未来趋势。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-84176d0379.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-84ac36aa52.png"></p>
<ul>
<li> <p><strong>华为</strong>18篇论文入选VLDB 2025。其中<strong>GaussDB</strong>两篇亮点论文《GaussDB-Vector: A Large-Scale Persistent Real-Time Vector Database for LLM Applications》、《GRewriter: Practical Query Rewriting with Automatic Rule Set Expansion in GaussDB》分别解析了向量数据库和查询重写技术的创新。GaussDB的向量数据库针对大语言模型应用进行了优化，而GRewriter查询重写器则提高了数据库查询的效率。</p> </li>
<li> <p><strong>腾讯</strong>共有9篇论文入选，这些论文的研究方向包括分布式事务调度、混合并发控制、OLTP负载压缩、时序图计算、NL2SQL等前沿领域。研究成果已在微信、腾讯广告等亿级业务中得到应用。这些成就得益于腾讯与多所高校的深度产学研合作，部分核心成果已集成至腾讯云数据库TDSQL及大数据产品矩阵，并广泛应用于金融、政务、电商等多个行业。</p> </li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2bc332711d.png"></p>
<ul>
<li> <p><strong>OceanBase</strong>&nbsp;与浙江大学、北京邮电大学、南洋理工大学等高校的联合研究成果有 4 篇论文入选VLDB 2025，涉及分布式可靠性、安全与隐私、查询优化和智能诊断等数据库核心技术。具体包括：《Towards Practical Oblivious Map》、《RankPQO: Learning-to-Rank for Parametric Query Optimization》、《CoLA: Model Collaboration for Log-based Anomaly Detection》、《DBPecker : A Graph-Based Compound Anomaly Diagnosis System for Distributed RDBMSs》。</p> </li>
<li> <p>由<strong>创邻科技</strong>深度参与并联合主导的&nbsp;LDBC FinBench 金融图数据库测试基准，荣获大会实验、分析与基准测试“最佳论文奖”；同时，公司全自主研发的AI驱动框架——&nbsp;GalaxyWeaver：大语言模型驱动的智能图建模与优化框架，成功入选 VLDB 2025并作大会报告！</p> </li>
</ul>
<blockquote>
<p>GalaxyWeaver已全面集成于创邻科技的旗舰产品国产高性能图数据库Galaxybase，将国产图数据库产品的AI集成推向了产业应用落地的新阶段。</p>
</blockquote>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4c587d7435.png"></p>
<ul>
<li> <p><strong>蚂蚁集团</strong>发起共建并主导设计的图数据库基准研究论文《The LDBC Financial Benchmark: Transaction Workload》荣获大会实验、分析与基准测试“最佳论文亚军奖”。</p> </li>
<li> <p><strong>星环科技</strong>与华东师范大学合作的研究成果《Rebirth-Retire: A Concurrency Control Protocol Adaptable to Different Levels of Contention》被国际顶级数据库会议VLDB 2025收录。该研究提出了一种新的并发控制协议Rebirth-Retire，有效解决了数据库在高并发环境下的性能瓶颈问题。</p> </li>
<li> <p><strong>数翊科技</strong>与武汉理工大学计算机与人工智能学院在向量化计算、行列混合存储等领域展开合作。双方在数据库领域的联合论文《Select Edges Wisely: Monotonic Path Aware Graph Layout Optimization for Disk-Based ANN Search》被VLDB 2025收录。数翊科技携核心数据库产品HexaDB的最新能力正式亮相VLDB，是唯一一家主打数字化与AI基础设施型的轻量化数据库引擎的科技公司。HexaDB仅用一套计算引擎和一套数据即可同时满足交易、分析、以及大模型推理的需求。</p> </li>
</ul>
<p><strong>浪潮KaiwuDB荣获2025年度“山东电子学会科学技术奖二等奖”</strong></p>
<p>9月1日，山东电子学会公布2025年度“山东电子学会科学技术奖”评审结果。浪潮数据库（KaiwuDB）、浪潮科学院、浪潮软件集团联合项目“面向工业物联网的高性能分布式多模数据库关键技术与应用”荣获科技进步二等奖。该项目成果以分布式多模数据库系统KaiwuDB 为依托，已在山东、上海等多省市落地，成功应用于新能源、智能制造等领域，为企业数字化转型提供核心数据支撑。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e28d1248d2.png"></p>
<blockquote>
<p>该项目面向工业物联网海量异构数据管理难题开展技术攻关，创新研发基于 FPGA 的异构加速计算架构与多模态数据一体化引擎，有效解决传统数据库多模态数据处理效率低、边缘算力利用率不足、跨域数据协同困难等问题，支撑设备数据毫秒级响应及多类型数据一站式管理。</p>
</blockquote>
<p><strong>浪潮KaiwuDB荣获2025年度“山东省信息产业协会科技创新奖”</strong></p>
<p>9月1日，山东省信息产业协会公布 2025 年度“山东省信息产业协会科技创新奖”获奖名单，浪潮KaiwuDB 研发团队荣获“创新团队奖”。2025年，KaiwuDB 研发团队在多模、时序数据处理、AI 预测分析、云边端数据协同及异构计算加速等 5 大核心技术上实现突破，新申请相关专利 90 余篇。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4bdfe6640e.png"></p>
<blockquote>
<p>该奖项旨在表彰在信息技术领域做出突出贡献的企业和团队，是山东省信息产业的重要奖项之一。</p>
</blockquote>
<p><strong>《OceanBase AI Data Infra解决方案白皮书》发布</strong></p>
<p>9月2日，《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdoc%2F146946%3F1016" target="_blank">OceanBase AI Data Infra解决方案白皮书</a>》正式发布，旨在帮助企业解决数据孤岛与模型失焦问题，打破数据与模型的割裂，助力企业智能化转型。白皮书提出了DB-LLM-OPS新范式，通过多模态数据融合治理、动态向量化与混合检索、实时/批处理一体化等技术优势，打通“数据-智能-运维”闭环，实现数据价值与模型能力的协同释放，并提供了高级搜索、智能推荐、RAG应用等四大典型AI场景的解决方案。</p>
<p><strong>达梦数据护航九三阅兵，彰显硬核实力</strong></p>
<p>9月3日上午，纪念中国人民抗日战争暨世界反法西斯战争胜利80周年大会在北京天安门广场隆重举行。达梦数据为大会全程护航，全方位、7*24小时全力守护大会信息系统的安全、高效、稳定运行，圆满完成本次服务保障任务，以优异的成绩再次交出了一份让党和人民满意的答卷。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-63de488905.png"></p>
<p><strong>以Data+AI赋能产业，Kyligence荣膺2025中国数智化转型升级创新服务企业</strong></p>
<p>9月8日，由数智猿×数据猿联合主办的“2025第五届数智化转型升级发展论坛——暨 AI 大模型 &amp; AI Agent 趋势论坛”在京举行。Kyligence（跬智信息）凭借领先的 Data+AI 技术与产品，以及在金融、零售、制造等领域的标杆性 Data Agent 应用案例，从众多候选企业中脱颖而出，荣获“2025 中国数智化转型升级创新服务企业奖”。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-23ad38c3e4.png"></p>
<blockquote>
<p>Kyligence 率先将数据分析与大语言模型深度融合，推出 AI 数据智能体（Data Agent）。该产品在问数、对话分析、归因分析和报告生成等方面表现优异，以领先的准确性、可靠性和安全性赢得了众多企业级客户的信赖。今年 4 月，Kyligence 又发布业内首款具备自主推理与洞察能力的产品——DeepInsight，将专利多维分析技术与 DeepSeek 推理框架结合，帮助企业高效检索、精准分析，提供专业决策支持。</p>
</blockquote>
<p><strong>电科金仓与海光信息签署战略合作</strong></p>
<p>9月11日，电科金仓与海光信息正式签署战略合作协议，双方将整合核心优势聚焦“产品联合研发适配优化、市场联合拓展和联合品牌建设”三大方向合作。双方还将以此次签约为契机，推动集团层面“计算+云+数据库”核心领域生态协同，涵盖政务云平台共建、定制化终端解决方案研发及市场资源共享，聚力打造技术领先、服务高效的行业智能解决方案。</p>
<p><strong>OceanBase联合中国银行保险报发布《面向AI时代的中小银行数据库研究与展望》报告</strong></p>
<p>9月11日，在金融科技年度盛会外滩大会举办期间，OceanBase 领衔发起“金融 CIO 数智跃迁闭门会”，并联合《中国银行保险报》发布业内首本聚焦 AI 时代中小银行数据库的研究报告——《面向AI时代的中小银行数据库研究与展望》。报告深入剖析了银行业强化数据库建设的时代背景，梳理了银行业务系统数据库的演进趋势与转型升级现状，以及 AI 驱动中小银行业务转型的机遇与挑战。针对 AI 时代中小银行数据库升级面临的难点与痛点，报告还提出了解决方案以及转型升级参考指南、方法论和未来发展趋势与展望。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-7c58f6bac9.png"></p>
<blockquote>
<p>根据课题组调研，当前中国银行业数据库国产升级进程在金融业处于领先地位。超 50% 的银行核心系统已采用分布式数据库，预计未来三年渗透率将突破 90%，其中 OceanBase 以 39.1% 的市场份额位居首位。</p>
</blockquote>
<p><strong>《HTAP数据库技术要求》等五项数据库技术标准正式发布</strong></p>
<p>9月17日，中国通信标准化协会公告显示，由中国信息通信研究院牵头的 T/CCSA 722-2025《基于无服务器架构的事务型数据库能力分级要求》、T/CCSA 723-2025《基于无服务器架构的分析型数据库能力分级要求》、T/CCSA 725-2025《数据库一体机技术要求》、T/CCSA 726-2025《数据库迁移工具能力要求》、T/CCSA 727-2025《事务分析混合型（HTAP）数据库技术要求》等多项数据库技术团体标准已于2025年9月17日正式发布，并将于2025年12月18日正式实施。</p>
<p><strong>浪潮KaiwuDB荣获2025年度“山东计算机学会科技进步二等奖”</strong></p>
<p>9月18日，山东计算机学会通报 2025 年度“山东计算机学会科学技术奖”获奖项目名单，浪潮数据库（KaiwuDB）、浪潮软件集团联合提报项目“开务数据库(KaiwuDB) 高性能 HTAP 引擎关键技术研究与应用”荣获科技进步奖二等奖。该项目在KaiwuDB SQL 语法兼容性、算子支持、优化器自治运行、索引智能推荐、混合多模存储及 HTAP（混合事务/分析处理）架构等技术方向上创新突破，从内核优化维度大幅提升 KaiwuDB 查询分析性能。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0a6f802497.png"></p>
<p><strong>云和恩墨与达梦数据签订战略合作协议，深化数据库生态协同发展</strong></p>
<p>9月19日，云和恩墨与达梦数据正式达成全面战略合作。此次战略合作协议的签订，标志着双方将在接下来的时间里，围绕产品推广、解决方案融合、人才培养、市场拓展和项目支持五大维度开展深度协作，共同推动国产数据库技术生态的完善与落地应用，助力千行百业实现数字化转型升级。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5026e1fa8f.png"></p>
<p><strong>OceanBase 亮相中国通信展！五大实践获 ICT 中国一等奖</strong></p>
<p>9月24日至26日，2025 年中国国际信息通信展览会在北京举行。现场，ICT 中国（2025）案例一等案例公布，OceanBase 五大案例入选并获表彰。案例包含：联通软研院基于 OceanBase 构建 AI 增强型智能数据平台；广东移动核心系统打造 XC 新一代数据库底座；江苏移动核心系统 XC 数据库替代项目；跨中心双活+智能调度：中移金科基于 OceanBase 打造金融级高可用数据库底座；运营商经营分析系统基于 OceanBase AP 能力的创新实践。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-58b69f4144.png"></p>
<p><strong>《OceanBase 实时分析能力白皮书》发布</strong></p>
<p>9月25日消息，《<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdoc%2F147171%3F1016" target="_blank">OceanBase 实时分析能力白皮书</a>》发布，旨在帮助企业应对 GenAI 时代下数据分析面临的架构复杂、数据延迟、成本高昂、多模融合等挑战。OceanBase 通过自研列存引擎、向量化执行引擎、多模一体化等技术，实现了一站式数据管理和实时分析，已在金融、零售、运营商等行业核心场景中验证，显著提升数据查询时效和系统性能，为企业提供高效、极简、智能的数据底座。</p>
<h2>9月产品/版本发布</h2>
<p><strong>Apache Cloudberry (Incubating) 2.0.0 发布！</strong></p>
<p>9月4日消息，Apache Cloudberry (Incubating) 2.0.0正式发布，这是该项目自2024年10月加入Apache软件基金会孵化器以来的首个正式版本。Cloudberry是一款开源大规模并行处理（MPP）数据库，支持本地和云上部署，为数据仓库和高级分析提供可扩展的基础。2.0.0版本基于PostgreSQL 14.x构建，主要亮点包括：分布式查询规划和执行的显著改进、增强的资源管理、改进的并行处理、动态表功能以及PAX存储格式的引入。此外，该版本还更新了许可证标头和依赖项属性，以满足ASF合规性要求。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-fa97c58a23.png"></p>
<p><strong>GreptimeDB v0.17 发布！Flow 现已支持 TQL（PromQL）</strong></p>
<p>9月5日，GreptimeDB v0.17版本正式发布。新版本增强了60项功能，如PromQL优化和TQL CTE支持，修复了32项错误，进行了2项性能优化，提升了稀疏编码器性能235%，改进了60项文档，并进行了1项测试优化和27项杂项任务。此外，Flow支持TQL（PromQL），Reconciliation Procedures功能可处理元数据备份恢复后与集群新数据不兼容的问题。</p>
<p><strong>IvorySQL 4.6 发布，全面支持 PostgreSQL 17.6</strong></p>
<p>9月5日，IvorySQL 4.6版本正式发布，全面支持PostgreSQL 17.6并带来多项新功能和已知问题的修复。增强功能包括加强规划器估计函数中的安全检查、防止pg_dump脚本被用于攻击等。新增特性有升级至PG 17.6内核、兼容MongoDB的解决方案、全平台LoongArch打包、IvorySQL在线试用、容器化部署支持（Docker Swarm和Kubernetes）以及IvorySQL Cloud v4.0发布。</p>
<p><strong>矩阵起源产品发布会发布MatrixOne与MatrixOne Intelligence</strong></p>
<p>9月12日，矩阵起源在上海举办“以数生智、以智驭数”产品发布会，正式推出两款战略级核心产品：超融合异构云原生数据库 MatrixOne (MO) 与 AI原生多模态数据智能平台 MatrixOne Intelligence (MOI)。<strong>超融合异构云原生数据库MatrixOne</strong>&nbsp;的核心是超融合架构，将 HTAP（混合事务/分析处理）、流处理、向量检索、全文搜索原生整合到同一引擎中，从根本上消除了长期困扰企业的数据孤岛问题。而平台的另一大创新是引入&nbsp;“数据的Git”新范式：通过将版本管理、分支、回滚、审计等软件工程理念引入数据管理，显著缩短了 AI 项目的开发周期，并加速跨团队协作，极大提升企业在复杂数据场景下的敏捷性。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-98d57c6e32.png"></p>
<ul>
<li><strong>AI原生多模态数据智能平台MatrixOne IntelligenceMOI</strong>&nbsp;产品的定位是下一代 Data Infrastructure，技术对标 Databricks + Snowflake，聚焦企业AI落地难题。MOI具备五大核心创新能力：融合架构实现数据统一管理，消除数据栈割裂；Agentic数据治理自动优化数据处理，降低人力依赖；智能数据解析高效处理非结构化数据，减少80%人工处理量；高性能运行底座支撑多并发业务；全链路安全保障确保数据安全与合规。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oss-emcsprod-public.modb.pro-155c8e8b9b.png"></p>
<ul>
<li>发布会还宣布了与多家企业及机构的战略合作：与赛意信息共创“AI+数字化工厂”，与辰奕智能合作加速AI在制造业落地。与上海云基地合作深化产业链联动，打造“方案孵化器”。此外，还与安畅网络、启数智能、迪际特科技等企业合作，推动AI在金融、制造、零售、公共安全、智慧城市等领域的应用落地。</li>
</ul>
<p><strong>云和恩墨2025秋季产品发布会线上举行</strong></p>
<p>9月12日，云和恩墨在2025年秋季产品发布会上推出了zData X、zCloud、zAIoT和MogDB等产品的最新版本，这些产品体现了公司在数据库一体机、智能化运维、数据智能和异构数据库迁移服务方面的最新进展。zData X 3.5版本展示了更高的性能、更优的成本和更易的运维；zCloud 6.7.2版本增强了对主流开源和国产数据库的兼容性和智能化运维能力；zAIoT 3.0版本在军工和工业制造领域的数据升值方面取得了显著成效；MogDB则通过“订阅使用”模式提供了商业发行版的企业级关系型数据库，用户只需支付服务费即可获得官方支持。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9f4a5b2c67.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-98c0a7d749.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4584d54e0a.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-b8033b27ad.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-68f9682f90.png"></p>
<p><strong>「Infra + AI 至简致远」DolphinDB 2025 年度峰会圆满举办</strong></p>
<p>9月12日，DolphinDB 2025年度峰会在杭州成功举办，吸引了近300位来自金融行业的嘉宾。DolphinDB 研发副总监程训焘博士通过《2025 DolphinDB 新产品发布》演讲，深入探讨了 DolphinDB 在实时计算领域的重大进展。程博士着重介绍了企业级实时计算平台 Orca&nbsp;的推出及其主要功能和优势。此外，程博士还介绍了 Swordfish 低延时嵌入式引擎和 Shark CPU/GPU 异构计算平台，展望了 DolphinDB 在 AI 时代的发展。此外，DolphinDB还发布了AI Agent，通过自我验证和迭代纠错机制，使AI更自然地融入金融研究与投资实践。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-46be047b3c.png"></p>
<ul>
<li><strong>Orca</strong>是DolphinDB推出的企业级实时计算平台，通过简化流计算任务的开发流程，支持多模态数据的统一处理，并提供针对金融等行业的专用数据模型，实现了企业级高可用性和跨地域协同计算。这一平台使得开发者能够以声明式方式描述流计算需求，自动生成计算图并智能规划资源，从而显著降低开发和运维的复杂性。Orca为企业在量化投研、物联网监控等场景提供了强大的实时计算支持。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-c040ece78b.png"></p>
<ul>
<li><strong>Swordfish</strong>是一款高性能计算函数库，专为<code>C++</code>程序设计，内含DolphinDB自研的计算内核，拥有超过2000个函数和流计算引擎。它通过在本地硬件上直接执行计算，避免了网络访问服务器的延迟，实现了十微秒甚至单微秒级的计算延迟，显著提升了高频计算任务的性能。Swordfish目前已支持C++和Java，未来还将推出Python版本。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e4d8c9fff0.png"></p>
<ul>
<li><strong>Shark</strong>是DolphinDB与海光信息合作开发的CPU/GPU异构计算平台，其核心组件Shark Graph并行计算引擎显著提升了性能，使因子挖掘速度提高了10倍以上，并且能够通过简单的“@GPU”标签实现DolphinDB脚本在GPU上的一键加速，性能提升可达10至20倍，同时减少CPU和内存占用。目前，Shark平台已支持海光DCU处理器，并计划继续优化国产处理器的性能和易用性，以提供更强大的计算能力。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-ee7ea33f10.png"></p>
<p><strong>腾讯云TDSQL自研产品家族扩容，数据库AI服务正式发布</strong></p>
<p>9月17日，在2025腾讯全球数字生态大会上，腾讯云正式公布自研数据库TDSQL全新产品家族，包含TDSQL（超大规模分布式关系型数据库）、TDSQL-C（云原生关系型数据库）、新亮相的TDSQL-B（超高性能分布式集群）三款产品，满足企业在智能化和全球化时代的不同场景需求；同时推出数据库AI服务（（TencentDB AI Service，简称TDAI））和业内首个AI自学习优化器，以AI技术驱动数据库进化。此外，腾讯云数据库启动第三届开放原子大赛——OpenTenBase多模态分析挑战赛和OpenTenBase-TXSQL SQL改写优化挑战赛，共60万奖金以激发开发者创新，举办生态伙伴颁奖仪式表彰优秀合作者，并发布学术生态建设成果。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-a2fff61047.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-fe51a4676d.png"></p>
<ul>
<li><strong>TDSQL-B</strong>：本次大会重磅发布的专为敏态业务打造的超高性能分布式集群，特别适用于金融场景和高增长业务。TDSQL-B 聚焦三大核心能力。首先是金融级高可靠，通过多副本容灾和快速故障恢复，实现数据零丢失、服务零中断。其次是性能突破，具备百万级 QPS 处理能力与海量存储，同时拥有无限的 TP 扩展性与轻量 AP 能力，能够轻松应对电商大促订单峰值、直播弹幕互动等高并发事务场景。TDSQL-B 在语法兼容性方面 100% 兼容 MySQL，支持分钟级弹性扩缩容，既“好用如单机”，又能抗流量洪峰。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-f99e4a2951.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-6622f7dae9.png"></p>
<ul>
<li>腾讯云正式推出<strong>数据库AI服务</strong>（TencentDB AI Service，简称<strong>TDAI</strong>）旨在用AI帮助企业治理好数据库、用好数据。TDAI依托自研数据库大模型、全域上下文、工具集这三大智能体基础设施，构建了数据库DevOps与数据洞察两大核心场景的智能体服务，将智能体能力引入数据库治理。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9e332391a5.png"> <img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-03decc0157.png"></p>
<ul>
<li>腾讯云还推出了行业首个<strong>AI自学习优化器</strong>，突破传统优化器在复杂场景中的局限性。AI自学习优化器通过全局探索最优执行计划、可量化的数据反馈、动态适配代价模型，和反思演进这四大能力，让复杂查询时延降低80%以上。凭借这一创新，客户无需人力投入，即可实现数据库的自动调优。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2a7780ce94.png"></p>
<ul>
<li>开放原子开源基金会秘书长助理李博、腾讯云数据库总经理王义成与多位高校代表共同启动了&nbsp;<strong>OpenTenBase 5.0</strong>&nbsp;与&nbsp;<strong>TXSQL 8.0.30</strong>&nbsp;新版本发布仪式。本次重磅发布的OpenTenBase 5.0 版本在 Oracle 兼容性、分布式性能、HTAP 能力三个方向实现跨越式升级，全新支持 AI 多模态能力，支持灵活集成大模型，向 Data + AI 共生进化迈出坚实的一步。OpenTenBase 强势推出 opentenbase_ai 插件，为 OpenTenBase 数据库提供了集成人工智能大语言模型能力的接口，让你能够直接在 SQL 中使用 AI 能力。</li>
</ul>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-e918a72307.png"></p>
<blockquote>
<p>OpenAtom OpenTenBase 是一款企业级分布式 HTAP 开源数据库，是 TDSQL 的社区发行版，2023 年 12 月贡献给开放原子开源基金会，其已成功应用于金融、医疗、航天等行业的核心业务系统。TXSQL 是腾讯云数据库团队基于 MySQL 深度定制的企业级数据库内核，去年 9 月，腾讯云数据库向 OpenTenBase 社区捐赠了&nbsp;TXSQL&nbsp;内核。TXSQL 对 InnoDB 存储引擎、查询优化、复制性能等方面进行了大量优化，具有高安全、低成本、易维护等特性，具有透明列加密、透明列压缩、Undo 闪回查询等企业级特性。</p>
</blockquote>
<p><strong>时序数据库 TimechoDB V2.0.6 发布 | 新增查询写回、黑白名单等功能</strong></p>
<p>9月23日，TimechoDBV2.0.6 版本正式发布！TimechoDB 是由&nbsp;IoTDB原厂团队开发的企业级时序数据库产品。V2.0.6 版本新增表模型查询写回功能，新增访问控制黑白名单功能，新增位操作函数（内置标量函数）以及可下推的时间函数，同时对数据库监控、性能、稳定性进行了全方位提升。</p>
<p><strong>云栖重磅｜瑶池数据库：从云原生数据底座向“AI就绪”的多模态数据底座演进</strong></p>
<p>9月24日，云栖大会上，<strong>阿里云瑶池数据库</strong>宣布从云原生数据底座向“AI就绪”的多模态数据底座演进。瑶池数据库推出全球首款基于CXL 2.0 Switch技术的<strong>PolarDB</strong>数据库专用服务器，树立了内存池化新标杆。同时，瑶池数据库发布「基于湖仓库一体化」的多模数据智能管理平台，支持多模态数据管理，融合OLTP和OLAP能力，支持AI算子能力（AI in SQL），让AI应用开发更高效。此外，瑶池数据库还推出ApsaraDB Agent智能顾问，提供一站式、7×24小时不间断的云数据库智能顾问服务，帮助企业轻松“驾驭”数据。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0a2994ecb1.png"></p>
<p><strong>酷克数据推出企业级数据仓库HashData Lightning 2.0</strong></p>
<p>9月24日，酷克数据HashData推出了企业级数据仓库HashData Lightning 2.0，该版本基于Apache Cloudberry 2.0内核，增强了复杂查询优化、存储管控等功能，提供了更低延迟、更高稳定性和并发支撑能力。Lightning 2.0引入了新监控工具CBCC、灾备恢复工具CBDR，并集成了一站式数据科学与AI开发工具箱HashML，实现了数据准备到模型部署的闭环能力。</p>
<p><strong>为AI而生！源于清华的向量数据库VexDB产品发布</strong></p>
<p>9月25日，源于清华的数智引航公司发布了名为VexDB的向量数据库。李国良教授介绍：“VexDB的名字由‘Vector+X+Database’的缩写组成，代表着能释放无限可能的多模态向量数据库。”该产品是一款融合关系型数据库能力和多路语义检索能力的向量数据库，可支持百亿向量数据毫秒级结果查询，召回准确度稳定在99%以上，具备“高性能、大容量、高精度、强一致、高可用、高安全、易用性”的七大产品特性，适用于推荐系统、语义搜索、图像识别等核心应用，全方位满足AI时代复杂场景下的数据检索需求。数智引航目前开发了适用于企业级AI应用场景的VexDB商业版，以及适用于开发商、个人开发者和开源项目的VexDB开发版，开发版提供一年的免费试用。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-3e7fdf0e83.png"></p>
<h2>9月代表厂商大事记</h2>
<p>【<strong>KaiwuDB</strong>】<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972224902111440896%3F1016" target="_blank"><strong>《KaiwuDB 2025年9月大事记》</strong></a></p>
<p>&nbsp; &nbsp;&nbsp;<strong>看点速览</strong></p>
<ul>
<li>KaiwuDB 荣获 2025 年度“山东电子学会科学技术奖二等奖”</li>
<li>KWDB社区携手“开放原子校源行”走进河北工业大学</li>
<li>浪潮数据库(KaiwuDB)、华师大联合论文获国际顶会NeurIPS 2025收录</li>
</ul>
<h2>相关资料</h2>
<ul>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2FdbRank%3F1016" target="_blank">墨天轮中国数据库流行度排行榜-2025年10月已更新</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F189802%3F1016" target="_blank">墨天轮中国数据库流行度排行榜规则解读</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Ftopic%2F61684%3F1016" target="_blank">月度国产数据库大事记合辑</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Ftopic%2F4704%3F1016" target="_blank">中国数据库排行榜 - 月度解读</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fbid%3F%3F1016" target="_blank">国产数据库招投标信息汇总</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdoc%2F146946%3F1016" target="_blank">《OceanBase AI Data Infra解决方案白皮书》_2025.pdf</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdoc%2F147171%3F1016" target="_blank">《OceanBase 实时分析能力白皮书》.pdf</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.ccsa.org.cn%2Fdetail%2F%3Fid%3D55463%26title" target="_blank">《HTAP数据库技术要求》等五项数据库技术标准-中国通信标准化协会公告</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Ftopic%2F659774%3F1016" target="_blank">【合辑】数据库顶会 VLDB 2025 论文下载</a></li>
<li><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fbid%2F2378966%3F1016" target="_blank">广东移动2025年省建中心云自主可控数据库（分布式OLTP）采购项目_中标候选人公示</a></li>
</ul>
<p>点击阅读原文：<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2Fdb%2F1972592310860918784%3F1016" target="_blank">https://www.modb.pro/db/1972592310860918784</a></p>
<hr>
<p>欲了解更多可浏览<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fwww.modb.pro%2F%3F1016" target="_blank">墨天轮社区</a>，围绕数据人的学习成长提供一站式的全面服务，打造集新闻资讯、在线问答、活动直播、在线课程、文档阅览、资源下载、知识分享及在线运维为一体的统一平台，持续促进数据领域的知识传播和技术创新。</p>
<p>关注官方公众号： 墨天轮、 墨天轮平台、墨天轮成长营、数据库国产化 、数据库资讯</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2ce61ce7c1.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-2ce61ce7c1.png" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 17:10:42 +0800</pubDate>
  </item><item>
    <title><![CDATA[通义千问宣布推出 Qwen Chat Memory 功能]]></title>
    <link>https://www.oschina.net/news/377784</link>
    <itunes:title><![CDATA[通义千问宣布推出 Qwen Chat Memory 功能]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><span>阿里旗下通义千问（Qwen）宣布正式推出<span>&nbsp;</span></span>Qwen Chat Memory<span><span>&nbsp;</span>功能，</span>用户可通过<span>&nbsp;</span>chat.qwen.ai<span>&nbsp;</span>直接体验这一新功能<span>。</span></p>
<p><span>这意味着 Qwen 迎来了真正意义上的“长记忆”时代——它不仅能理解用户的上下文，还能主动保留重要信息，并在未来的对话中进行关联和回忆，让交流体验更自然、更贴近人类思维。</span></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4a7906062d.png"></p>
<p>据介绍，Qwen Chat Memory 可在多轮对话中记住用户的偏好、习惯及过往交流内容，从而在后续对话中提供更具连续性和个性化的响应。例如，它能记得你的工作内容、兴趣方向或常用语气风格，在下一次对话中自动调用相关背景，帮助用户节省重复说明的时间。</p>
<p>阿里方面表示，这一功能的推出标志着通义千问在多轮对话智能化方向上迈出关键一步，也将推动 Qwen 成为更贴近用户长期需求的智能助手。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><span>阿里旗下通义千问（Qwen）宣布正式推出<span>&nbsp;</span></span>Qwen Chat Memory<span><span>&nbsp;</span>功能，</span>用户可通过<span>&nbsp;</span>chat.qwen.ai<span>&nbsp;</span>直接体验这一新功能<span>。</span></p>
<p><span>这意味着 Qwen 迎来了真正意义上的“长记忆”时代——它不仅能理解用户的上下文，还能主动保留重要信息，并在未来的对话中进行关联和回忆，让交流体验更自然、更贴近人类思维。</span></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4a7906062d.png"></p>
<p>据介绍，Qwen Chat Memory 可在多轮对话中记住用户的偏好、习惯及过往交流内容，从而在后续对话中提供更具连续性和个性化的响应。例如，它能记得你的工作内容、兴趣方向或常用语气风格，在下一次对话中自动调用相关背景，帮助用户节省重复说明的时间。</p>
<p>阿里方面表示，这一功能的推出标志着通义千问在多轮对话智能化方向上迈出关键一步，也将推动 Qwen 成为更贴近用户长期需求的智能助手。</p>]]>
    </description>
    <content:encoded><![CDATA[<p><span>阿里旗下通义千问（Qwen）宣布正式推出<span>&nbsp;</span></span>Qwen Chat Memory<span><span>&nbsp;</span>功能，</span>用户可通过<span>&nbsp;</span>chat.qwen.ai<span>&nbsp;</span>直接体验这一新功能<span>。</span></p>
<p><span>这意味着 Qwen 迎来了真正意义上的“长记忆”时代——它不仅能理解用户的上下文，还能主动保留重要信息，并在未来的对话中进行关联和回忆，让交流体验更自然、更贴近人类思维。</span></p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4a7906062d.png"></p>
<p>据介绍，Qwen Chat Memory 可在多轮对话中记住用户的偏好、习惯及过往交流内容，从而在后续对话中提供更具连续性和个性化的响应。例如，它能记得你的工作内容、兴趣方向或常用语气风格，在下一次对话中自动调用相关背景，帮助用户节省重复说明的时间。</p>
<p>阿里方面表示，这一功能的推出标志着通义千问在多轮对话智能化方向上迈出关键一步，也将推动 Qwen 成为更贴近用户长期需求的智能助手。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4a7906062d.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-4a7906062d.png" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 17:04:09 +0800</pubDate>
  </item><item>
    <title><![CDATA[vivo HDFS EC 大规模落地实践]]></title>
    <link>https://my.oschina.net/vivotech/blog/18695773</link>
    <itunes:title><![CDATA[vivo HDFS EC 大规模落地实践]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<blockquote>
<p>作者：Gu Ruinan - 互联网大数据团队- Zhao Yongxiang</p>
<p>Erasure Coding(简称EC)，是一种纠删码。EC编码能够对部分缺失的数据进行数据恢复，广泛应用于存储与通信领域。在Hadoop3.0版本中，作为一种新的冗余存储的方式引入进来。使用EC编码的方式替代原来的三副本存储，保证数据可靠性的同时可以节约存储。相应地，付出的代价是读取性能的下降，对于访问频率不高的数据，使用EC编码很合适。</p>
<p>vivo目前HDFS集群节点达万台级别，数据规模接近EB级别，并且业务数据规模还在以较高速度持续增长中。在推进压缩算法缓解存储压力的同时，EC编码的推进也是存储降本的一大有力手段。</p>
</blockquote>
<p>1分钟看图掌握核心观点👇</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5663af9821.gif"></p>
<h1>一、背景</h1>
<p>Reed-Soloman编码(简称：RS码)，是EC里一种经典的编码算法。下面简单介绍一下Reed-Soloman编码过程(不涉及数学原理的详细解析)。</p>
<p>假设我们的输入数据以D1，D2，...D5的向量来表示，矩阵B为编码矩阵，进行编码后得到D和C组成的矩阵，其中D为数据块(data block)，C为校验块(parity block)。我们的数据写入都需要经过编码后才能进行存储。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-ed40bc3031.png" alt="图片"></p>
<p>假设我们抹除掉了D1，D4，C2。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9e39d4164e.png" alt="图片"></p>
<p>我们能通过编码矩阵得到一个用于恢复的矩阵，将这个矩阵与剩余块相乘，可得到原来完整的输入数据，再次进行编码后可恢复C2。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-f549f93b44.png" alt="图片"></p>
<h1>二、存储布局的改变</h1>
<p>EC编码对HDFS的应用，使数据块存储的结构发生了改变。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0f88f6ed6f.png" alt="图片"></p>
<p>在传统三副本的策略中，一个文件被划分为不同的块(block)进行存储，一个数据块对应三个副本(replication)，每个副本存储的内容完全一致，数据的存储时连续的，这种布局称为连续块存储布局(Contigous Block Layout)。</p>
<p>在EC策略中，一个文件被划分为不同的块组(Block Group)进行存储，一个块组内划分为多个内部块(Internal Block)，其中，内部块又分为数据块(Data Block)和校验块(Parity Block)。数据块存储文件的数据，校验块存储由数据块生成的校验内容。一个块组内，可容忍的块丢失数量与校验块数量相同，如果丢失块的数量大于校验块数量，则数据不可被恢复。</p>
<p>在块组中，数据并不像三副本策略一样连续存储在一个块中，而是将连续的数据拆分为多个Cell，分散存储在不同的内部块中，形成一个个条带(Stripe)。这种布局称为条带存储布局(Striped Block Layout)。</p>
<p>我们集群目前采用EC策略RS6-3-1024k，其中6表示块组中数据块数量，3表示块组中校验块数量，1024k表示Cell大小。</p>
<p>三副本是HDFS默认的冗余存储方式，优点是当有机器宕机，数据丢失时，不会影响用户的读取，补块的方式也仅仅是副本的复制，简单高效。缺点也很明显，存储的冗余度高，三副本的存储冗余度达到200%。</p>
<p>EC编码通过编码的存储方式，来进行冗余存储。优点是存储的冗余度低(具体的冗余度取决于不同的存储策略)，可靠性高。缺点是写入需要编码，造成性能的下降(大概3-4倍)，补块时间长(校验块越多，补块时间越长)，读取时如果遇到DN宕机，也需要额外的资源与时间进行解码恢复。</p>
<h1>三、HDFS EC 码应用实践</h1>
<h2>3.1 兼容性问题</h2>
<h3>3.1.1 服务端</h3>
<p>早在2020年，EC已经在vivo的HDFS集群中投入使用。EC是Hadoop3.0后推出的新特性，要想正常使用，服务端和客户端都需要升级到3.0或以上版本。</p>
<p>由于离线集群规模庞大，升级的调研和实施需要耗费比较长的时间。因此，我们临时搭建了一套基于3.1版本的冷备专用集群，使用EC来存储冷备数据，如下图：</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-c5b7fe514e.png" alt="图片"></p>
<p>冷备集群使用3.1版本的Yarn，可以同时访问热数据与冷数据，3.1版本的HDFS专门用来存储EC编码的冷数据。</p>
<p>由于新增冷备集群的方案增加了集群运维的成本，架构也不够优雅，只是暂时的解决办法。在2021年，我们离线集群完成了HDFS从2.6到3.1的全面升级，正式支持EC编码，在2022年，我们完成绝大部分冷备集群的数据到离线集群的迁移，增量数据全部写到离线集群中。</p>
<h3>3.1.2 客户端</h3>
<p>我们没有对Client2.x客户端访问EC文件做兼容性的开发，更多是通过推动用户升级客户端来访问EC文件，例如Spark2任务切换至Spark3任务。该方案增加了用户迁移的成本，但同时也减少了HDFS侧的开发成本，用户任务逐步往Spark3迁移也更符合未来的规划。</p>
<h2>3.2 EC 异步转换</h2>
<p>由于EC编码会带来对文件读写性能的下降，对EC编码的定位主要应用在冷数据的存储，业务并不直接写EC数据，而是采用后台转储的方式，把三副本数据转储成EC数据。对不同业务而言，对"冷"的标准都不一致，不能用统一的标准来衡量数据的冷热。在推广EC编码的过程中，平台并不用统一的标准来"强制"把用户数据转为EC，是否转为EC的最终决定权在用户。我们向用户提供分区访问频率的数据作为参考，帮助用户来了解不同分区路径的访问频次，让用户更好地选择哪些分区转为EC编码。用户可以通过大数据开发者平台(Big data developer platform)设置x天前的数据转为EC存储，后台程序会将相应分区通过Hadoop distcp，将三副本写入到已设置EC策略的目录中，再用新目录替换掉原目录，其中目录名称不变，保证了元数据一致，用户无需修改代码。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-33f5ae101f.png" alt="图片"></p>
<h2>3.3 Distcp 数据校验</h2>
<p>先来介绍一下HDFS两种校验和的方式。</p>
<h3>3.3.1 MD5MD5CRC</h3>
<p>此方式为HDFS默认的校验方式，这种校验方式会进行两次MD5计算一次CRC计算，从名字就可以反映出来。</p>
<ul>
<li> <p><strong>块级校验和</strong>：所有chunk CRC的级联的MD5值。（an MD5 of a concatenation of chunk CRCs）</p> </li>
<li> <p><strong>文件级校验和</strong>：所有块校验和的级联的MD5值。（the MD5 of the concatenation of all the block checksums）</p> </li>
</ul>
<p>由定义可知，这种方式对于HDFS分块大小敏感，不同的分块大小块级校验和不一样，导致文件校验和也会不一样。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-440ee80cf7.png" alt="图片"></p>
<h3>3.3.2 Composite CRC</h3>
<p>Composite CRC一个新的校验和计算方式。</p>
<p>当计算块校验和不是简单地将chunk CRC进行级联（concatenation），而是将chunk CRC进行数学式的组合（mathematically compose），计算文件校验和时对文件所有的chunk CRC进行数学式组合。因此，对于文件校验和，该计算方式对于分块大小并不敏感。 CRC算法相关论文。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-c6ffc53153.png" alt="图片"></p>
<p>在数据进行distcp的过程中，HDFS会进行校验和校验，确保distcp的源数据与新数据一致，但正如前文所说，EC编码会带来存储布局的改变，相同的文件三副本与EC数据存储的块大小，块数量都不一致，这让HDFS默认的MD5MD5CRC的方式变得不再适用。</p>
<p>需要将校验方式改为COMPOSITE CRC。</p>
<p>可通过 dfs.checksum.combine.mode 改变校验和校验的方式（MD5MD5CRC(默认值) or COMPOSITE_CRC)。</p>
<p>即使distcp过程中会进行校验，为了确保万无一失，我们还会对前后的分区目录的校验和校验。(目录校验和计算方式为将目录下文件MD5值排序，再进行MD5计算）为了保证转EC前后文件的一致性，多加一道校验的"工序"是值得的。</p>
<h2>3.4 文件损坏与修复</h2>
<p>文件损坏与丢块是HDFS EC应用绕不开的一个话题，原因是在Hadoop EC特性新推出的过程中，有若干与文件损坏相关的bug。EC文件损坏的过程主要发生在补块阶段，计算结果的不准确导致了新补的块与原来的块内容不一致。我们在EC推广的过程中，也狠狠地踩过文件损坏的"坑"。如何避免文件损坏，如何对补块的结果进行校验，如何修复损坏文件是三个重要的需要解决的问题。</p>
<h3>3.4.1 如何避免文件损坏</h3>
<p>通过对社区的调研，我们打了若干的patch来解决文件损坏与丢块的问题。</p>
<h3>3.4.2 对补块结果的校验</h3>
<p>我们引入了HDFS-15759，Patch提供了一个对EC补块的校验功能，在DN执行补块任务时，对补块结果进行校验。如果校验失败会抛出异常，并且补块任务会进行重试。</p>
<h3>3.4.3 EC批量校验工具</h3>
<p>我们对开源的EC批量校验工具进行了定制化的改造，工具能够对EC目录进行批量扫描，扫描出目录中的损坏的EC文件，在此感谢Stephen O'Donnell对工具的开源。</p>
<p>原理大致如下，对数据块进行EC编码，通过比对新生成的校验块和原来的校验块，来验证是否存在文件损坏。如果比对通过，则没有文件损坏，如果比对不通过，则存在文件损坏。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-80ad556a9b.png" alt="图片"></p>
<p>工具支持MR，可以分布式执行，此外，也可只对一个条带进行比对，只生成校验块的第一个条带，比对与原校验块第一个条带是否一致，这些都大大提高了批量校验EC文件的效率。</p>
<p>工具地址：</p>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsodonnel%2Fhdfs-ec-validator" target="_blank">https://github.com/sodonnel/hdfs-ec-validator</a></p>
<h3>3.4.4 修复损坏文件</h3>
<p>在我们的集群，绝大部分损坏的文件都是ORC文件，ORC文件发生损坏时，由于其元数据分布的方式，会出现元数据的损坏，ORC无法解析。</p>
<p>假设一个块组内，数据块编号为1~6，校验块编号为7~9，数据块1损坏，我们可以通过读取数据块2~6加上任一一个校验块，得到"完好"的文件，对于ORC文件而言，判断是否完好取决于能否正常解析。</p>
<p>HDFS客户端get文件的时候默认只会读取数据块，我们通过改造HDFS客户端，使我们能够读取块组内指定编号的块，通过各种排列组合，得到一个"完好"的文件，之后将"完好"的文件覆盖掉HDFS上的损坏文件，来达到文件修复的目的。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-ff7df263d5.png" alt="图片"></p>
<h2>3.5 机器异构&amp;存储策略</h2>
<p>由于EC数据访问频率低，将EC数据存储到大存储的机器上，利用机器异构降低我们的单位存储成本。</p>
<p>在HDFS中，如果文件写入的路径设置了hot存储策略的目录，则会优先把文件存储到disk存储介质当中，如果设置了cold存储策略的目录，则会优先把文件存储到archive存储介质当中。</p>
<p>因此，当我们将大存储机器的盘都设置为Archive，并且将EC目录设置为Cold存储策略，即可将EC数据存放到大存储机器上，使TCO降低，进一步实现存储降本。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-99835c9495.png" alt="图片"></p>
<h1>四、总结与展望</h1>
<p>vivo的HDFS集群已存有几百PB的数据采用EC-RS6-3-1024k策略存储，相比三副本EC-RS6-3-1024k方式能带来50%的存储收益，节省了数百PB的存储空间，为公司带来了巨大的收益。目前我们推荐用户将访问频次较少的数据转为EC，因为EC会带来读取性能的下降，如何减少EC带来的读取性能下降？以及后续细化对用户数据的冷热分层，对越冷的数据采用冗余度越低的EC策略，EC补块速度优化等，都是后续继续大规模推进EC需要解决的重要难题。</p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<blockquote>
<p>作者：Gu Ruinan - 互联网大数据团队- Zhao Yongxiang</p>
<p>Erasure Coding(简称EC)，是一种纠删码。EC编码能够对部分缺失的数据进行数据恢复，广泛应用于存储与通信领域。在Hadoop3.0版本中，作为一种新的冗余存储的方式引入进来。使用EC编码的方式替代原来的三副本存储，保证数据可靠性的同时可以节约存储。相应地，付出的代价是读取性能的下降，对于访问频率不高的数据，使用EC编码很合适。</p>
<p>vivo目前HDFS集群节点达万台级别，数据规模接近EB级别，并且业务数据规模还在以较高速度持续增长中。在推进压缩算法缓解存储压力的同时，EC编码的推进也是存储降本的一大有力手段。</p>
</blockquote>
<p>1分钟看图掌握核心观点👇</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5663af9821.gif"></p>
<h1>一、背景</h1>
<p>Reed-Soloman编码(简称：RS码)，是EC里一种经典的编码算法。下面简单介绍一下Reed-Soloman编码过程(不涉及数学原理的详细解析)。</p>
<p>假设我们的输入数据以D1，D2，...D5的向量来表示，矩阵B为编码矩阵，进行编码后得到D和C组成的矩阵，其中D为数据块(data block)，C为校验块(parity block)。我们的数据写入都需要经过编码后才能进行存储。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-ed40bc3031.png" alt="图片"></p>
<p>假设我们抹除掉了D1，D4，C2。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9e39d4164e.png" alt="图片"></p>
<p>我们能通过编码矩阵得到一个用于恢复的矩阵，将这个矩阵与剩余块相乘，可得到原来完整的输入数据，再次进行编码后可恢复C2。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-f549f93b44.png" alt="图片"></p>
<h1>二、存储布局的改变</h1>
<p>EC编码对HDFS的应用，使数据块存储的结构发生了改变。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0f88f6ed6f.png" alt="图片"></p>
<p>在传统三副本的策略中，一个文件被划分为不同的块(block)进行存储，一个数据块对应三个副本(replication)，每个副本存储的内容完全一致，数据的存储时连续的，这种布局称为连续块存储布局(Contigous Block Layout)。</p>
<p>在EC策略中，一个文件被划分为不同的块组(Block Group)进行存储，一个块组内划分为多个内部块(Internal Block)，其中，内部块又分为数据块(Data Block)和校验块(Parity Block)。数据块存储文件的数据，校验块存储由数据块生成的校验内容。一个块组内，可容忍的块丢失数量与校验块数量相同，如果丢失块的数量大于校验块数量，则数据不可被恢复。</p>
<p>在块组中，数据并不像三副本策略一样连续存储在一个块中，而是将连续的数据拆分为多个Cell，分散存储在不同的内部块中，形成一个个条带(Stripe)。这种布局称为条带存储布局(Striped Block Layout)。</p>
<p>我们集群目前采用EC策略RS6-3-1024k，其中6表示块组中数据块数量，3表示块组中校验块数量，1024k表示Cell大小。</p>
<p>三副本是HDFS默认的冗余存储方式，优点是当有机器宕机，数据丢失时，不会影响用户的读取，补块的方式也仅仅是副本的复制，简单高效。缺点也很明显，存储的冗余度高，三副本的存储冗余度达到200%。</p>
<p>EC编码通过编码的存储方式，来进行冗余存储。优点是存储的冗余度低(具体的冗余度取决于不同的存储策略)，可靠性高。缺点是写入需要编码，造成性能的下降(大概3-4倍)，补块时间长(校验块越多，补块时间越长)，读取时如果遇到DN宕机，也需要额外的资源与时间进行解码恢复。</p>
<h1>三、HDFS EC 码应用实践</h1>
<h2>3.1 兼容性问题</h2>
<h3>3.1.1 服务端</h3>
<p>早在2020年，EC已经在vivo的HDFS集群中投入使用。EC是Hadoop3.0后推出的新特性，要想正常使用，服务端和客户端都需要升级到3.0或以上版本。</p>
<p>由于离线集群规模庞大，升级的调研和实施需要耗费比较长的时间。因此，我们临时搭建了一套基于3.1版本的冷备专用集群，使用EC来存储冷备数据，如下图：</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-c5b7fe514e.png" alt="图片"></p>
<p>冷备集群使用3.1版本的Yarn，可以同时访问热数据与冷数据，3.1版本的HDFS专门用来存储EC编码的冷数据。</p>
<p>由于新增冷备集群的方案增加了集群运维的成本，架构也不够优雅，只是暂时的解决办法。在2021年，我们离线集群完成了HDFS从2.6到3.1的全面升级，正式支持EC编码，在2022年，我们完成绝大部分冷备集群的数据到离线集群的迁移，增量数据全部写到离线集群中。</p>
<h3>3.1.2 客户端</h3>
<p>我们没有对Client2.x客户端访问EC文件做兼容性的开发，更多是通过推动用户升级客户端来访问EC文件，例如Spark2任务切换至Spark3任务。该方案增加了用户迁移的成本，但同时也减少了HDFS侧的开发成本，用户任务逐步往Spark3迁移也更符合未来的规划。</p>
<h2>3.2 EC 异步转换</h2>
<p>由于EC编码会带来对文件读写性能的下降，对EC编码的定位主要应用在冷数据的存储，业务并不直接写EC数据，而是采用后台转储的方式，把三副本数据转储成EC数据。对不同业务而言，对"冷"的标准都不一致，不能用统一的标准来衡量数据的冷热。在推广EC编码的过程中，平台并不用统一的标准来"强制"把用户数据转为EC，是否转为EC的最终决定权在用户。我们向用户提供分区访问频率的数据作为参考，帮助用户来了解不同分区路径的访问频次，让用户更好地选择哪些分区转为EC编码。用户可以通过大数据开发者平台(Big data developer platform)设置x天前的数据转为EC存储，后台程序会将相应分区通过Hadoop distcp，将三副本写入到已设置EC策略的目录中，再用新目录替换掉原目录，其中目录名称不变，保证了元数据一致，用户无需修改代码。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-33f5ae101f.png" alt="图片"></p>
<h2>3.3 Distcp 数据校验</h2>
<p>先来介绍一下HDFS两种校验和的方式。</p>
<h3>3.3.1 MD5MD5CRC</h3>
<p>此方式为HDFS默认的校验方式，这种校验方式会进行两次MD5计算一次CRC计算，从名字就可以反映出来。</p>
<ul>
<li> <p><strong>块级校验和</strong>：所有chunk CRC的级联的MD5值。（an MD5 of a concatenation of chunk CRCs）</p> </li>
<li> <p><strong>文件级校验和</strong>：所有块校验和的级联的MD5值。（the MD5 of the concatenation of all the block checksums）</p> </li>
</ul>
<p>由定义可知，这种方式对于HDFS分块大小敏感，不同的分块大小块级校验和不一样，导致文件校验和也会不一样。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-440ee80cf7.png" alt="图片"></p>
<h3>3.3.2 Composite CRC</h3>
<p>Composite CRC一个新的校验和计算方式。</p>
<p>当计算块校验和不是简单地将chunk CRC进行级联（concatenation），而是将chunk CRC进行数学式的组合（mathematically compose），计算文件校验和时对文件所有的chunk CRC进行数学式组合。因此，对于文件校验和，该计算方式对于分块大小并不敏感。 CRC算法相关论文。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-c6ffc53153.png" alt="图片"></p>
<p>在数据进行distcp的过程中，HDFS会进行校验和校验，确保distcp的源数据与新数据一致，但正如前文所说，EC编码会带来存储布局的改变，相同的文件三副本与EC数据存储的块大小，块数量都不一致，这让HDFS默认的MD5MD5CRC的方式变得不再适用。</p>
<p>需要将校验方式改为COMPOSITE CRC。</p>
<p>可通过 dfs.checksum.combine.mode 改变校验和校验的方式（MD5MD5CRC(默认值) or COMPOSITE_CRC)。</p>
<p>即使distcp过程中会进行校验，为了确保万无一失，我们还会对前后的分区目录的校验和校验。(目录校验和计算方式为将目录下文件MD5值排序，再进行MD5计算）为了保证转EC前后文件的一致性，多加一道校验的"工序"是值得的。</p>
<h2>3.4 文件损坏与修复</h2>
<p>文件损坏与丢块是HDFS EC应用绕不开的一个话题，原因是在Hadoop EC特性新推出的过程中，有若干与文件损坏相关的bug。EC文件损坏的过程主要发生在补块阶段，计算结果的不准确导致了新补的块与原来的块内容不一致。我们在EC推广的过程中，也狠狠地踩过文件损坏的"坑"。如何避免文件损坏，如何对补块的结果进行校验，如何修复损坏文件是三个重要的需要解决的问题。</p>
<h3>3.4.1 如何避免文件损坏</h3>
<p>通过对社区的调研，我们打了若干的patch来解决文件损坏与丢块的问题。</p>
<h3>3.4.2 对补块结果的校验</h3>
<p>我们引入了HDFS-15759，Patch提供了一个对EC补块的校验功能，在DN执行补块任务时，对补块结果进行校验。如果校验失败会抛出异常，并且补块任务会进行重试。</p>
<h3>3.4.3 EC批量校验工具</h3>
<p>我们对开源的EC批量校验工具进行了定制化的改造，工具能够对EC目录进行批量扫描，扫描出目录中的损坏的EC文件，在此感谢Stephen O'Donnell对工具的开源。</p>
<p>原理大致如下，对数据块进行EC编码，通过比对新生成的校验块和原来的校验块，来验证是否存在文件损坏。如果比对通过，则没有文件损坏，如果比对不通过，则存在文件损坏。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-80ad556a9b.png" alt="图片"></p>
<p>工具支持MR，可以分布式执行，此外，也可只对一个条带进行比对，只生成校验块的第一个条带，比对与原校验块第一个条带是否一致，这些都大大提高了批量校验EC文件的效率。</p>
<p>工具地址：</p>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsodonnel%2Fhdfs-ec-validator" target="_blank">https://github.com/sodonnel/hdfs-ec-validator</a></p>
<h3>3.4.4 修复损坏文件</h3>
<p>在我们的集群，绝大部分损坏的文件都是ORC文件，ORC文件发生损坏时，由于其元数据分布的方式，会出现元数据的损坏，ORC无法解析。</p>
<p>假设一个块组内，数据块编号为1~6，校验块编号为7~9，数据块1损坏，我们可以通过读取数据块2~6加上任一一个校验块，得到"完好"的文件，对于ORC文件而言，判断是否完好取决于能否正常解析。</p>
<p>HDFS客户端get文件的时候默认只会读取数据块，我们通过改造HDFS客户端，使我们能够读取块组内指定编号的块，通过各种排列组合，得到一个"完好"的文件，之后将"完好"的文件覆盖掉HDFS上的损坏文件，来达到文件修复的目的。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-ff7df263d5.png" alt="图片"></p>
<h2>3.5 机器异构&amp;存储策略</h2>
<p>由于EC数据访问频率低，将EC数据存储到大存储的机器上，利用机器异构降低我们的单位存储成本。</p>
<p>在HDFS中，如果文件写入的路径设置了hot存储策略的目录，则会优先把文件存储到disk存储介质当中，如果设置了cold存储策略的目录，则会优先把文件存储到archive存储介质当中。</p>
<p>因此，当我们将大存储机器的盘都设置为Archive，并且将EC目录设置为Cold存储策略，即可将EC数据存放到大存储机器上，使TCO降低，进一步实现存储降本。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-99835c9495.png" alt="图片"></p>
<h1>四、总结与展望</h1>
<p>vivo的HDFS集群已存有几百PB的数据采用EC-RS6-3-1024k策略存储，相比三副本EC-RS6-3-1024k方式能带来50%的存储收益，节省了数百PB的存储空间，为公司带来了巨大的收益。目前我们推荐用户将访问频次较少的数据转为EC，因为EC会带来读取性能的下降，如何减少EC带来的读取性能下降？以及后续细化对用户数据的冷热分层，对越冷的数据采用冗余度越低的EC策略，EC补块速度优化等，都是后续继续大规模推进EC需要解决的重要难题。</p>]]>
    </description>
    <content:encoded><![CDATA[<blockquote>
<p>作者：Gu Ruinan - 互联网大数据团队- Zhao Yongxiang</p>
<p>Erasure Coding(简称EC)，是一种纠删码。EC编码能够对部分缺失的数据进行数据恢复，广泛应用于存储与通信领域。在Hadoop3.0版本中，作为一种新的冗余存储的方式引入进来。使用EC编码的方式替代原来的三副本存储，保证数据可靠性的同时可以节约存储。相应地，付出的代价是读取性能的下降，对于访问频率不高的数据，使用EC编码很合适。</p>
<p>vivo目前HDFS集群节点达万台级别，数据规模接近EB级别，并且业务数据规模还在以较高速度持续增长中。在推进压缩算法缓解存储压力的同时，EC编码的推进也是存储降本的一大有力手段。</p>
</blockquote>
<p>1分钟看图掌握核心观点👇</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5663af9821.gif"></p>
<h1>一、背景</h1>
<p>Reed-Soloman编码(简称：RS码)，是EC里一种经典的编码算法。下面简单介绍一下Reed-Soloman编码过程(不涉及数学原理的详细解析)。</p>
<p>假设我们的输入数据以D1，D2，...D5的向量来表示，矩阵B为编码矩阵，进行编码后得到D和C组成的矩阵，其中D为数据块(data block)，C为校验块(parity block)。我们的数据写入都需要经过编码后才能进行存储。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-ed40bc3031.png" alt="图片"></p>
<p>假设我们抹除掉了D1，D4，C2。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9e39d4164e.png" alt="图片"></p>
<p>我们能通过编码矩阵得到一个用于恢复的矩阵，将这个矩阵与剩余块相乘，可得到原来完整的输入数据，再次进行编码后可恢复C2。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-f549f93b44.png" alt="图片"></p>
<h1>二、存储布局的改变</h1>
<p>EC编码对HDFS的应用，使数据块存储的结构发生了改变。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-0f88f6ed6f.png" alt="图片"></p>
<p>在传统三副本的策略中，一个文件被划分为不同的块(block)进行存储，一个数据块对应三个副本(replication)，每个副本存储的内容完全一致，数据的存储时连续的，这种布局称为连续块存储布局(Contigous Block Layout)。</p>
<p>在EC策略中，一个文件被划分为不同的块组(Block Group)进行存储，一个块组内划分为多个内部块(Internal Block)，其中，内部块又分为数据块(Data Block)和校验块(Parity Block)。数据块存储文件的数据，校验块存储由数据块生成的校验内容。一个块组内，可容忍的块丢失数量与校验块数量相同，如果丢失块的数量大于校验块数量，则数据不可被恢复。</p>
<p>在块组中，数据并不像三副本策略一样连续存储在一个块中，而是将连续的数据拆分为多个Cell，分散存储在不同的内部块中，形成一个个条带(Stripe)。这种布局称为条带存储布局(Striped Block Layout)。</p>
<p>我们集群目前采用EC策略RS6-3-1024k，其中6表示块组中数据块数量，3表示块组中校验块数量，1024k表示Cell大小。</p>
<p>三副本是HDFS默认的冗余存储方式，优点是当有机器宕机，数据丢失时，不会影响用户的读取，补块的方式也仅仅是副本的复制，简单高效。缺点也很明显，存储的冗余度高，三副本的存储冗余度达到200%。</p>
<p>EC编码通过编码的存储方式，来进行冗余存储。优点是存储的冗余度低(具体的冗余度取决于不同的存储策略)，可靠性高。缺点是写入需要编码，造成性能的下降(大概3-4倍)，补块时间长(校验块越多，补块时间越长)，读取时如果遇到DN宕机，也需要额外的资源与时间进行解码恢复。</p>
<h1>三、HDFS EC 码应用实践</h1>
<h2>3.1 兼容性问题</h2>
<h3>3.1.1 服务端</h3>
<p>早在2020年，EC已经在vivo的HDFS集群中投入使用。EC是Hadoop3.0后推出的新特性，要想正常使用，服务端和客户端都需要升级到3.0或以上版本。</p>
<p>由于离线集群规模庞大，升级的调研和实施需要耗费比较长的时间。因此，我们临时搭建了一套基于3.1版本的冷备专用集群，使用EC来存储冷备数据，如下图：</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-c5b7fe514e.png" alt="图片"></p>
<p>冷备集群使用3.1版本的Yarn，可以同时访问热数据与冷数据，3.1版本的HDFS专门用来存储EC编码的冷数据。</p>
<p>由于新增冷备集群的方案增加了集群运维的成本，架构也不够优雅，只是暂时的解决办法。在2021年，我们离线集群完成了HDFS从2.6到3.1的全面升级，正式支持EC编码，在2022年，我们完成绝大部分冷备集群的数据到离线集群的迁移，增量数据全部写到离线集群中。</p>
<h3>3.1.2 客户端</h3>
<p>我们没有对Client2.x客户端访问EC文件做兼容性的开发，更多是通过推动用户升级客户端来访问EC文件，例如Spark2任务切换至Spark3任务。该方案增加了用户迁移的成本，但同时也减少了HDFS侧的开发成本，用户任务逐步往Spark3迁移也更符合未来的规划。</p>
<h2>3.2 EC 异步转换</h2>
<p>由于EC编码会带来对文件读写性能的下降，对EC编码的定位主要应用在冷数据的存储，业务并不直接写EC数据，而是采用后台转储的方式，把三副本数据转储成EC数据。对不同业务而言，对"冷"的标准都不一致，不能用统一的标准来衡量数据的冷热。在推广EC编码的过程中，平台并不用统一的标准来"强制"把用户数据转为EC，是否转为EC的最终决定权在用户。我们向用户提供分区访问频率的数据作为参考，帮助用户来了解不同分区路径的访问频次，让用户更好地选择哪些分区转为EC编码。用户可以通过大数据开发者平台(Big data developer platform)设置x天前的数据转为EC存储，后台程序会将相应分区通过Hadoop distcp，将三副本写入到已设置EC策略的目录中，再用新目录替换掉原目录，其中目录名称不变，保证了元数据一致，用户无需修改代码。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-33f5ae101f.png" alt="图片"></p>
<h2>3.3 Distcp 数据校验</h2>
<p>先来介绍一下HDFS两种校验和的方式。</p>
<h3>3.3.1 MD5MD5CRC</h3>
<p>此方式为HDFS默认的校验方式，这种校验方式会进行两次MD5计算一次CRC计算，从名字就可以反映出来。</p>
<ul>
<li> <p><strong>块级校验和</strong>：所有chunk CRC的级联的MD5值。（an MD5 of a concatenation of chunk CRCs）</p> </li>
<li> <p><strong>文件级校验和</strong>：所有块校验和的级联的MD5值。（the MD5 of the concatenation of all the block checksums）</p> </li>
</ul>
<p>由定义可知，这种方式对于HDFS分块大小敏感，不同的分块大小块级校验和不一样，导致文件校验和也会不一样。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-440ee80cf7.png" alt="图片"></p>
<h3>3.3.2 Composite CRC</h3>
<p>Composite CRC一个新的校验和计算方式。</p>
<p>当计算块校验和不是简单地将chunk CRC进行级联（concatenation），而是将chunk CRC进行数学式的组合（mathematically compose），计算文件校验和时对文件所有的chunk CRC进行数学式组合。因此，对于文件校验和，该计算方式对于分块大小并不敏感。 CRC算法相关论文。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-c6ffc53153.png" alt="图片"></p>
<p>在数据进行distcp的过程中，HDFS会进行校验和校验，确保distcp的源数据与新数据一致，但正如前文所说，EC编码会带来存储布局的改变，相同的文件三副本与EC数据存储的块大小，块数量都不一致，这让HDFS默认的MD5MD5CRC的方式变得不再适用。</p>
<p>需要将校验方式改为COMPOSITE CRC。</p>
<p>可通过 dfs.checksum.combine.mode 改变校验和校验的方式（MD5MD5CRC(默认值) or COMPOSITE_CRC)。</p>
<p>即使distcp过程中会进行校验，为了确保万无一失，我们还会对前后的分区目录的校验和校验。(目录校验和计算方式为将目录下文件MD5值排序，再进行MD5计算）为了保证转EC前后文件的一致性，多加一道校验的"工序"是值得的。</p>
<h2>3.4 文件损坏与修复</h2>
<p>文件损坏与丢块是HDFS EC应用绕不开的一个话题，原因是在Hadoop EC特性新推出的过程中，有若干与文件损坏相关的bug。EC文件损坏的过程主要发生在补块阶段，计算结果的不准确导致了新补的块与原来的块内容不一致。我们在EC推广的过程中，也狠狠地踩过文件损坏的"坑"。如何避免文件损坏，如何对补块的结果进行校验，如何修复损坏文件是三个重要的需要解决的问题。</p>
<h3>3.4.1 如何避免文件损坏</h3>
<p>通过对社区的调研，我们打了若干的patch来解决文件损坏与丢块的问题。</p>
<h3>3.4.2 对补块结果的校验</h3>
<p>我们引入了HDFS-15759，Patch提供了一个对EC补块的校验功能，在DN执行补块任务时，对补块结果进行校验。如果校验失败会抛出异常，并且补块任务会进行重试。</p>
<h3>3.4.3 EC批量校验工具</h3>
<p>我们对开源的EC批量校验工具进行了定制化的改造，工具能够对EC目录进行批量扫描，扫描出目录中的损坏的EC文件，在此感谢Stephen O'Donnell对工具的开源。</p>
<p>原理大致如下，对数据块进行EC编码，通过比对新生成的校验块和原来的校验块，来验证是否存在文件损坏。如果比对通过，则没有文件损坏，如果比对不通过，则存在文件损坏。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-80ad556a9b.png" alt="图片"></p>
<p>工具支持MR，可以分布式执行，此外，也可只对一个条带进行比对，只生成校验块的第一个条带，比对与原校验块第一个条带是否一致，这些都大大提高了批量校验EC文件的效率。</p>
<p>工具地址：</p>
<p><a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fgithub.com%2Fsodonnel%2Fhdfs-ec-validator" target="_blank">https://github.com/sodonnel/hdfs-ec-validator</a></p>
<h3>3.4.4 修复损坏文件</h3>
<p>在我们的集群，绝大部分损坏的文件都是ORC文件，ORC文件发生损坏时，由于其元数据分布的方式，会出现元数据的损坏，ORC无法解析。</p>
<p>假设一个块组内，数据块编号为1~6，校验块编号为7~9，数据块1损坏，我们可以通过读取数据块2~6加上任一一个校验块，得到"完好"的文件，对于ORC文件而言，判断是否完好取决于能否正常解析。</p>
<p>HDFS客户端get文件的时候默认只会读取数据块，我们通过改造HDFS客户端，使我们能够读取块组内指定编号的块，通过各种排列组合，得到一个"完好"的文件，之后将"完好"的文件覆盖掉HDFS上的损坏文件，来达到文件修复的目的。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-ff7df263d5.png" alt="图片"></p>
<h2>3.5 机器异构&amp;存储策略</h2>
<p>由于EC数据访问频率低，将EC数据存储到大存储的机器上，利用机器异构降低我们的单位存储成本。</p>
<p>在HDFS中，如果文件写入的路径设置了hot存储策略的目录，则会优先把文件存储到disk存储介质当中，如果设置了cold存储策略的目录，则会优先把文件存储到archive存储介质当中。</p>
<p>因此，当我们将大存储机器的盘都设置为Archive，并且将EC目录设置为Cold存储策略，即可将EC数据存放到大存储机器上，使TCO降低，进一步实现存储降本。</p>
<p><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-99835c9495.png" alt="图片"></p>
<h1>四、总结与展望</h1>
<p>vivo的HDFS集群已存有几百PB的数据采用EC-RS6-3-1024k策略存储，相比三副本EC-RS6-3-1024k方式能带来50%的存储收益，节省了数百PB的存储空间，为公司带来了巨大的收益。目前我们推荐用户将访问频次较少的数据转为EC，因为EC会带来读取性能的下降，如何减少EC带来的读取性能下降？以及后续细化对用户数据的冷热分层，对越冷的数据采用冗余度越低的EC策略，EC补块速度优化等，都是后续继续大规模推进EC需要解决的重要难题。</p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5663af9821.gif"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-5663af9821.gif" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 15:36:24 +0800</pubDate>
  </item><item>
    <title><![CDATA[豆包语音合成模型 2.0 升级，语义理解+情感演绎双突破]]></title>
    <link>https://www.oschina.net/news/377759</link>
    <itunes:title><![CDATA[豆包语音合成模型 2.0 升级，语义理解+情感演绎双突破]]></itunes:title>
    <itunes:author><![CDATA[OSCHINA 社区最新新闻[RSS+]]]></itunes:author>
    <itunes:summary>
      <![CDATA[<p><span>火山引擎<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F9QvctKYTW0TNDv2856uxTw" target="_blank">宣布</a>升级豆包语音合成模型2.0（Doubao-Seed-TTS 2.0）和豆包声音复刻模型2.0（Doubao-Seed-ICL 2.0）。此次升级基于豆包大语言模型研发语音合成新架构，让合成和复刻的声音都能解锁深度语义理解和上下文理解能力，从单纯的文本朗读进化为“理解后的精准情感表达”。</span></p>
<p><span>此外2.0模型针对教育场景专项优化，使得全科复杂公式符号的合成平均准确率高达90%左右。</span></p>
<p><span>公告称，对话式合成让豆包语音合成模型2.0像是一位会思考的“演绎者”，让声音具备深度语义理解能力，并进一步将理解范围从给定文本扩大到多轮对话，理解包括：对话中的用户 Query、明确的自然语音指令，以及描述性的内心活动、背景信息、细腻情感等，让 AI 语音从“听得清”转变到“懂语义知语境”的情感式表达。</span></p>
<p><span>对话式语音合成具备3大核心优势：</span></p>
<ul>
<li><span>更强的互动拟人感：精准呈现与场景匹配的语气、语调、停顿等，让交互充满真实人际沟通的自然感。</span></li>
<li><span>更饱满的情感演绎：深度理解文字背后的情绪延续与变化，让声音的情绪承接更饱满连贯。</span></li>
<li><span>更精准的指令遵循：实现语速、情绪、声线、风格、音调的精准指令控制，提升语音表现可控性。</span></li>
</ul>
<p><span>豆包声音复刻模型2.0同样具有深度语义理解能力，在语音交互、小说配音、播客对话等场景中具备更强的声音表现力。</span></p>
<p><span>此外，豆包语音合成模型2.0和豆包声音复刻模型2.0提升了学科教育场景下复杂公式符号的朗读表现，针对教育场景进行数据增广与模型优化，涵盖单位、函数、幂数、面积、化合物、复分解等上百种类，经过大量客户真实场景的复杂公式评测集测试验证，在小学至高中全学科（数学、英语、化学、物理、地理、生物）的复杂公式符号朗读任务中，平均准确率达90%左右。</span></p>
<p><span><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9dba7e6834.png"></span></p>]]>
    </itunes:summary>
    <description>
      <![CDATA[<p><span>火山引擎<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F9QvctKYTW0TNDv2856uxTw" target="_blank">宣布</a>升级豆包语音合成模型2.0（Doubao-Seed-TTS 2.0）和豆包声音复刻模型2.0（Doubao-Seed-ICL 2.0）。此次升级基于豆包大语言模型研发语音合成新架构，让合成和复刻的声音都能解锁深度语义理解和上下文理解能力，从单纯的文本朗读进化为“理解后的精准情感表达”。</span></p>
<p><span>此外2.0模型针对教育场景专项优化，使得全科复杂公式符号的合成平均准确率高达90%左右。</span></p>
<p><span>公告称，对话式合成让豆包语音合成模型2.0像是一位会思考的“演绎者”，让声音具备深度语义理解能力，并进一步将理解范围从给定文本扩大到多轮对话，理解包括：对话中的用户 Query、明确的自然语音指令，以及描述性的内心活动、背景信息、细腻情感等，让 AI 语音从“听得清”转变到“懂语义知语境”的情感式表达。</span></p>
<p><span>对话式语音合成具备3大核心优势：</span></p>
<ul>
<li><span>更强的互动拟人感：精准呈现与场景匹配的语气、语调、停顿等，让交互充满真实人际沟通的自然感。</span></li>
<li><span>更饱满的情感演绎：深度理解文字背后的情绪延续与变化，让声音的情绪承接更饱满连贯。</span></li>
<li><span>更精准的指令遵循：实现语速、情绪、声线、风格、音调的精准指令控制，提升语音表现可控性。</span></li>
</ul>
<p><span>豆包声音复刻模型2.0同样具有深度语义理解能力，在语音交互、小说配音、播客对话等场景中具备更强的声音表现力。</span></p>
<p><span>此外，豆包语音合成模型2.0和豆包声音复刻模型2.0提升了学科教育场景下复杂公式符号的朗读表现，针对教育场景进行数据增广与模型优化，涵盖单位、函数、幂数、面积、化合物、复分解等上百种类，经过大量客户真实场景的复杂公式评测集测试验证，在小学至高中全学科（数学、英语、化学、物理、地理、生物）的复杂公式符号朗读任务中，平均准确率达90%左右。</span></p>
<p><span><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9dba7e6834.png"></span></p>]]>
    </description>
    <content:encoded><![CDATA[<p><span>火山引擎<a href="https://www.oschina.net/action/GoToLink?url=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F9QvctKYTW0TNDv2856uxTw" target="_blank">宣布</a>升级豆包语音合成模型2.0（Doubao-Seed-TTS 2.0）和豆包声音复刻模型2.0（Doubao-Seed-ICL 2.0）。此次升级基于豆包大语言模型研发语音合成新架构，让合成和复刻的声音都能解锁深度语义理解和上下文理解能力，从单纯的文本朗读进化为“理解后的精准情感表达”。</span></p>
<p><span>此外2.0模型针对教育场景专项优化，使得全科复杂公式符号的合成平均准确率高达90%左右。</span></p>
<p><span>公告称，对话式合成让豆包语音合成模型2.0像是一位会思考的“演绎者”，让声音具备深度语义理解能力，并进一步将理解范围从给定文本扩大到多轮对话，理解包括：对话中的用户 Query、明确的自然语音指令，以及描述性的内心活动、背景信息、细腻情感等，让 AI 语音从“听得清”转变到“懂语义知语境”的情感式表达。</span></p>
<p><span>对话式语音合成具备3大核心优势：</span></p>
<ul>
<li><span>更强的互动拟人感：精准呈现与场景匹配的语气、语调、停顿等，让交互充满真实人际沟通的自然感。</span></li>
<li><span>更饱满的情感演绎：深度理解文字背后的情绪延续与变化，让声音的情绪承接更饱满连贯。</span></li>
<li><span>更精准的指令遵循：实现语速、情绪、声线、风格、音调的精准指令控制，提升语音表现可控性。</span></li>
</ul>
<p><span>豆包声音复刻模型2.0同样具有深度语义理解能力，在语音交互、小说配音、播客对话等场景中具备更强的声音表现力。</span></p>
<p><span>此外，豆包语音合成模型2.0和豆包声音复刻模型2.0提升了学科教育场景下复杂公式符号的朗读表现，针对教育场景进行数据增广与模型优化，涵盖单位、函数、幂数、面积、化合物、复分解等上百种类，经过大量客户真实场景的复杂公式评测集测试验证，在小学至高中全学科（数学、英语、化学、物理、地理、生物）的复杂公式符号朗读任务中，平均准确率达90%左右。</span></p>
<p><span><img src="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9dba7e6834.png"></span></p>]]></content:encoded>
    <itunes:image href="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9dba7e6834.png"/>
          <media:content url="https://democwise2016.github.io/action-RSS-Fulltext/file-cache/oscimg.oschina.net-9dba7e6834.png" medium="image"/>
    <pubDate>Thu, 16 Oct 2025 15:09:58 +0800</pubDate>
  </item></channel>
</rss>